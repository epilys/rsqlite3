#![allow(dead_code, mutable_transmutes, non_camel_case_types, non_snake_case,
         non_upper_case_globals, unused_assignments, unused_mut)]
#![register_tool(c2rust)]
#![feature(c_variadic, 
           core_intrinsics, extern_types,
           register_tool)]


mod lib;
use std::ops::DerefMut;

use crate::lib::*;

use ::libc;
use ::libc::{FILE,};
use std::mem::ManuallyDrop;
extern "C" {
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn exit(_: libc::c_int) -> !;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
        -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fgets(__s: *mut libc::c_char, __n: libc::c_int, __stream: *mut FILE) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn rewind(__stream: *mut FILE);
    /* popen and pclose are not C89 functions and so are
     ** sometimes omitted from the <stdio.h> header */
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const libc::c_int;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn getuid() -> __uid_t;
    /* Make sure isatty() has a prototype. */
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
    fn readlink(__path: *const libc::c_char, __buf: *mut libc::c_char, __len: size_t) -> ssize_t;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn readline(_: *const libc::c_char) -> *mut libc::c_char;
    static mut rl_attempted_completion_function: Option<rl_completion_func_t>;
    static mut rl_attempted_completion_over: libc::c_int;
    fn rl_completion_matches(
        _: *const libc::c_char,
        _: Option<rl_compentry_func_t>,
    ) -> *mut *mut libc::c_char;
    fn time(__timer: *mut time_t) -> time_t;
    fn add_history(_: *const libc::c_char);
    fn stifle_history(_: libc::c_int);
    fn write_history(_: *const libc::c_char) -> libc::c_int;
    fn read_history(_: *const libc::c_char) -> libc::c_int;
    fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    fn zlibVersion() -> *const libc::c_char;
    fn deflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn deflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
    fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn compressBound(sourceLen: uLong) -> uLong;
    fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
    fn deflateInit2_(
        strm: z_streamp,
        level: libc::c_int,
        method: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn inflateInit2_(
        strm: z_streamp,
        windowBits: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    pub type __dirstream;
    pub type internal_state;
}
/*
extern "C" {
    pub type _IO_wide_data;
    pub type _IO_codecvt;
    pub type _IO_marker;
    pub type sqlite3;
    pub type sqlite3_api_routines;
    pub type sqlite3_stmt;
    pub type sqlite3_value;
    pub type sqlite3_context;
    pub type sqlite3_backup;
    pub type __dirstream;
    pub type internal_state;
    fn strtol(_: *const libc::c_char, _: *mut *mut libc::c_char, _: libc::c_int) -> libc::c_long;
    fn malloc(_: libc::c_ulong) -> *mut libc::c_void;
    fn realloc(_: *mut libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn free(__ptr: *mut libc::c_void);
    fn system(__command: *const libc::c_char) -> libc::c_int;
    fn getenv(__name: *const libc::c_char) -> *mut libc::c_char;
    fn exit(_: libc::c_int) -> !;
    fn memcpy(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> *mut libc::c_void;
    fn memmove(_: *mut libc::c_void, _: *const libc::c_void, _: libc::c_ulong)
        -> *mut libc::c_void;
    fn memset(_: *mut libc::c_void, _: libc::c_int, _: libc::c_ulong) -> *mut libc::c_void;
    fn memcmp(_: *const libc::c_void, _: *const libc::c_void, _: libc::c_ulong) -> libc::c_int;
    fn strncpy(_: *mut libc::c_char, _: *const libc::c_char, _: libc::c_ulong)
        -> *mut libc::c_char;
    fn strcmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn strncmp(_: *const libc::c_char, _: *const libc::c_char, _: libc::c_ulong) -> libc::c_int;
    fn strdup(_: *const libc::c_char) -> *mut libc::c_char;
    fn strchr(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
    fn strstr(_: *const libc::c_char, _: *const libc::c_char) -> *mut libc::c_char;
    fn strlen(_: *const libc::c_char) -> libc::c_ulong;
    static mut stdin: *mut FILE;
    static mut stdout: *mut FILE;
    static mut stderr: *mut FILE;
    fn fclose(__stream: *mut FILE) -> libc::c_int;
    fn fflush(__stream: *mut FILE) -> libc::c_int;
    fn fopen(_: *const libc::c_char, _: *const libc::c_char) -> *mut FILE;
    fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut libc::c_char,
        __modes: libc::c_int,
        __n: size_t,
    ) -> libc::c_int;
    fn fprintf(_: *mut FILE, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn printf(_: *const libc::c_char, _: ...) -> libc::c_int;
    fn sscanf(_: *const libc::c_char, _: *const libc::c_char, _: ...) -> libc::c_int;
    fn fgetc(__stream: *mut FILE) -> libc::c_int;
    fn fputc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn putc(__c: libc::c_int, __stream: *mut FILE) -> libc::c_int;
    fn fgets(__s: *mut libc::c_char, __n: libc::c_int, __stream: *mut FILE) -> *mut libc::c_char;
    fn fputs(__s: *const libc::c_char, __stream: *mut FILE) -> libc::c_int;
    fn fread(
        _: *mut libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fwrite(
        _: *const libc::c_void,
        _: libc::c_ulong,
        _: libc::c_ulong,
        _: *mut FILE,
    ) -> libc::c_ulong;
    fn fseek(__stream: *mut FILE, __off: libc::c_long, __whence: libc::c_int) -> libc::c_int;
    fn ftell(__stream: *mut FILE) -> libc::c_long;
    fn rewind(__stream: *mut FILE);
    /* popen and pclose are not C89 functions and so are
     ** sometimes omitted from the <stdio.h> header */
    fn popen(__command: *const libc::c_char, __modes: *const libc::c_char) -> *mut FILE;
    fn pclose(__stream: *mut FILE) -> libc::c_int;
    fn sqlite3_libversion() -> *const libc::c_char;
    fn sqlite3_sourceid() -> *const libc::c_char;
    fn sqlite3_libversion_number() -> libc::c_int;
    fn sqlite3_close(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_exec(
        _: *mut sqlite3,
        sql: *const libc::c_char,
        callback_0: Option<
            unsafe extern "C" fn(
                _: *mut libc::c_void,
                _: libc::c_int,
                _: *mut *mut libc::c_char,
                _: *mut *mut libc::c_char,
            ) -> libc::c_int,
        >,
        _: *mut libc::c_void,
        errmsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_initialize() -> libc::c_int;
    fn sqlite3_config(_: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_db_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_total_changes64(_: *mut sqlite3) -> sqlite3_int64;
    fn sqlite3_interrupt(_: *mut sqlite3);
    fn sqlite3_complete(sql: *const libc::c_char) -> libc::c_int;
    fn sqlite3_busy_timeout(_: *mut sqlite3, ms: libc::c_int) -> libc::c_int;
    fn sqlite3_mprintf(_: *const libc::c_char, _: ...) -> *mut libc::c_char;
    fn sqlite3_vmprintf(_: *const libc::c_char, _: ::std::ffi::VaList) -> *mut libc::c_char;
    fn sqlite3_snprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ...
    ) -> *mut libc::c_char;
    fn sqlite3_vsnprintf(
        _: libc::c_int,
        _: *mut libc::c_char,
        _: *const libc::c_char,
        _: ::std::ffi::VaList,
    ) -> *mut libc::c_char;
    fn sqlite3_malloc(_: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_malloc64(_: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_realloc(_: *mut libc::c_void, _: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_realloc64(_: *mut libc::c_void, _: sqlite3_uint64) -> *mut libc::c_void;
    fn sqlite3_free(_: *mut libc::c_void);
    fn sqlite3_randomness(N: libc::c_int, P: *mut libc::c_void);
    fn sqlite3_set_authorizer(
        _: *mut sqlite3,
        xAuth: Option<
            unsafe extern "C" fn(
                _: *mut libc::c_void,
                _: libc::c_int,
                _: *const libc::c_char,
                _: *const libc::c_char,
                _: *const libc::c_char,
                _: *const libc::c_char,
            ) -> libc::c_int,
        >,
        pUserData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_trace_v2(
        _: *mut sqlite3,
        uMask: libc::c_uint,
        xCallback: Option<
            unsafe extern "C" fn(
                _: libc::c_uint,
                _: *mut libc::c_void,
                _: *mut libc::c_void,
                _: *mut libc::c_void,
            ) -> libc::c_int,
        >,
        pCtx: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_progress_handler(
        _: *mut sqlite3,
        _: libc::c_int,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int>,
        _: *mut libc::c_void,
    );
    fn sqlite3_open(filename: *const libc::c_char, ppDb: *mut *mut sqlite3) -> libc::c_int;
    fn sqlite3_open_v2(
        filename: *const libc::c_char,
        ppDb: *mut *mut sqlite3,
        flags: libc::c_int,
        zVfs: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_extended_errcode(db: *mut sqlite3) -> libc::c_int;
    fn sqlite3_errmsg(_: *mut sqlite3) -> *const libc::c_char;
    fn sqlite3_limit(_: *mut sqlite3, id: libc::c_int, newVal: libc::c_int) -> libc::c_int;
    fn sqlite3_prepare_v2(
        db: *mut sqlite3,
        zSql: *const libc::c_char,
        nByte: libc::c_int,
        ppStmt: *mut *mut sqlite3_stmt,
        pzTail: *mut *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_sql(pStmt: *mut sqlite3_stmt) -> *const libc::c_char;
    fn sqlite3_expanded_sql(pStmt: *mut sqlite3_stmt) -> *mut libc::c_char;
    fn sqlite3_stmt_readonly(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_stmt_isexplain(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_blob(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_void,
        n: libc::c_int,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_double(_: *mut sqlite3_stmt, _: libc::c_int, _: libc::c_double) -> libc::c_int;
    fn sqlite3_bind_int(_: *mut sqlite3_stmt, _: libc::c_int, _: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_int64(_: *mut sqlite3_stmt, _: libc::c_int, _: sqlite3_int64) -> libc::c_int;
    fn sqlite3_bind_null(_: *mut sqlite3_stmt, _: libc::c_int) -> libc::c_int;
    fn sqlite3_bind_text(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_bind_value(
        _: *mut sqlite3_stmt,
        _: libc::c_int,
        _: *const sqlite3_value,
    ) -> libc::c_int;
    fn sqlite3_bind_parameter_count(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_bind_parameter_name(_: *mut sqlite3_stmt, _: libc::c_int) -> *const libc::c_char;
    fn sqlite3_bind_parameter_index(
        _: *mut sqlite3_stmt,
        zName: *const libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_column_count(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_name(_: *mut sqlite3_stmt, N: libc::c_int) -> *const libc::c_char;
    fn sqlite3_column_decltype(_: *mut sqlite3_stmt, _: libc::c_int) -> *const libc::c_char;
    fn sqlite3_step(_: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_column_blob(_: *mut sqlite3_stmt, iCol: libc::c_int) -> *const libc::c_void;
    fn sqlite3_column_double(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_double;
    fn sqlite3_column_int(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_int64(_: *mut sqlite3_stmt, iCol: libc::c_int) -> sqlite3_int64;
    fn sqlite3_column_text(_: *mut sqlite3_stmt, iCol: libc::c_int) -> *const libc::c_uchar;
    fn sqlite3_column_value(_: *mut sqlite3_stmt, iCol: libc::c_int) -> *mut sqlite3_value;
    fn sqlite3_column_bytes(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_column_type(_: *mut sqlite3_stmt, iCol: libc::c_int) -> libc::c_int;
    fn sqlite3_finalize(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_reset(pStmt: *mut sqlite3_stmt) -> libc::c_int;
    fn sqlite3_create_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xFunc: Option<
            unsafe extern "C" fn(
                _: *mut sqlite3_context,
                _: libc::c_int,
                _: *mut *mut sqlite3_value,
            ) -> (),
        >,
        xStep: Option<
            unsafe extern "C" fn(
                _: *mut sqlite3_context,
                _: libc::c_int,
                _: *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option<unsafe extern "C" fn(_: *mut sqlite3_context) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_create_window_function(
        db: *mut sqlite3,
        zFunctionName: *const libc::c_char,
        nArg: libc::c_int,
        eTextRep: libc::c_int,
        pApp: *mut libc::c_void,
        xStep: Option<
            unsafe extern "C" fn(
                _: *mut sqlite3_context,
                _: libc::c_int,
                _: *mut *mut sqlite3_value,
            ) -> (),
        >,
        xFinal: Option<unsafe extern "C" fn(_: *mut sqlite3_context) -> ()>,
        xValue: Option<unsafe extern "C" fn(_: *mut sqlite3_context) -> ()>,
        xInverse: Option<
            unsafe extern "C" fn(
                _: *mut sqlite3_context,
                _: libc::c_int,
                _: *mut *mut sqlite3_value,
            ) -> (),
        >,
        xDestroy: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    ) -> libc::c_int;
    fn sqlite3_value_blob(_: *mut sqlite3_value) -> *const libc::c_void;
    fn sqlite3_value_double(_: *mut sqlite3_value) -> libc::c_double;
    fn sqlite3_value_int(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_int64(_: *mut sqlite3_value) -> sqlite3_int64;
    fn sqlite3_value_text(_: *mut sqlite3_value) -> *const libc::c_uchar;
    fn sqlite3_value_bytes(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_value_type(_: *mut sqlite3_value) -> libc::c_int;
    fn sqlite3_aggregate_context(_: *mut sqlite3_context, nBytes: libc::c_int)
        -> *mut libc::c_void;
    fn sqlite3_user_data(_: *mut sqlite3_context) -> *mut libc::c_void;
    fn sqlite3_context_db_handle(_: *mut sqlite3_context) -> *mut sqlite3;
    fn sqlite3_get_auxdata(_: *mut sqlite3_context, N: libc::c_int) -> *mut libc::c_void;
    fn sqlite3_set_auxdata(
        _: *mut sqlite3_context,
        N: libc::c_int,
        _: *mut libc::c_void,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: libc::c_int,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_blob64(
        _: *mut sqlite3_context,
        _: *const libc::c_void,
        _: sqlite3_uint64,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_double(_: *mut sqlite3_context, _: libc::c_double);
    fn sqlite3_result_error(_: *mut sqlite3_context, _: *const libc::c_char, _: libc::c_int);
    fn sqlite3_result_error_nomem(_: *mut sqlite3_context);
    fn sqlite3_result_error_code(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int(_: *mut sqlite3_context, _: libc::c_int);
    fn sqlite3_result_int64(_: *mut sqlite3_context, _: sqlite3_int64);
    fn sqlite3_result_null(_: *mut sqlite3_context);
    fn sqlite3_result_text(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: libc::c_int,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    );
    fn sqlite3_result_text64(
        _: *mut sqlite3_context,
        _: *const libc::c_char,
        _: sqlite3_uint64,
        _: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
        encoding: libc::c_uchar,
    );
    fn sqlite3_result_value(_: *mut sqlite3_context, _: *mut sqlite3_value);
    fn sqlite3_create_collation(
        _: *mut sqlite3,
        zName: *const libc::c_char,
        eTextRep: libc::c_int,
        pArg: *mut libc::c_void,
        xCompare: Option<
            unsafe extern "C" fn(
                _: *mut libc::c_void,
                _: libc::c_int,
                _: *const libc::c_void,
                _: libc::c_int,
                _: *const libc::c_void,
            ) -> libc::c_int,
        >,
    ) -> libc::c_int;
    fn sqlite3_sleep(_: libc::c_int) -> libc::c_int;
    fn sqlite3_get_autocommit(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_db_handle(_: *mut sqlite3_stmt) -> *mut sqlite3;
    fn sqlite3_db_readonly(db: *mut sqlite3, zDbName: *const libc::c_char) -> libc::c_int;
    fn sqlite3_txn_state(_: *mut sqlite3, zSchema: *const libc::c_char) -> libc::c_int;
    fn sqlite3_table_column_metadata(
        db: *mut sqlite3,
        zDbName: *const libc::c_char,
        zTableName: *const libc::c_char,
        zColumnName: *const libc::c_char,
        pzDataType: *mut *const libc::c_char,
        pzCollSeq: *mut *const libc::c_char,
        pNotNull: *mut libc::c_int,
        pPrimaryKey: *mut libc::c_int,
        pAutoinc: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_load_extension(
        db: *mut sqlite3,
        zFile: *const libc::c_char,
        zProc: *const libc::c_char,
        pzErrMsg: *mut *mut libc::c_char,
    ) -> libc::c_int;
    fn sqlite3_enable_load_extension(db: *mut sqlite3, onoff: libc::c_int) -> libc::c_int;
    fn sqlite3_create_module(
        db: *mut sqlite3,
        zName: *const libc::c_char,
        p: *const sqlite3_module,
        pClientData: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_declare_vtab(_: *mut sqlite3, zSQL: *const libc::c_char) -> libc::c_int;
    fn sqlite3_overload_function(
        _: *mut sqlite3,
        zFuncName: *const libc::c_char,
        nArg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_vfs_find(zVfsName: *const libc::c_char) -> *mut sqlite3_vfs;
    fn sqlite3_vfs_register(_: *mut sqlite3_vfs, makeDflt: libc::c_int) -> libc::c_int;
    fn sqlite3_file_control(
        _: *mut sqlite3,
        zDbName: *const libc::c_char,
        op: libc::c_int,
        _: *mut libc::c_void,
    ) -> libc::c_int;
    fn sqlite3_test_control(op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_keyword_count() -> libc::c_int;
    fn sqlite3_keyword_name(
        _: libc::c_int,
        _: *mut *const libc::c_char,
        _: *mut libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_keyword_check(_: *const libc::c_char, _: libc::c_int) -> libc::c_int;
    fn sqlite3_status64(
        op: libc::c_int,
        pCurrent: *mut sqlite3_int64,
        pHighwater: *mut sqlite3_int64,
        resetFlag: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_db_status(
        _: *mut sqlite3,
        op: libc::c_int,
        pCur: *mut libc::c_int,
        pHiwtr: *mut libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_stmt_status(
        _: *mut sqlite3_stmt,
        op: libc::c_int,
        resetFlg: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_backup_init(
        pDest: *mut sqlite3,
        zDestName: *const libc::c_char,
        pSource: *mut sqlite3,
        zSourceName: *const libc::c_char,
    ) -> *mut sqlite3_backup;
    fn sqlite3_backup_step(p: *mut sqlite3_backup, nPage: libc::c_int) -> libc::c_int;
    fn sqlite3_backup_finish(p: *mut sqlite3_backup) -> libc::c_int;
    fn sqlite3_stricmp(_: *const libc::c_char, _: *const libc::c_char) -> libc::c_int;
    fn sqlite3_strnicmp(
        _: *const libc::c_char,
        _: *const libc::c_char,
        _: libc::c_int,
    ) -> libc::c_int;
    fn sqlite3_strglob(zGlob: *const libc::c_char, zStr: *const libc::c_char) -> libc::c_int;
    fn sqlite3_strlike(
        zGlob: *const libc::c_char,
        zStr: *const libc::c_char,
        cEsc: libc::c_uint,
    ) -> libc::c_int;
    fn sqlite3_vtab_config(_: *mut sqlite3, op: libc::c_int, _: ...) -> libc::c_int;
    fn sqlite3_vtab_on_conflict(_: *mut sqlite3) -> libc::c_int;
    fn sqlite3_vtab_nochange(_: *mut sqlite3_context) -> libc::c_int;
    fn sqlite3_vtab_collation(_: *mut sqlite3_index_info, _: libc::c_int) -> *const libc::c_char;
    fn sqlite3_deserialize(
        db: *mut sqlite3,
        zSchema: *const libc::c_char,
        pData: *mut libc::c_uchar,
        szDb: sqlite3_int64,
        szBuf: sqlite3_int64,
        mFlags: libc::c_uint,
    ) -> libc::c_int;
    fn __ctype_b_loc() -> *mut *const libc::c_ushort;
    fn __ctype_tolower_loc() -> *mut *const libc::c_int;
    fn signal(__sig: libc::c_int, __handler: __sighandler_t) -> __sighandler_t;
    fn raise(__sig: libc::c_int) -> libc::c_int;
    fn getpwuid(__uid: __uid_t) -> *mut passwd;
    fn access(__name: *const libc::c_char, __type: libc::c_int) -> libc::c_int;
    fn chdir(__path: *const libc::c_char) -> libc::c_int;
    fn getpid() -> __pid_t;
    fn getuid() -> __uid_t;
    /* Make sure isatty() has a prototype. */
    fn isatty(__fd: libc::c_int) -> libc::c_int;
    fn symlink(__from: *const libc::c_char, __to: *const libc::c_char) -> libc::c_int;
    fn readlink(__path: *const libc::c_char, __buf: *mut libc::c_char, __len: size_t) -> ssize_t;
    fn unlink(__name: *const libc::c_char) -> libc::c_int;
    fn opendir(__name: *const libc::c_char) -> *mut DIR;
    fn closedir(__dirp: *mut DIR) -> libc::c_int;
    fn readdir(__dirp: *mut DIR) -> *mut dirent;
    fn chmod(__file: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn mkdir(__path: *const libc::c_char, __mode: __mode_t) -> libc::c_int;
    fn __lxstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn __xstat(
        __ver: libc::c_int,
        __filename: *const libc::c_char,
        __stat_buf: *mut stat,
    ) -> libc::c_int;
    fn readline(_: *const libc::c_char) -> *mut libc::c_char;
    static mut rl_attempted_completion_function: Option<rl_completion_func_t>;
    static mut rl_attempted_completion_over: libc::c_int;
    fn rl_completion_matches(
        _: *const libc::c_char,
        _: Option<rl_compentry_func_t>,
    ) -> *mut *mut libc::c_char;
    fn time(__timer: *mut time_t) -> time_t;
    fn add_history(_: *const libc::c_char);
    fn stifle_history(_: libc::c_int);
    fn write_history(_: *const libc::c_char) -> libc::c_int;
    fn read_history(_: *const libc::c_char) -> libc::c_int;
    fn utimes(__file: *const libc::c_char, __tvp: *const timeval) -> libc::c_int;
    fn getrusage(__who: __rusage_who_t, __usage: *mut rusage) -> libc::c_int;
    fn __errno_location() -> *mut libc::c_int;
    fn zlibVersion() -> *const libc::c_char;
    fn deflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn deflateEnd(strm: z_streamp) -> libc::c_int;
    fn inflate(strm: z_streamp, flush: libc::c_int) -> libc::c_int;
    fn inflateEnd(strm: z_streamp) -> libc::c_int;
    fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
    fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn compressBound(sourceLen: uLong) -> uLong;
    fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> libc::c_int;
    fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
    fn deflateInit2_(
        strm: z_streamp,
        level: libc::c_int,
        method: libc::c_int,
        windowBits: libc::c_int,
        memLevel: libc::c_int,
        strategy: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
    fn inflateInit2_(
        strm: z_streamp,
        windowBits: libc::c_int,
        version: *const libc::c_char,
        stream_size: libc::c_int,
    ) -> libc::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1];
#[derive(Copy, Clone)]
#[repr(C)]
pub struct __va_list_tag {
    pub gp_offset: libc::c_uint,
    pub fp_offset: libc::c_uint,
    pub overflow_arg_area: *mut libc::c_void,
    pub reg_save_area: *mut libc::c_void,
}
pub type size_t = libc::c_ulong;
pub type __int32_t = libc::c_int;
pub type __dev_t = libc::c_ulong;
pub type __uid_t = libc::c_uint;
pub type __gid_t = libc::c_uint;
pub type __ino_t = libc::c_ulong;
pub type __ino64_t = libc::c_ulong;
pub type __mode_t = libc::c_uint;
pub type __nlink_t = libc::c_ulong;
pub type __off_t = libc::c_long;
pub type __off64_t = libc::c_long;
pub type __pid_t = libc::c_int;
pub type __time_t = libc::c_long;
pub type __suseconds_t = libc::c_long;
pub type __blksize_t = libc::c_long;
pub type __blkcnt_t = libc::c_long;
pub type __ssize_t = libc::c_long;
pub type __syscall_slong_t = libc::c_long;
pub type mode_t = __mode_t;
pub type uid_t = __uid_t;
pub type ssize_t = __ssize_t;
pub type time_t = __time_t;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
pub type va_list = __builtin_va_list;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct _IO_FILE {
    pub _flags: libc::c_int,
    pub _IO_read_ptr: *mut libc::c_char,
    pub _IO_read_end: *mut libc::c_char,
    pub _IO_read_base: *mut libc::c_char,
    pub _IO_write_base: *mut libc::c_char,
    pub _IO_write_ptr: *mut libc::c_char,
    pub _IO_write_end: *mut libc::c_char,
    pub _IO_buf_base: *mut libc::c_char,
    pub _IO_buf_end: *mut libc::c_char,
    pub _IO_save_base: *mut libc::c_char,
    pub _IO_backup_base: *mut libc::c_char,
    pub _IO_save_end: *mut libc::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: libc::c_int,
    pub _flags2: libc::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: libc::c_ushort,
    pub _vtable_offset: libc::c_schar,
    pub _shortbuf: [libc::c_char; 1],
    pub _lock: *mut libc::c_void,
    pub _offset: libc::c_long,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut libc::c_void,
    pub __pad5: size_t,
    pub _mode: libc::c_int,
    pub _unused2: [libc::c_char; 20],
}
pub type _IO_lock_t = ();
pub type FILE = _IO_FILE;
pub type sqlite_int64 = libc::c_longlong;
pub type sqlite_uint64 = libc::c_ulonglong;
pub type sqlite3_int64 = sqlite_int64;
pub type sqlite3_uint64 = sqlite_uint64;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_file {
    pub pMethods: *const sqlite3_io_methods,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_io_methods {
    pub iVersion: libc::c_int,
    pub xClose: Option<unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int>,
    pub xRead: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: *mut libc::c_void,
            _: libc::c_int,
            _: sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xWrite: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: *const libc::c_void,
            _: libc::c_int,
            _: sqlite3_int64,
        ) -> libc::c_int,
    >,
    pub xTruncate:
        Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: sqlite3_int64) -> libc::c_int>,
    pub xSync: Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int>,
    pub xFileSize:
        Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: *mut sqlite3_int64) -> libc::c_int>,
    pub xLock: Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int>,
    pub xUnlock: Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int>,
    pub xCheckReservedLock:
        Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: *mut libc::c_int) -> libc::c_int>,
    pub xFileControl: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: libc::c_int,
            _: *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xSectorSize: Option<unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int>,
    pub xDeviceCharacteristics: Option<unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int>,
    pub xShmMap: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: libc::c_int,
            _: libc::c_int,
            _: libc::c_int,
            _: *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xShmLock: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: libc::c_int,
            _: libc::c_int,
            _: libc::c_int,
        ) -> libc::c_int,
    >,
    pub xShmBarrier: Option<unsafe extern "C" fn(_: *mut sqlite3_file) -> ()>,
    pub xShmUnmap:
        Option<unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int>,
    pub xFetch: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: sqlite3_int64,
            _: libc::c_int,
            _: *mut *mut libc::c_void,
        ) -> libc::c_int,
    >,
    pub xUnfetch: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_file,
            _: sqlite3_int64,
            _: *mut libc::c_void,
        ) -> libc::c_int,
    >,
}
pub type sqlite3_syscall_ptr = Option<unsafe extern "C" fn() -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_mem_methods {
    pub xMalloc: Option<unsafe extern "C" fn(_: libc::c_int) -> *mut libc::c_void>,
    pub xFree: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub xRealloc:
        Option<unsafe extern "C" fn(_: *mut libc::c_void, _: libc::c_int) -> *mut libc::c_void>,
    pub xSize: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int>,
    pub xRoundup: Option<unsafe extern "C" fn(_: libc::c_int) -> libc::c_int>,
    pub xInit: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int>,
    pub xShutdown: Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
    pub pAppData: *mut libc::c_void,
}
pub type sqlite3_destructor_type = Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab {
    pub pModule: *const sqlite3_module,
    pub nRef: libc::c_int,
    pub zErrMsg: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_vtab_cursor {
    pub pVtab: *mut sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_info {
    pub nConstraint: libc::c_int,
    pub aConstraint: *mut sqlite3_index_constraint,
    pub nOrderBy: libc::c_int,
    pub aOrderBy: *mut sqlite3_index_orderby,
    pub aConstraintUsage: *mut sqlite3_index_constraint_usage,
    pub idxNum: libc::c_int,
    pub idxStr: *mut libc::c_char,
    pub needToFreeIdxStr: libc::c_int,
    pub orderByConsumed: libc::c_int,
    pub estimatedCost: libc::c_double,
    pub estimatedRows: sqlite3_int64,
    pub idxFlags: libc::c_int,
    pub colUsed: sqlite3_uint64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint_usage {
    pub argvIndex: libc::c_int,
    pub omit: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_orderby {
    pub iColumn: libc::c_int,
    pub desc: libc::c_uchar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3_index_constraint {
    pub iColumn: libc::c_int,
    pub op: libc::c_uchar,
    pub usable: libc::c_uchar,
    pub iTermOffset: libc::c_int,
}
*/
/* DO NOT EDIT!
** This file is automatically generated by the script in the canonical
** SQLite source tree at tool/mkshellc.tcl.  That script combines source
** code from various constituent source files of SQLite into this single
** "shell.c" file used to implement the SQLite command-line shell.
**
** Most of the code found below comes from the "src/shell.c.in" file in
** the canonical SQLite source tree.  That main file contains "INCLUDE"
** lines that specify other files in the canonical source tree that are
** inserted to getnerate this complete program source file.
**
** The code from multiple files is combined into this single "shell.c"
** source file to help make the command-line program easier to compile.
**
** To modify this program, get a copy of the canonical SQLite source tree,
** edit the src/shell.c.in" and/or some of the other files that are included
** by "src/shell.c.in", then rerun the tool/mkshellc.tcl script.
*/
/*
** 2001 September 15
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
** This file contains code to implement the "sqlite" command line
** utility for accessing SQLite databases.
*/
/*
** Optionally #include a user-defined header, whereby compilation options
** may be set prior to where they take effect, but after platform setup.
** If SQLITE_CUSTOM_INCLUDE=? is defined, its value names the #include
** file. Note that this macro has a like effect on sqlite3.c compilation.
*/
/*
** Determine if we are dealing with WinRT, which provides only a subset of
** the full Win32 API.
*/
/*
** Warning pragmas copied from msvc.h in the core.
*/
/* defined(_MSC_VER) */
/*
** No support for loadable extensions in VxWorks.
*/
/*
** Enable large-file support for fopen() and friends on unix.
*/
pub type i64_0 = sqlite3_int64;
pub type u64_0 = sqlite3_uint64;
pub type u8_0 = libc::c_uchar;
pub type C2RustUnnamed = libc::c_uint;
pub const _ISalnum: C2RustUnnamed = 8;
pub const _ISpunct: C2RustUnnamed = 4;
pub const _IScntrl: C2RustUnnamed = 2;
pub const _ISblank: C2RustUnnamed = 1;
pub const _ISgraph: C2RustUnnamed = 32768;
pub const _ISprint: C2RustUnnamed = 16384;
pub const _ISspace: C2RustUnnamed = 8192;
pub const _ISxdigit: C2RustUnnamed = 4096;
pub const _ISdigit: C2RustUnnamed = 2048;
pub const _ISalpha: C2RustUnnamed = 1024;
pub const _ISlower: C2RustUnnamed = 512;
pub const _ISupper: C2RustUnnamed = 256;
pub type __sighandler_t = Option<unsafe extern "C" fn(_: libc::c_int) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct passwd {
    pub pw_name: *mut libc::c_char,
    pub pw_passwd: *mut libc::c_char,
    pub pw_uid: __uid_t,
    pub pw_gid: __gid_t,
    pub pw_gecos: *mut libc::c_char,
    pub pw_dir: *mut libc::c_char,
    pub pw_shell: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct dirent {
    pub d_ino: libc::c_ulong,
    pub d_off: libc::c_long,
    pub d_reclen: libc::c_ushort,
    pub d_type: libc::c_uchar,
    pub d_name: [libc::c_char; 256],
}
pub type DIR = __dirstream;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct stat {
    pub st_dev: __dev_t,
    pub st_ino: __ino_t,
    pub st_nlink: __nlink_t,
    pub st_mode: __mode_t,
    pub st_uid: __uid_t,
    pub st_gid: __gid_t,
    pub __pad0: libc::c_int,
    pub st_rdev: __dev_t,
    pub st_size: __off_t,
    pub st_blksize: __blksize_t,
    pub st_blocks: __blkcnt_t,
    pub st_atim: timespec,
    pub st_mtim: timespec,
    pub st_ctim: timespec,
    pub __glibc_reserved: [__syscall_slong_t; 3],
}
pub type rl_compentry_func_t =
    unsafe extern "C" fn(_: *const libc::c_char, _: libc::c_int) -> *mut libc::c_char;
pub type rl_completion_func_t = unsafe extern "C" fn(
    _: *const libc::c_char,
    _: libc::c_int,
    _: libc::c_int,
) -> *mut *mut libc::c_char;
pub type __rusage_who = libc::c_int;
pub const RUSAGE_CHILDREN: __rusage_who = -1;
pub const RUSAGE_SELF: __rusage_who = 0;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub c2rust_unnamed: C2RustUnnamed_13,
    pub c2rust_unnamed_0: C2RustUnnamed_12,
    pub c2rust_unnamed_1: C2RustUnnamed_11,
    pub c2rust_unnamed_2: C2RustUnnamed_10,
    pub c2rust_unnamed_3: C2RustUnnamed_9,
    pub c2rust_unnamed_4: C2RustUnnamed_8,
    pub c2rust_unnamed_5: C2RustUnnamed_7,
    pub c2rust_unnamed_6: C2RustUnnamed_6,
    pub c2rust_unnamed_7: C2RustUnnamed_5,
    pub c2rust_unnamed_8: C2RustUnnamed_4,
    pub c2rust_unnamed_9: C2RustUnnamed_3,
    pub c2rust_unnamed_10: C2RustUnnamed_2,
    pub c2rust_unnamed_11: C2RustUnnamed_1,
    pub c2rust_unnamed_12: C2RustUnnamed_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_0 {
    pub ru_nivcsw: ManuallyDrop<libc::c_long>,
    pub __ru_nivcsw_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_1 {
    pub ru_nvcsw: ManuallyDrop<libc::c_long>,
    pub __ru_nvcsw_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_2 {
    pub ru_nsignals: ManuallyDrop<libc::c_long>,
    pub __ru_nsignals_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_3 {
    pub ru_msgrcv: ManuallyDrop<libc::c_long>,
    pub __ru_msgrcv_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_4 {
    pub ru_msgsnd: ManuallyDrop<libc::c_long>,
    pub __ru_msgsnd_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_5 {
    pub ru_oublock: ManuallyDrop<libc::c_long>,
    pub __ru_oublock_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_6 {
    pub ru_inblock: ManuallyDrop<libc::c_long>,
    pub __ru_inblock_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_7 {
    pub ru_nswap: ManuallyDrop<libc::c_long>,
    pub __ru_nswap_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_8 {
    pub ru_majflt: ManuallyDrop<libc::c_long>,
    pub __ru_majflt_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_9 {
    pub ru_minflt: ManuallyDrop<libc::c_long>,
    pub __ru_minflt_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_10 {
    pub ru_isrss: ManuallyDrop<libc::c_long>,
    pub __ru_isrss_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_11 {
    pub ru_idrss: ManuallyDrop<libc::c_long>,
    pub __ru_idrss_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_12 {
    pub ru_ixrss: ManuallyDrop<libc::c_long>,
    pub __ru_ixrss_word: ManuallyDrop<__syscall_slong_t>,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_13 {
    pub ru_maxrss: ManuallyDrop<libc::c_long>,
    pub __ru_maxrss_word: ManuallyDrop<__syscall_slong_t>,
}
pub type __rusage_who_t = libc::c_int;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_14 {
    pub zSuffix: *mut libc::c_char,
    pub iMult: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellText {
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct SHA3Context {
    pub u: C2RustUnnamed_15,
    pub nRate: libc::c_uint,
    pub nLoaded: libc::c_uint,
    pub ixMask: libc::c_uint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub union C2RustUnnamed_15 {
    pub s: ManuallyDrop<[u64_0; 25]>,
    pub x: ManuallyDrop<[libc::c_uchar; 1600]>,
}
/* Name of directory (nul-terminated) */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_cursor {
    pub base: sqlite3_vtab_cursor,
    pub nLvl: libc::c_int,
    pub iLvl: libc::c_int,
    pub aLvl: *mut FsdirLevel,
    pub zBase: *const libc::c_char,
    pub nBase: libc::c_int,
    pub sStat: stat,
    pub zPath: *mut libc::c_char,
    pub iRowid: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct FsdirLevel {
    pub pDir: *mut DIR,
    pub zDir: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct fsdir_tab {
    pub base: sqlite3_vtab,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_vtab {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct completion_cursor {
    pub base: sqlite3_vtab_cursor,
    pub db: *mut sqlite3,
    pub nPrefix: libc::c_int,
    pub nLine: libc::c_int,
    pub zPrefix: *mut libc::c_char,
    pub zLine: *mut libc::c_char,
    pub zCurrentRow: *const libc::c_char,
    pub szRow: libc::c_int,
    pub pStmt: *mut sqlite3_stmt,
    pub iRowid: sqlite3_int64,
    pub ePhase: libc::c_int,
    pub j: libc::c_int,
}
/* An open appendvfs file
**
** An instance of this structure describes the appended database file.
** A separate sqlite3_file object is always appended. The appended
** sqlite3_file object (which can be accessed using ORIGFILE()) describes
** the entire file, including the prefix, the database, and the
** append-mark.
**
** The structure of an AppendVFS database is like this:
**
**   +-------------+---------+----------+-------------+
**   | prefix-file | padding | database | append-mark |
**   +-------------+---------+----------+-------------+
**                           ^          ^
**                           |          |
**                         iPgOne      iMark
**
**
** "prefix file" -  file onto which the database has been appended.
** "padding"     -  zero or more bytes inserted so that "database"
**                  starts on an APND_ROUNDUP boundary
** "database"    -  The SQLite database file
** "append-mark" -  The 25-byte "Start-Of-SQLite3-NNNNNNNN" that indicates
**                  the offset from the start of prefix-file to the start
**                  of "database".
**
** The size of the database is iMark - iPgOne.
**
** The NNNNNNNN in the "Start-Of-SQLite3-NNNNNNNN" suffix is the value
** of iPgOne stored as a big-ending 64-bit integer.
**
** iMark will be the size of the underlying file minus 25 (APND_MARKSIZE).
** Or, iMark is -1 to indicate that it has not yet been written.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ApndFile {
    pub base: sqlite3_file,
    pub iPgOne: sqlite3_int64,
    pub iMark: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct Decimal {
    pub sign: libc::c_char,
    pub oom: libc::c_char,
    pub isNull: libc::c_char,
    pub isInit: libc::c_char,
    pub nDigit: libc::c_int,
    pub nFrac: libc::c_int,
    pub a: *mut libc::c_schar,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_16 {
    pub zFuncName: *const libc::c_char,
    pub nArg: libc::c_int,
    pub xFunc: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_context,
            _: libc::c_int,
            _: *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_17 {
    pub zFName: *mut libc::c_char,
    pub nArg: libc::c_int,
    pub iAux: libc::c_int,
    pub xFunc: Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_context,
            _: libc::c_int,
            _: *mut *mut sqlite3_value,
        ) -> (),
    >,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct series_cursor {
    pub base: sqlite3_vtab_cursor,
    pub isDesc: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub iValue: sqlite3_int64,
    pub mnValue: sqlite3_int64,
    pub mxValue: sqlite3_int64,
    pub iStep: sqlite3_int64,
}
/* Boundary between word and non-word */
/* Each opcode is a "state" in the NFA */
pub type ReStateNumber = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReStateSet {
    pub nState: libc::c_uint,
    pub aState: *mut ReStateNumber,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReInput {
    pub z: *const libc::c_uchar,
    pub i: libc::c_int,
    pub mx: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ReCompiled {
    pub sIn: ReInput,
    pub zErr: *const libc::c_char,
    pub aOp: *mut libc::c_char,
    pub aArg: *mut libc::c_int,
    pub xNextChar: Option<unsafe extern "C" fn(_: *mut ReInput) -> libc::c_uint>,
    pub zInit: [libc::c_uchar; 12],
    pub nInit: libc::c_int,
    pub nState: libc::c_uint,
    pub nAlloc: libc::c_uint,
}
pub type Byte = libc::c_uchar;
pub type uInt = libc::c_uint;
pub type uLong = libc::c_ulong;
pub type Bytef = Byte;
pub type uLongf = uLong;
pub type voidpf = *mut libc::c_void;
pub type alloc_func = Option<unsafe extern "C" fn(_: voidpf, _: uInt, _: uInt) -> voidpf>;
pub type free_func = Option<unsafe extern "C" fn(_: voidpf, _: voidpf) -> ()>;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut libc::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: libc::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
/* ************************ End ../ext/misc/regexp.c ********************/
/* ************************ Begin ../ext/misc/zipfile.c ******************/
/*
** 2017-12-26
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This file implements a virtual table for reading and writing ZIP archive
** files.
**
** Usage example:
**
**     SELECT name, sz, datetime(mtime,'unixepoch') FROM zipfile($filename);
**
** Current limitations:
**
**    *  No support for encryption
**    *  No support for ZIP archives spanning multiple files
**    *  No support for zip64 extensions
**    *  Only the "inflate/deflate" (zlib) compression method is supported
*/
/* #include "sqlite3ext.h" */
/* typedef sqlite3_int64 i64; */
/* typedef unsigned char u8; */
pub type u32_0 = libc::c_uint;
/* 4-byte unsigned integer */
pub type u16_0 = libc::c_ushort;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEOCD {
    pub iDisk: u16_0,
    pub iFirstDisk: u16_0,
    pub nEntry: u16_0,
    pub nEntryTotal: u16_0,
    pub nSize: u32_0,
    pub iOffset: u32_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCDS {
    pub iVersionMadeBy: u16_0,
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
    pub nComment: u16_0,
    pub iDiskStart: u16_0,
    pub iInternalAttr: u16_0,
    pub iExternalAttr: u32_0,
    pub iOffset: u32_0,
    pub zFile: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileLFH {
    pub iVersionExtract: u16_0,
    pub flags: u16_0,
    pub iCompression: u16_0,
    pub mTime: u16_0,
    pub mDate: u16_0,
    pub crc32: u32_0,
    pub szCompressed: u32_0,
    pub szUncompressed: u32_0,
    pub nFile: u16_0,
    pub nExtra: u16_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileEntry {
    pub cds: ZipfileCDS,
    pub mUnixTime: u32_0,
    pub aExtra: *mut u8_0,
    pub iDataOff: i64_0,
    pub aData: *mut u8_0,
    pub pNext: *mut ZipfileEntry,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCsr {
    pub base: sqlite3_vtab_cursor,
    pub iId: i64_0,
    pub bEof: u8_0,
    pub bNoop: u8_0,
    pub pFile: *mut FILE,
    pub iNextOff: i64_0,
    pub eocd: ZipfileEOCD,
    pub pFreeEntry: *mut ZipfileEntry,
    pub pCurrent: *mut ZipfileEntry,
    pub pCsrNext: *mut ZipfileCsr,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileTab {
    pub base: sqlite3_vtab,
    pub zFile: *mut libc::c_char,
    pub db: *mut sqlite3,
    pub aBuffer: *mut u8_0,
    pub pCsrList: *mut ZipfileCsr,
    pub iNextCsrid: i64_0,
    pub pFirstEntry: *mut ZipfileEntry,
    pub pLastEntry: *mut ZipfileEntry,
    pub pWriteFd: *mut FILE,
    pub szCurrent: i64_0,
    pub szOrig: i64_0,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileBuffer {
    pub a: *mut u8_0,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ZipfileCtx {
    pub nEntry: libc::c_int,
    pub body: ZipfileBuffer,
    pub cds: ZipfileBuffer,
}
/*
** sqlite3expert object.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct sqlite3expert {
    pub iSample: libc::c_int,
    pub db: *mut sqlite3,
    pub dbm: *mut sqlite3,
    pub dbv: *mut sqlite3,
    pub pTable: *mut IdxTable,
    pub pScan: *mut IdxScan,
    pub pWrite: *mut IdxWrite,
    pub pStatement: *mut IdxStatement,
    pub bRun: libc::c_int,
    pub pzErrmsg: *mut *mut libc::c_char,
    pub rc: libc::c_int,
    pub hIdx: IdxHash,
    pub zCandidates: *mut libc::c_char,
}
/* Next entry in hash */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHash {
    pub pFirst: *mut IdxHashEntry,
    pub aHash: [*mut IdxHashEntry; 1023],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxHashEntry {
    pub zKey: *mut libc::c_char,
    pub zVal: *mut libc::c_char,
    pub zVal2: *mut libc::c_char,
    pub pHashNext: *mut IdxHashEntry,
    pub pNext: *mut IdxHashEntry,
}
/*
** Each statement being analyzed is represented by an instance of this
** structure.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxStatement {
    pub iId: libc::c_int,
    pub zSql: *mut libc::c_char,
    pub zIdx: *mut libc::c_char,
    pub zEQP: *mut libc::c_char,
    pub pNext: *mut IdxStatement,
}
/* Next table in linked list of all tables */
/*
** An object of the following type is created for each unique table/write-op
** seen. The objects are stored in a singly-linked list beginning at
** sqlite3expert.pWrite.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxWrite {
    pub pTab: *mut IdxTable,
    pub eOp: libc::c_int,
    pub pNext: *mut IdxWrite,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxTable {
    pub nCol: libc::c_int,
    pub zName: *mut libc::c_char,
    pub aCol: *mut IdxColumn,
    pub pNext: *mut IdxTable,
}
/* Next IdxScan object for same analysis */
/*
** Information regarding a single database table. Extracted from
** "PRAGMA table_info" by function idxGetTableInfo().
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxColumn {
    pub zName: *mut libc::c_char,
    pub zColl: *mut libc::c_char,
    pub iPk: libc::c_int,
}
/* See above */
/*
** A single scan of a single table.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxScan {
    pub pTab: *mut IdxTable,
    pub iDb: libc::c_int,
    pub covering: i64_0,
    pub pOrder: *mut IdxConstraint,
    pub pEq: *mut IdxConstraint,
    pub pRange: *mut IdxConstraint,
    pub pNextScan: *mut IdxScan,
}
/*
** A single constraint. Equivalent to either "col = ?" or "col < ?" (or
** any other type of single-ended range constraint on a column).
**
** pLink:
**   Used to temporarily link IdxConstraint objects into lists while
**   creating candidate indexes.
*/
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxConstraint {
    pub zColl: *mut libc::c_char,
    pub bRange: libc::c_int,
    pub iCol: libc::c_int,
    pub bFlag: libc::c_int,
    pub bDesc: libc::c_int,
    pub pNext: *mut IdxConstraint,
    pub pLink: *mut IdxConstraint,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertCsr {
    pub base: sqlite3_vtab_cursor,
    pub pData: *mut sqlite3_stmt,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertVtab {
    pub base: sqlite3_vtab,
    pub pTab: *mut IdxTable,
    pub pExpert: *mut sqlite3expert,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemCtx {
    pub nSlot: libc::c_int,
    pub aSlot: [IdxRemSlot; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxRemSlot {
    pub eType: libc::c_int,
    pub iVal: i64_0,
    pub rVal: libc::c_double,
    pub nByte: libc::c_int,
    pub n: libc::c_int,
    pub z: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct IdxSampleCtx {
    pub iTarget: libc::c_int,
    pub target: libc::c_double,
    pub nRow: libc::c_double,
    pub nRet: libc::c_double,
}
/* Integer key value */
/* Table object */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataTable {
    pub base: sqlite3_vtab,
    pub db: *mut sqlite3,
    pub pStmt: *mut sqlite3_stmt,
    pub bPtr: libc::c_int,
}
/* Cursor object */
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbdataCursor {
    pub base: sqlite3_vtab_cursor,
    pub pStmt: *mut sqlite3_stmt,
    pub iPgno: libc::c_int,
    pub aPage: *mut u8_0,
    pub nPage: libc::c_int,
    pub nCell: libc::c_int,
    pub iCell: libc::c_int,
    pub bOnePage: libc::c_int,
    pub szDb: libc::c_int,
    pub iRowid: sqlite3_int64,
    pub pRec: *mut u8_0,
    pub nRec: libc::c_int,
    pub nHdr: libc::c_int,
    pub iField: libc::c_int,
    pub pHdrPtr: *mut u8_0,
    pub pPtr: *mut u8_0,
    pub iIntkey: sqlite3_int64,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ExpertInfo {
    pub pExpert: *mut sqlite3expert,
    pub bVerbose: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraphRow {
    pub iEqpId: libc::c_int,
    pub iParentId: libc::c_int,
    pub pNext: *mut EQPGraphRow,
    pub zText: [libc::c_char; 1],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct EQPGraph {
    pub pRow: *mut EQPGraphRow,
    pub pLast: *mut EQPGraphRow,
    pub zPrefix: [libc::c_char; 100],
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ShellState {
    pub db: *mut sqlite3,
    pub autoExplain: u8_0,
    pub autoEQP: u8_0,
    pub autoEQPtest: u8_0,
    pub autoEQPtrace: u8_0,
    pub scanstatsOn: u8_0,
    pub openMode: u8_0,
    pub doXdgOpen: u8_0,
    pub nEqpLevel: u8_0,
    pub eTraceType: u8_0,
    pub bSafeMode: u8_0,
    pub bSafeModePersist: u8_0,
    pub statsOn: libc::c_uint,
    pub mEqpLines: libc::c_uint,
    pub outCount: libc::c_int,
    pub cnt: libc::c_int,
    pub lineno: libc::c_int,
    pub openFlags: libc::c_int,
    pub in_0: *mut FILE,
    pub out: *mut FILE,
    pub traceOut: *mut FILE,
    pub nErr: libc::c_int,
    pub mode: libc::c_int,
    pub modePrior: libc::c_int,
    pub cMode: libc::c_int,
    pub normalMode: libc::c_int,
    pub writableSchema: libc::c_int,
    pub showHeader: libc::c_int,
    pub nCheck: libc::c_int,
    pub nProgress: libc::c_uint,
    pub mxProgress: libc::c_uint,
    pub flgProgress: libc::c_uint,
    pub shellFlgs: libc::c_uint,
    pub priorShFlgs: libc::c_uint,
    pub szMax: sqlite3_int64,
    pub zDestTable: *mut libc::c_char,
    pub zTempFile: *mut libc::c_char,
    pub zTestcase: [libc::c_char; 30],
    pub colSeparator: [libc::c_char; 20],
    pub rowSeparator: [libc::c_char; 20],
    pub colSepPrior: [libc::c_char; 20],
    pub rowSepPrior: [libc::c_char; 20],
    pub colWidth: *mut libc::c_int,
    pub actualWidth: *mut libc::c_int,
    pub nWidth: libc::c_int,
    pub nullValue: [libc::c_char; 20],
    pub outfile: [libc::c_char; 4096],
    pub pStmt: *mut sqlite3_stmt,
    pub pLog: *mut FILE,
    pub aAuxDb: [AuxDb; 5],
    pub pAuxDb: *mut AuxDb,
    pub aiIndent: *mut libc::c_int,
    pub nIndent: libc::c_int,
    pub iIndent: libc::c_int,
    pub zNonce: *mut libc::c_char,
    pub sGraph: EQPGraph,
    pub expert: ExpertInfo,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct AuxDb {
    pub db: *mut sqlite3,
    pub zDbFilename: *const libc::c_char,
    pub zFreeOnClose: *mut libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_18 {
    pub zPattern: *const libc::c_char,
    pub zDesc: *const libc::c_char,
}
pub const QSS_HasDark: QuickScanState = 256;
pub const QSS_EndingSemi: QuickScanState = 512;
pub type QuickScanState = libc::c_uint;
pub const QSS_Start: QuickScanState = 0;
pub const QSS_ScanMask: QuickScanState = 768;
pub const QSS_CharMask: QuickScanState = 255;
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_19 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_20 {
    pub zLimitName: *const libc::c_char,
    pub limitCode: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ImportCtx {
    pub zFile: *const libc::c_char,
    pub in_0: *mut FILE,
    pub xCloser: Option<unsafe extern "C" fn(_: *mut FILE) -> libc::c_int>,
    pub z: *mut libc::c_char,
    pub n: libc::c_int,
    pub nAlloc: libc::c_int,
    pub nLine: libc::c_int,
    pub nRow: libc::c_int,
    pub nErr: libc::c_int,
    pub bNotFirst: libc::c_int,
    pub cTerm: libc::c_int,
    pub cColSep: libc::c_int,
    pub cRowSep: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_21 {
    pub zCtrlName: *const libc::c_char,
    pub ctrlCode: libc::c_int,
    pub zUsage: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct RecoverTable {
    pub zQuoted: *mut libc::c_char,
    pub nCol: libc::c_int,
    pub azlCol: *mut *mut libc::c_char,
    pub iPk: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_22 {
    pub zName: *const libc::c_char,
    pub zSql: *const libc::c_char,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct C2RustUnnamed_23 {
    pub zName: *const libc::c_char,
    pub ofst: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct DbConfigChoices {
    pub zName: *const libc::c_char,
    pub op: libc::c_int,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArCommand {
    pub eCmd: u8_0,
    pub bVerbose: u8_0,
    pub bZip: u8_0,
    pub bDryRun: u8_0,
    pub bAppend: u8_0,
    pub fromCmdLine: u8_0,
    pub nArg: libc::c_int,
    pub zSrcTable: *mut libc::c_char,
    pub zFile: *const libc::c_char,
    pub zDir: *const libc::c_char,
    pub azArg: *mut *mut libc::c_char,
    pub p: *mut ShellState,
    pub db: *mut sqlite3,
}
#[derive(Copy, Clone)]
#[repr(C)]
pub struct ArSwitch {
    pub zLong: *const libc::c_char,
    pub cShort: libc::c_char,
    pub eSwitch: u8_0,
    pub bArg: u8_0,
}
#[inline]
unsafe extern "C" fn atoi(mut __nptr: *const libc::c_char) -> libc::c_int {
    return strtol(
        __nptr,
        0 as *mut libc::c_void as *mut *mut libc::c_char,
        10 as libc::c_int,
    ) as libc::c_int;
}
#[inline]
unsafe extern "C" fn tolower(mut __c: libc::c_int) -> libc::c_int {
    return if __c >= -(128 as libc::c_int) && __c < 256 as libc::c_int {
        *(*__ctype_tolower_loc()).offset(__c as isize)
    } else {
        __c
    };
}
#[inline]
unsafe extern "C" fn stat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __xstat(1 as libc::c_int, __path, __statbuf);
}
#[inline]
unsafe extern "C" fn lstat(
    mut __path: *const libc::c_char,
    mut __statbuf: *mut stat,
) -> libc::c_int {
    return __lxstat(1 as libc::c_int, __path, __statbuf);
}
/* On Windows, we normally run with output mode of TEXT so that \n characters
** are automatically translated into \r\n.  However, this behavior needs
** to be disabled in some cases (ex: when generating CSV output and when
** rendering quoted strings that contain \n characters).  The following
** routines take care of that.
*/
/* True if the timer is enabled */
static mut enableTimer: libc::c_int = 0 as libc::c_int;
/* Return the current wall-clock time */
unsafe extern "C" fn timeOfDay() -> sqlite3_int64 {
    static mut clockVfs: *mut sqlite3_vfs = 0 as *const sqlite3_vfs as *mut sqlite3_vfs; /* Never actually happens */
    let mut t: sqlite3_int64 = 0;
    if clockVfs.is_null() {
        clockVfs = sqlite3_vfs_find(0 as *const libc::c_char)
    }
    if clockVfs.is_null() {
        return 0 as libc::c_int as sqlite3_int64;
    } else {
        if (*clockVfs).iVersion >= 2 as libc::c_int && (*clockVfs).xCurrentTimeInt64.is_some() {
            (*clockVfs)
                .xCurrentTimeInt64
                .expect("non-null function pointer")(clockVfs, &mut t);
        } else {
            let mut r: libc::c_double = 0.;
            (*clockVfs).xCurrentTime.expect("non-null function pointer")(clockVfs, &mut r);
            t = (r * 86400000.0f64) as sqlite3_int64
        }
        return t;
    };
}
/* VxWorks does not support getrusage() as far as we can determine */
/* Saved resource information for the beginning of an operation */
static mut sBegin: rusage = rusage {
    ru_utime: timeval {
        tv_sec: 0,
        tv_usec: 0,
    },
    ru_stime: timeval {
        tv_sec: 0,
        tv_usec: 0,
    },
    c2rust_unnamed: C2RustUnnamed_13 {
        ru_maxrss: ManuallyDrop::new(0),
    },
    c2rust_unnamed_0: C2RustUnnamed_12 {
        ru_ixrss: ManuallyDrop::new(0),
    },
    c2rust_unnamed_1: C2RustUnnamed_11 {
        ru_idrss: ManuallyDrop::new(0),
    },
    c2rust_unnamed_2: C2RustUnnamed_10 {
        ru_isrss: ManuallyDrop::new(0),
    },
    c2rust_unnamed_3: C2RustUnnamed_9 {
        ru_minflt: ManuallyDrop::new(0),
    },
    c2rust_unnamed_4: C2RustUnnamed_8 {
        ru_majflt: ManuallyDrop::new(0),
    },
    c2rust_unnamed_5: C2RustUnnamed_7 {
        ru_nswap: ManuallyDrop::new(0),
    },
    c2rust_unnamed_6: C2RustUnnamed_6 {
        ru_inblock: ManuallyDrop::new(0),
    },
    c2rust_unnamed_7: C2RustUnnamed_5 {
        ru_oublock: ManuallyDrop::new(0),
    },
    c2rust_unnamed_8: C2RustUnnamed_4 {
        ru_msgsnd: ManuallyDrop::new(0),
    },
    c2rust_unnamed_9: C2RustUnnamed_3 {
        ru_msgrcv: ManuallyDrop::new(0),
    },
    c2rust_unnamed_10: C2RustUnnamed_2 {
        ru_nsignals: ManuallyDrop::new(0),
    },
    c2rust_unnamed_11: C2RustUnnamed_1 {
        ru_nvcsw: ManuallyDrop::new(0),
    },
    c2rust_unnamed_12: C2RustUnnamed_0 {
        ru_nivcsw: ManuallyDrop::new(0),
    },
};
/* CPU time at start */
static mut iBegin: sqlite3_int64 = 0;
/* Wall-clock time at start */
/*
** Begin timing an operation
*/
unsafe extern "C" fn beginTimer() {
    if enableTimer != 0 {
        getrusage(RUSAGE_SELF as libc::c_int, &mut sBegin);
        iBegin = timeOfDay()
    };
}
/* Return the difference of two time_structs in seconds */
unsafe extern "C" fn timeDiff(mut pStart: *mut timeval, mut pEnd: *mut timeval) -> libc::c_double {
    return ((*pEnd).tv_usec - (*pStart).tv_usec) as libc::c_double * 0.000001f64
        + ((*pEnd).tv_sec - (*pStart).tv_sec) as libc::c_double;
}
/*
** Print the timing results.
*/
unsafe extern "C" fn endTimer() {
    if enableTimer != 0 {
        let mut iEnd: sqlite3_int64 = timeOfDay();
        let mut sEnd: rusage = rusage {
            ru_utime: timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            ru_stime: timeval {
                tv_sec: 0,
                tv_usec: 0,
            },
            c2rust_unnamed: C2RustUnnamed_13 {
                ru_maxrss: ManuallyDrop::new(0),
            },
            c2rust_unnamed_0: C2RustUnnamed_12 {
                ru_ixrss: ManuallyDrop::new(0),
            },
            c2rust_unnamed_1: C2RustUnnamed_11 {
                ru_idrss: ManuallyDrop::new(0),
            },
            c2rust_unnamed_2: C2RustUnnamed_10 {
                ru_isrss: ManuallyDrop::new(0),
            },
            c2rust_unnamed_3: C2RustUnnamed_9 {
                ru_minflt: ManuallyDrop::new(0),
            },
            c2rust_unnamed_4: C2RustUnnamed_8 {
                ru_majflt: ManuallyDrop::new(0),
            },
            c2rust_unnamed_5: C2RustUnnamed_7 {
                ru_nswap: ManuallyDrop::new(0),
            },
            c2rust_unnamed_6: C2RustUnnamed_6 {
                ru_inblock: ManuallyDrop::new(0),
            },
            c2rust_unnamed_7: C2RustUnnamed_5 {
                ru_oublock: ManuallyDrop::new(0),
            },
            c2rust_unnamed_8: C2RustUnnamed_4 {
                ru_msgsnd: ManuallyDrop::new(0),
            },
            c2rust_unnamed_9: C2RustUnnamed_3 {
                ru_msgrcv: ManuallyDrop::new(0),
            },
            c2rust_unnamed_10: C2RustUnnamed_2 {
                ru_nsignals: ManuallyDrop::new(0),
            },
            c2rust_unnamed_11: C2RustUnnamed_1 {
                ru_nvcsw: ManuallyDrop::new(0),
            },
            c2rust_unnamed_12: C2RustUnnamed_0 {
                ru_nivcsw: ManuallyDrop::new(0),
            },
        };
        getrusage(RUSAGE_SELF as libc::c_int, &mut sEnd);
        printf(
            b"Run Time: real %.3f user %f sys %f\n\x00" as *const u8 as *const libc::c_char,
            (iEnd - iBegin) as libc::c_double * 0.001f64,
            timeDiff(&mut sBegin.ru_utime, &mut sEnd.ru_utime),
            timeDiff(&mut sBegin.ru_stime, &mut sEnd.ru_stime),
        );
    };
}
/*
** If the following flag is set, then command execution stops
** at an error if we are not interactive.
*/
static mut bail_on_error: libc::c_int = 0 as libc::c_int;
/*
** Threat stdin as an interactive input if the following variable
** is true.  Otherwise, assume stdin is connected to a file or pipe.
*/
static mut stdin_is_interactive: libc::c_int = 1 as libc::c_int;
/*
** On Windows systems we have to know if standard output is a console
** in order to translate UTF-8 into MBCS.  The following variable is
** true if translation is required.
*/
static mut stdout_is_console: libc::c_int = 1 as libc::c_int;
/*
** The following is the open SQLite database.  We make a pointer
** to this database a static variable so that it can be accessed
** by the SIGINT handler to interrupt database processing.
*/
static mut globalDb: *mut sqlite3 = 0 as *const sqlite3 as *mut sqlite3;
/*
** True if an interrupt (Control-C) has been received.
*/
static mut seenInterrupt: libc::c_int = 0 as libc::c_int;
/* SQLITE_DEBUG */
/*
** This is the name of our program. It is set in main(), used
** in a number of other places, mostly for error messages.
*/
static mut Argv0: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
/*
** Prompt strings. Initialized in main. Settable with
**   .prompt main continue
*/
static mut mainPrompt: [libc::c_char; 20] = [0; 20];
/* First line prompt. default: "sqlite> "*/
static mut continuePrompt: [libc::c_char; 20] = [0; 20];
/* Indicate out-of-memory and exit. */
unsafe extern "C" fn shell_out_of_memory() {
    fprintf(
        stderr,
        b"Error: out of memory\n\x00" as *const u8 as *const libc::c_char,
    );
    exit(1 as libc::c_int);
}
/* SQLITE_DEBUG */
/* SQLITE_DEBUG */
/*
** Write I/O traces to the following stream.
*/
/*
** This routine works like printf in that its first argument is a
** format string and subsequent arguments are values to be substituted
** in place of % fields.  The result of formatting this string
** is written to iotrace.
*/
/*
** Output string zUtf to stream pOut as w characters.  If w is negative,
** then right-justify the text.  W is the width in UTF-8 characters, not
** in bytes.  This is different from the %*.*s specification in printf
** since with %*.*s the width is measured in bytes, not characters.
*/
unsafe extern "C" fn utf8_width_print(
    mut pOut: *mut FILE,
    mut w: libc::c_int,
    mut zUtf: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut aw: libc::c_int = if w < 0 as libc::c_int { -w } else { w };
    n = 0 as libc::c_int;
    i = n;
    's_12: while *zUtf.offset(i as isize) != 0 {
        if *zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int != 0x80 as libc::c_int {
            n += 1;
            if n == aw {
                loop {
                    i += 1;
                    if !(*zUtf.offset(i as isize) as libc::c_int & 0xc0 as libc::c_int
                        == 0x80 as libc::c_int)
                    {
                        break 's_12;
                    }
                }
            }
        }
        i += 1
    }
    if n >= aw {
        fprintf(
            pOut,
            b"%.*s\x00" as *const u8 as *const libc::c_char,
            i,
            zUtf,
        );
    } else if w < 0 as libc::c_int {
        fprintf(
            pOut,
            b"%*s%s\x00" as *const u8 as *const libc::c_char,
            aw - n,
            b"\x00" as *const u8 as *const libc::c_char,
            zUtf,
        );
    } else {
        fprintf(
            pOut,
            b"%s%*s\x00" as *const u8 as *const libc::c_char,
            zUtf,
            aw - n,
            b"\x00" as *const u8 as *const libc::c_char,
        );
    };
}
/*
** Determines if a string is a number of not.
*/
unsafe extern "C" fn isNumber(
    mut z: *const libc::c_char,
    mut realnum: *mut libc::c_int,
) -> libc::c_int {
    if *z as libc::c_int == '-' as i32 || *z as libc::c_int == '+' as i32 {
        z = z.offset(1)
    }
    if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize) as libc::c_int
        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
        == 0
    {
        return 0 as libc::c_int;
    } else {
        z = z.offset(1);
        if !realnum.is_null() {
            *realnum = 0 as libc::c_int
        }
        while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize) as libc::c_int
            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            z = z.offset(1)
        }
        if *z as libc::c_int == '.' as i32 {
            z = z.offset(1);
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            } else {
                while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    z = z.offset(1)
                }
                if !realnum.is_null() {
                    *realnum = 1 as libc::c_int
                }
            }
        }
        if *z as libc::c_int == 'e' as i32 || *z as libc::c_int == 'E' as i32 {
            z = z.offset(1);
            if *z as libc::c_int == '+' as i32 || *z as libc::c_int == '-' as i32 {
                z = z.offset(1)
            }
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            } else {
                while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    z = z.offset(1)
                }
                if !realnum.is_null() {
                    *realnum = 1 as libc::c_int
                }
            }
        }
        return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
    };
}
/*
** Compute a string length that is limited to what can be stored in
** lower 30 bits of a 32-bit signed integer.
*/
unsafe extern "C" fn strlen30(mut z: *const libc::c_char) -> libc::c_int {
    let mut z2: *const libc::c_char = z;
    while *z2 != 0 {
        z2 = z2.offset(1)
    }
    return 0x3fffffff as libc::c_int & z2.offset_from(z) as libc::c_long as libc::c_int;
}
/*
** Return the length of a string in characters.  Multibyte UTF8 characters
** count as a single character.
*/
unsafe extern "C" fn strlenChar(mut z: *const libc::c_char) -> libc::c_int {
    let mut n: libc::c_int = 0 as libc::c_int;
    while *z != 0 {
        let fresh0 = z;
        z = z.offset(1);
        if !(0xc0 as libc::c_int & *fresh0 as libc::c_int != 0x80 as libc::c_int) {
            continue;
        }
        n += 1
    }
    return n;
}
/*
** Return open FILE * if zFile exists, can be opened for read
** and is an ordinary file or a character stream source.
** Otherwise return 0.
*/
unsafe extern "C" fn openChrSource(mut zFile: *const libc::c_char) -> *mut FILE {
    let mut x: stat = {
        let mut init = stat {
            st_dev: 0 as libc::c_int as __dev_t,
            st_ino: 0,
            st_nlink: 0,
            st_mode: 0,
            st_uid: 0,
            st_gid: 0,
            __pad0: 0,
            st_rdev: 0,
            st_size: 0,
            st_blksize: 0,
            st_blocks: 0,
            st_atim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_mtim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            st_ctim: timespec {
                tv_sec: 0,
                tv_nsec: 0,
            },
            __glibc_reserved: [0; 3],
        };
        init
    };
    let mut rc: libc::c_int = stat(zFile, &mut x);
    if rc != 0 as libc::c_int {
        return 0 as *mut FILE;
    } else if x.st_mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o100000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o10000 as libc::c_int as libc::c_uint
        || x.st_mode & 0o170000 as libc::c_int as libc::c_uint
            == 0o20000 as libc::c_int as libc::c_uint
    {
        return fopen(zFile, b"rb\x00" as *const u8 as *const libc::c_char);
    } else {
        return 0 as *mut FILE;
    };
}
/*
** This routine reads a line of text from FILE in, stores
** the text in memory obtained from malloc() and returns a pointer
** to the text.  NULL is returned at end of file, or if malloc()
** fails.
**
** If zLine is not NULL then it is a malloced buffer returned from
** a previous call to this routine that may be reused.
*/
unsafe extern "C" fn local_getline(
    mut zLine: *mut libc::c_char,
    mut in_0: *mut FILE,
) -> *mut libc::c_char {
    let mut nLine: libc::c_int = if zLine.is_null() {
        0 as libc::c_int
    } else {
        100 as libc::c_int
    };
    let mut n: libc::c_int = 0 as libc::c_int;
    loop {
        if n + 100 as libc::c_int > nLine {
            nLine = nLine * 2 as libc::c_int + 100 as libc::c_int;
            zLine =
                realloc(zLine as *mut libc::c_void, nLine as libc::c_ulong) as *mut libc::c_char;
            if zLine.is_null() {
                shell_out_of_memory();
            }
        }
        if fgets(&mut *zLine.offset(n as isize), nLine - n, in_0).is_null() {
            if n == 0 as libc::c_int {
                free(zLine as *mut libc::c_void);
                return 0 as *mut libc::c_char;
            } else {
                *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
                break;
            }
        } else {
            while *zLine.offset(n as isize) != 0 {
                n += 1
            }
            if !(n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '\n' as i32)
            {
                continue;
            }
            n -= 1;
            if n > 0 as libc::c_int
                && *zLine.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '\r' as i32
            {
                n -= 1
            }
            *zLine.offset(n as isize) = 0 as libc::c_int as libc::c_char;
            break;
        }
    }
    /* defined(_WIN32) || defined(WIN32) */
    return zLine;
}
/*
** Retrieve a single line of input text.
**
** If in==0 then read from standard input and prompt before each line.
** If isContinuation is true, then a continuation prompt is appropriate.
** If isContinuation is zero, then the main prompt should be used.
**
** If zPrior is not NULL then it is a buffer from a prior call to this
** routine that can be reused.
**
** The result is stored in space obtained from malloc() and must either
** be freed by the caller or else passed back into this routine via the
** zPrior argument for reuse.
*/
unsafe extern "C" fn one_input_line(
    mut in_0: *mut FILE,
    mut zPrior: *mut libc::c_char,
    mut isContinuation: libc::c_int,
) -> *mut libc::c_char {
    let mut zPrompt: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zResult: *mut libc::c_char = 0 as *mut libc::c_char;
    if !in_0.is_null() {
        zResult = local_getline(zPrior, in_0)
    } else {
        zPrompt = if isContinuation != 0 {
            continuePrompt.as_mut_ptr()
        } else {
            mainPrompt.as_mut_ptr()
        };
        free(zPrior as *mut libc::c_void);
        zResult = readline(zPrompt);
        if !zResult.is_null() && *zResult as libc::c_int != 0 {
            add_history(zResult);
        }
    }
    return zResult;
}
/*
** Return the value of a hexadecimal digit.  Return -1 if the input
** is not a hex digit.
*/
unsafe extern "C" fn hexDigitValue(mut c: libc::c_char) -> libc::c_int {
    if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
        return c as libc::c_int - '0' as i32;
    } else if c as libc::c_int >= 'a' as i32 && c as libc::c_int <= 'f' as i32 {
        return c as libc::c_int - 'a' as i32 + 10 as libc::c_int;
    } else if c as libc::c_int >= 'A' as i32 && c as libc::c_int <= 'F' as i32 {
        return c as libc::c_int - 'A' as i32 + 10 as libc::c_int;
    } else {
        return -(1 as libc::c_int);
    };
}
/*
** Interpret zArg as an integer value, possibly with suffixes.
*/
unsafe extern "C" fn integerValue(mut zArg: *const libc::c_char) -> sqlite3_int64 {
    let mut v: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    static mut aMult: [C2RustUnnamed_14; 9] = [
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KiB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MiB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GiB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1024 as libc::c_int * 1024 as libc::c_int * 1024 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"KB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"MB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"GB\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"K\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"M\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_14 {
                zSuffix: b"G\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                iMult: 1000000000 as libc::c_int,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut isNeg: libc::c_int = 0 as libc::c_int;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
        isNeg = 1 as libc::c_int;
        zArg = zArg.offset(1)
    } else if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32 {
        zArg = zArg.offset(1)
    }
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        let mut x: libc::c_int = 0;
        zArg = zArg.offset(2 as libc::c_int as isize);
        loop {
            x = hexDigitValue(*zArg.offset(0 as libc::c_int as isize));
            if !(x >= 0 as libc::c_int) {
                break;
            }
            v = (v << 4 as libc::c_int) + x as libc::c_longlong;
            zArg = zArg.offset(1)
        }
    } else {
        while *(*__ctype_b_loc()).offset(
            *zArg.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int as isize
        ) as libc::c_int
            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            v = v * 10 as libc::c_int as libc::c_longlong
                + *zArg.offset(0 as libc::c_int as isize) as libc::c_longlong
                - '0' as i32 as libc::c_longlong;
            zArg = zArg.offset(1)
        }
    }
    i = 0 as libc::c_int;
    while i
        < (::std::mem::size_of::<[C2RustUnnamed_14; 9]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_14>() as libc::c_ulong)
            as libc::c_int
    {
        if sqlite3_stricmp(aMult[i as usize].zSuffix, zArg) == 0 as libc::c_int {
            v *= aMult[i as usize].iMult as libc::c_longlong;
            break;
        } else {
            i += 1
        }
    }
    return if isNeg != 0 { -v } else { v };
}
/*
** Initialize and destroy a ShellText object
*/
unsafe extern "C" fn initText(mut p: *mut ShellText) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ShellText>() as libc::c_ulong,
    );
}
unsafe extern "C" fn freeText(mut p: *mut ShellText) {
    free((*p).z as *mut libc::c_void);
    initText(p);
}
/* zIn is either a pointer to a NULL-terminated string in memory obtained
** from malloc(), or a NULL pointer. The string pointed to by zAppend is
** added to zIn, and the result returned in memory obtained from malloc().
** zIn, if it was not NULL, is freed.
**
** If the third argument, quote, is not '\0', then it is used as a
** quote character for zAppend.
*/
unsafe extern "C" fn appendText(
    mut p: *mut ShellText,
    mut zAppend: *const libc::c_char,
    mut quote: libc::c_char,
) {
    let mut len: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut nAppend: libc::c_int = strlen30(zAppend);
    len = nAppend + (*p).n + 1 as libc::c_int;
    if quote != 0 {
        len += 2 as libc::c_int;
        i = 0 as libc::c_int;
        while i < nAppend {
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                len += 1
            }
            i += 1
        }
    }
    if (*p).z.is_null() || (*p).n + len >= (*p).nAlloc {
        (*p).nAlloc = (*p).nAlloc * 2 as libc::c_int + len + 20 as libc::c_int;
        (*p).z =
            realloc((*p).z as *mut libc::c_void, (*p).nAlloc as libc::c_ulong) as *mut libc::c_char;
        if (*p).z.is_null() {
            shell_out_of_memory();
        }
    }
    if quote != 0 {
        let mut zCsr: *mut libc::c_char = (*p).z.offset((*p).n as isize);
        let fresh1 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh1 = quote;
        i = 0 as libc::c_int;
        while i < nAppend {
            let fresh2 = zCsr;
            zCsr = zCsr.offset(1);
            *fresh2 = *zAppend.offset(i as isize);
            if *zAppend.offset(i as isize) as libc::c_int == quote as libc::c_int {
                let fresh3 = zCsr;
                zCsr = zCsr.offset(1);
                *fresh3 = quote
            }
            i += 1
        }
        let fresh4 = zCsr;
        zCsr = zCsr.offset(1);
        *fresh4 = quote;
        (*p).n = zCsr.offset_from((*p).z) as libc::c_long as libc::c_int;
        *zCsr = '\u{0}' as i32 as libc::c_char
    } else {
        memcpy(
            (*p).z.offset((*p).n as isize) as *mut libc::c_void,
            zAppend as *const libc::c_void,
            nAppend as libc::c_ulong,
        );
        (*p).n += nAppend;
        *(*p).z.offset((*p).n as isize) = '\u{0}' as i32 as libc::c_char
    };
}
/*
** Attempt to determine if identifier zName needs to be quoted, either
** because it contains non-alphanumeric characters, or because it is an
** SQLite keyword.  Be conservative in this estimate:  When in doubt assume
** that quoting is required.
**
** Return '"' if quoting is required.  Return 0 if no quoting is required.
*/
unsafe extern "C" fn quoteChar(mut zName: *const libc::c_char) -> libc::c_char {
    let mut i: libc::c_int = 0;
    if *(*__ctype_b_loc())
        .offset(*zName.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int as isize)
        as libc::c_int
        & _ISalpha as libc::c_int as libc::c_ushort as libc::c_int
        == 0
        && *zName.offset(0 as libc::c_int as isize) as libc::c_int != '_' as i32
    {
        return '\"' as i32 as libc::c_char;
    } else {
        i = 0 as libc::c_int;
        while *zName.offset(i as isize) != 0 {
            if *(*__ctype_b_loc())
                .offset(*zName.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
                as libc::c_int
                & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                == 0
                && *zName.offset(i as isize) as libc::c_int != '_' as i32
            {
                return '\"' as i32 as libc::c_char;
            } else {
                i += 1
            }
        }
        return if sqlite3_keyword_check(zName, i) != 0 {
            '\"' as i32
        } else {
            0 as libc::c_int
        } as libc::c_char;
    };
}
/*
** Construct a fake object name and column list to describe the structure
** of the view, virtual table, or table valued function zSchema.zName.
*/
unsafe extern "C" fn shellFakeSchema(
    mut db: *mut sqlite3,
    mut zSchema: *const libc::c_char,
    mut zName: *const libc::c_char,
) -> *mut libc::c_char
/* The name of the virtual table */ {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut s: ShellText = ShellText {
        z: 0 as *mut libc::c_char,
        n: 0,
        nAlloc: 0,
    };
    let mut cQuote: libc::c_char = 0;
    let mut zDiv: *mut libc::c_char =
        b"(\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
    let mut nRow: libc::c_int = 0 as libc::c_int;
    zSql = sqlite3_mprintf(
        b"PRAGMA \"%w\".table_info=%Q;\x00" as *const u8 as *const libc::c_char,
        if !zSchema.is_null() {
            zSchema
        } else {
            b"main\x00" as *const u8 as *const libc::c_char
        },
        zName,
    );
    sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    initText(&mut s);
    if !zSchema.is_null() {
        cQuote = quoteChar(zSchema);
        if cQuote as libc::c_int != 0
            && sqlite3_stricmp(zSchema, b"temp\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            cQuote = 0 as libc::c_int as libc::c_char
        }
        appendText(&mut s, zSchema, cQuote);
        appendText(
            &mut s,
            b".\x00" as *const u8 as *const libc::c_char,
            0 as libc::c_int as libc::c_char,
        );
    }
    cQuote = quoteChar(zName);
    appendText(&mut s, zName, cQuote);
    while sqlite3_step(pStmt) == 100 as libc::c_int {
        let mut zCol: *const libc::c_char =
            sqlite3_column_text(pStmt, 1 as libc::c_int) as *const libc::c_char;
        nRow += 1;
        appendText(&mut s, zDiv, 0 as libc::c_int as libc::c_char);
        zDiv = b",\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
        cQuote = quoteChar(zCol);
        appendText(&mut s, zCol, cQuote);
    }
    appendText(
        &mut s,
        b")\x00" as *const u8 as *const libc::c_char,
        0 as libc::c_int as libc::c_char,
    );
    sqlite3_finalize(pStmt);
    if nRow == 0 as libc::c_int {
        freeText(&mut s);
        s.z = 0 as *mut libc::c_char
    }
    return s.z;
}
/*
** SQL function:  shell_module_schema(X)
**
** Return a fake schema for the table-valued function or eponymous virtual
** table X.
*/
unsafe extern "C" fn shellModuleSchema(
    mut pCtx: *mut sqlite3_context,
    mut _nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char =
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    let mut zFake: *mut libc::c_char = shellFakeSchema(
        sqlite3_context_db_handle(pCtx),
        0 as *const libc::c_char,
        zName,
    );
    if !zFake.is_null() {
        sqlite3_result_text(
            pCtx,
            sqlite3_mprintf(b"/* %s */\x00" as *const u8 as *const libc::c_char, zFake),
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        );
        free(zFake as *mut libc::c_void);
    };
}
/*
** SQL function:  shell_add_schema(S,X)
**
** Add the schema name X to the CREATE statement in S and return the result.
** Examples:
**
**    CREATE TABLE t1(x)   ->   CREATE TABLE xyz.t1(x);
**
** Also works on
**
**    CREATE INDEX
**    CREATE UNIQUE INDEX
**    CREATE VIEW
**    CREATE TRIGGER
**    CREATE VIRTUAL TABLE
**
** This UDF is used by the .schema command to insert the schema name of
** attached databases into the middle of the sqlite_schema.sql field.
*/
unsafe extern "C" fn shellAddSchemaName(
    mut pCtx: *mut sqlite3_context,
    mut _nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    static mut aPrefix: [*const libc::c_char; 6] = [
        b"TABLE\x00" as *const u8 as *const libc::c_char,
        b"INDEX\x00" as *const u8 as *const libc::c_char,
        b"UNIQUE INDEX\x00" as *const u8 as *const libc::c_char,
        b"VIEW\x00" as *const u8 as *const libc::c_char,
        b"TRIGGER\x00" as *const u8 as *const libc::c_char,
        b"VIRTUAL TABLE\x00" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut zIn: *const libc::c_char =
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    let mut zSchema: *const libc::c_char =
        sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize)) as *const libc::c_char;
    let mut zName: *const libc::c_char =
        sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize)) as *const libc::c_char;
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx);
    if !zIn.is_null()
        && strncmp(
            zIn,
            b"CREATE \x00" as *const u8 as *const libc::c_char,
            7 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 6]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                as libc::c_int
        {
            let mut n: libc::c_int = strlen30(aPrefix[i as usize]);
            if strncmp(
                zIn.offset(7 as libc::c_int as isize),
                aPrefix[i as usize],
                n as libc::c_ulong,
            ) == 0 as libc::c_int
                && *zIn.offset((n + 7 as libc::c_int) as isize) as libc::c_int == ' ' as i32
            {
                let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut zFake: *mut libc::c_char = 0 as *mut libc::c_char;
                if !zSchema.is_null() {
                    let mut cQuote: libc::c_char = quoteChar(zSchema);
                    if cQuote as libc::c_int != 0
                        && sqlite3_stricmp(zSchema, b"temp\x00" as *const u8 as *const libc::c_char)
                            != 0 as libc::c_int
                    {
                        z = sqlite3_mprintf(
                            b"%.*s \"%w\".%s\x00" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        )
                    } else {
                        z = sqlite3_mprintf(
                            b"%.*s %s.%s\x00" as *const u8 as *const libc::c_char,
                            n + 7 as libc::c_int,
                            zIn,
                            zSchema,
                            zIn.offset(n as isize).offset(8 as libc::c_int as isize),
                        )
                    }
                }
                if !zName.is_null()
                    && *aPrefix[i as usize].offset(0 as libc::c_int as isize) as libc::c_int
                        == 'V' as i32
                    && {
                        zFake = shellFakeSchema(db, zSchema, zName);
                        !zFake.is_null()
                    }
                {
                    if z.is_null() {
                        z = sqlite3_mprintf(
                            b"%s\n/* %s */\x00" as *const u8 as *const libc::c_char,
                            zIn,
                            zFake,
                        )
                    } else {
                        z = sqlite3_mprintf(
                            b"%z\n/* %s */\x00" as *const u8 as *const libc::c_char,
                            z,
                            zFake,
                        )
                    }
                    free(zFake as *mut libc::c_void);
                }
                if !z.is_null() {
                    sqlite3_result_text(
                        pCtx,
                        z,
                        -(1 as libc::c_int),
                        Some(sqlite3_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
                    );
                    return;
                }
            }
            i += 1
        }
    }
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
/* Insert next input into u.x[nLoaded^ixMask]. */
/*
** A single step of the Keccak mixing function for a 1600-bit state
*/
unsafe extern "C" fn KeccakF1600Step(mut p: *mut SHA3Context) {
    let mut i: libc::c_int = 0;
    let mut b0: u64_0 = 0;
    let mut b1: u64_0 = 0;
    let mut b2: u64_0 = 0;
    let mut b3: u64_0 = 0;
    let mut b4: u64_0 = 0;
    let mut c0: u64_0 = 0;
    let mut c1: u64_0 = 0;
    let mut c2: u64_0 = 0;
    let mut c3: u64_0 = 0;
    let mut c4: u64_0 = 0;
    let mut d0: u64_0 = 0;
    let mut d1: u64_0 = 0;
    let mut d2: u64_0 = 0;
    let mut d3: u64_0 = 0;
    let mut d4: u64_0 = 0;
    static mut RC: [u64_0; 24] = [
        0x1 as libc::c_ulonglong,
        0x8082 as libc::c_ulonglong,
        0x800000000000808a as libc::c_ulonglong,
        0x8000000080008000 as libc::c_ulonglong,
        0x808b as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008009 as libc::c_ulonglong,
        0x8a as libc::c_ulonglong,
        0x88 as libc::c_ulonglong,
        0x80008009 as libc::c_ulonglong,
        0x8000000a as libc::c_ulonglong,
        0x8000808b as libc::c_ulonglong,
        0x800000000000008b as libc::c_ulonglong,
        0x8000000000008089 as libc::c_ulonglong,
        0x8000000000008003 as libc::c_ulonglong,
        0x8000000000008002 as libc::c_ulonglong,
        0x8000000000000080 as libc::c_ulonglong,
        0x800a as libc::c_ulonglong,
        0x800000008000000a as libc::c_ulonglong,
        0x8000000080008081 as libc::c_ulonglong,
        0x8000000000008080 as libc::c_ulonglong,
        0x80000001 as libc::c_ulonglong,
        0x8000000080008008 as libc::c_ulonglong,
    ];
    i = 0 as libc::c_int;
    while i < 24 as libc::c_int {
        c0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[5 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[10 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[15 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[20 as libc::c_int as usize];
        c1 = (*p).u.s.deref_mut()[1 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[6 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[11 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[16 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[21 as libc::c_int as usize];
        c2 = (*p).u.s.deref_mut()[2 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[7 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[12 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[17 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[22 as libc::c_int as usize];
        c3 = (*p).u.s.deref_mut()[3 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[8 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[13 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[18 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[23 as libc::c_int as usize];
        c4 = (*p).u.s.deref_mut()[4 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[9 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[14 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[19 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[24 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^= RC[i as usize];
        (*p).u.s.deref_mut()[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s.deref_mut()[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s.deref_mut()[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s.deref_mut()[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s.deref_mut()[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[10 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[20 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[5 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[15 as libc::c_int as usize];
        c1 = (*p).u.s.deref_mut()[6 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[16 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[1 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[11 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[21 as libc::c_int as usize];
        c2 = (*p).u.s.deref_mut()[12 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[22 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[7 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[17 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[2 as libc::c_int as usize];
        c3 = (*p).u.s.deref_mut()[18 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[3 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[13 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[23 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[8 as libc::c_int as usize];
        c4 = (*p).u.s.deref_mut()[24 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[9 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[19 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[4 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[14 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^= RC[(i + 1 as libc::c_int) as usize];
        (*p).u.s.deref_mut()[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s.deref_mut()[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s.deref_mut()[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s.deref_mut()[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s.deref_mut()[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[20 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[15 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[10 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[5 as libc::c_int as usize];
        c1 = (*p).u.s.deref_mut()[16 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[11 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[6 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[1 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[21 as libc::c_int as usize];
        c2 = (*p).u.s.deref_mut()[7 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[2 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[22 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[17 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[12 as libc::c_int as usize];
        c3 = (*p).u.s.deref_mut()[23 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[18 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[13 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[8 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[3 as libc::c_int as usize];
        c4 = (*p).u.s.deref_mut()[14 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[9 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[4 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[24 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[19 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^= RC[(i + 2 as libc::c_int) as usize];
        (*p).u.s.deref_mut()[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s.deref_mut()[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s.deref_mut()[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s.deref_mut()[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s.deref_mut()[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        c0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[15 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[5 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[20 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[10 as libc::c_int as usize];
        c1 = (*p).u.s.deref_mut()[11 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[1 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[16 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[6 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[21 as libc::c_int as usize];
        c2 = (*p).u.s.deref_mut()[22 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[12 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[2 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[17 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[7 as libc::c_int as usize];
        c3 = (*p).u.s.deref_mut()[8 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[23 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[13 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[3 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[18 as libc::c_int as usize];
        c4 = (*p).u.s.deref_mut()[19 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[9 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[24 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[14 as libc::c_int as usize]
            ^ (*p).u.s.deref_mut()[4 as libc::c_int as usize];
        d0 = c4 ^ (c1 << 1 as libc::c_int | c1 >> 64 as libc::c_int - 1 as libc::c_int);
        d1 = c0 ^ (c2 << 1 as libc::c_int | c2 >> 64 as libc::c_int - 1 as libc::c_int);
        d2 = c1 ^ (c3 << 1 as libc::c_int | c3 >> 64 as libc::c_int - 1 as libc::c_int);
        d3 = c2 ^ (c4 << 1 as libc::c_int | c4 >> 64 as libc::c_int - 1 as libc::c_int);
        d4 = c3 ^ (c0 << 1 as libc::c_int | c0 >> 64 as libc::c_int - 1 as libc::c_int);
        b0 = (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^ d0;
        b1 = ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) << 44 as libc::c_int
            | ((*p).u.s.deref_mut()[1 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 44 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) << 43 as libc::c_int
            | ((*p).u.s.deref_mut()[2 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 43 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) << 21 as libc::c_int
            | ((*p).u.s.deref_mut()[3 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 21 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) << 14 as libc::c_int
            | ((*p).u.s.deref_mut()[4 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 14 as libc::c_int;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[0 as libc::c_int as usize] ^= RC[(i + 3 as libc::c_int) as usize];
        (*p).u.s.deref_mut()[1 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[2 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[3 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[4 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b2 = ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) << 3 as libc::c_int
            | ((*p).u.s.deref_mut()[5 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 3 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) << 45 as libc::c_int
            | ((*p).u.s.deref_mut()[6 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 45 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) << 61 as libc::c_int
            | ((*p).u.s.deref_mut()[7 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 61 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) << 28 as libc::c_int
            | ((*p).u.s.deref_mut()[8 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 28 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) << 20 as libc::c_int
            | ((*p).u.s.deref_mut()[9 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 20 as libc::c_int;
        (*p).u.s.deref_mut()[5 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[6 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[7 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[8 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[9 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b4 = ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) << 18 as libc::c_int
            | ((*p).u.s.deref_mut()[10 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 18 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) << 1 as libc::c_int
            | ((*p).u.s.deref_mut()[11 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 1 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) << 6 as libc::c_int
            | ((*p).u.s.deref_mut()[12 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 6 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) << 25 as libc::c_int
            | ((*p).u.s.deref_mut()[13 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 25 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) << 8 as libc::c_int
            | ((*p).u.s.deref_mut()[14 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 8 as libc::c_int;
        (*p).u.s.deref_mut()[10 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[11 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[12 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[13 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[14 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b1 = ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) << 36 as libc::c_int
            | ((*p).u.s.deref_mut()[15 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 36 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) << 10 as libc::c_int
            | ((*p).u.s.deref_mut()[16 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 10 as libc::c_int;
        b3 = ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) << 15 as libc::c_int
            | ((*p).u.s.deref_mut()[17 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 15 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) << 56 as libc::c_int
            | ((*p).u.s.deref_mut()[18 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 56 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) << 27 as libc::c_int
            | ((*p).u.s.deref_mut()[19 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 27 as libc::c_int;
        (*p).u.s.deref_mut()[15 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[16 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[17 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[18 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[19 as libc::c_int as usize] = b4 ^ !b0 & b1;
        b3 = ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) << 41 as libc::c_int
            | ((*p).u.s.deref_mut()[20 as libc::c_int as usize] ^ d0) >> 64 as libc::c_int - 41 as libc::c_int;
        b4 = ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) << 2 as libc::c_int
            | ((*p).u.s.deref_mut()[21 as libc::c_int as usize] ^ d1) >> 64 as libc::c_int - 2 as libc::c_int;
        b0 = ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) << 62 as libc::c_int
            | ((*p).u.s.deref_mut()[22 as libc::c_int as usize] ^ d2) >> 64 as libc::c_int - 62 as libc::c_int;
        b1 = ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) << 55 as libc::c_int
            | ((*p).u.s.deref_mut()[23 as libc::c_int as usize] ^ d3) >> 64 as libc::c_int - 55 as libc::c_int;
        b2 = ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) << 39 as libc::c_int
            | ((*p).u.s.deref_mut()[24 as libc::c_int as usize] ^ d4) >> 64 as libc::c_int - 39 as libc::c_int;
        (*p).u.s.deref_mut()[20 as libc::c_int as usize] = b0 ^ !b1 & b2;
        (*p).u.s.deref_mut()[21 as libc::c_int as usize] = b1 ^ !b2 & b3;
        (*p).u.s.deref_mut()[22 as libc::c_int as usize] = b2 ^ !b3 & b4;
        (*p).u.s.deref_mut()[23 as libc::c_int as usize] = b3 ^ !b4 & b0;
        (*p).u.s.deref_mut()[24 as libc::c_int as usize] = b4 ^ !b0 & b1;
        i += 4 as libc::c_int
    }
}
/*
** Initialize a new hash.  iSize determines the size of the hash
** in bits and should be one of 224, 256, 384, or 512.  Or iSize
** can be zero to use the default hash size of 256 bits.
*/
unsafe extern "C" fn SHA3Init(mut p: *mut SHA3Context, mut iSize: libc::c_int) {
    memset(
        p as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<SHA3Context>() as libc::c_ulong,
    );
    if iSize >= 128 as libc::c_int && iSize <= 512 as libc::c_int {
        (*p).nRate = ((1600 as libc::c_int
            - (iSize + 31 as libc::c_int & !(31 as libc::c_int)) * 2 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint
    } else {
        (*p).nRate = ((1600 as libc::c_int - 2 as libc::c_int * 256 as libc::c_int)
            / 8 as libc::c_int) as libc::c_uint
    };
    /* Known to be little-endian at compile-time. No-op */
}
/*
** Make consecutive calls to the SHA3Update function to add new content
** to the hash
*/
unsafe extern "C" fn SHA3Update(
    mut p: *mut SHA3Context,
    mut aData: *const libc::c_uchar,
    mut nData: libc::c_uint,
) {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if (*p).nLoaded.wrapping_rem(8 as libc::c_int as libc::c_uint)
        == 0 as libc::c_int as libc::c_uint
        && aData.offset_from(0 as *const libc::c_uchar) as libc::c_long
            & 7 as libc::c_int as libc::c_long
            == 0 as libc::c_int as libc::c_long
    {
        while i.wrapping_add(7 as libc::c_int as libc::c_uint) < nData {
            (*p).u.s.deref_mut()[(*p).nLoaded.wrapping_div(8 as libc::c_int as libc::c_uint) as usize] ^=
                *(&*aData.offset(i as isize) as *const libc::c_uchar as *mut u64_0);
            (*p).nLoaded = (*p).nLoaded.wrapping_add(8 as libc::c_int as libc::c_uint);
            if (*p).nLoaded >= (*p).nRate {
                KeccakF1600Step(p);
                (*p).nLoaded = 0 as libc::c_int as libc::c_uint
            }
            i = i.wrapping_add(8 as libc::c_int as libc::c_uint)
        }
    }
    while i < nData {
        (*p).u.x.deref_mut()[(*p).nLoaded as usize] = ((*p).u.x.deref_mut()[(*p).nLoaded as usize] as libc::c_int
            ^ *aData.offset(i as isize) as libc::c_int)
            as libc::c_uchar;
        (*p).nLoaded = (*p).nLoaded.wrapping_add(1);
        if (*p).nLoaded == (*p).nRate {
            KeccakF1600Step(p);
            (*p).nLoaded = 0 as libc::c_int as libc::c_uint
        }
        i = i.wrapping_add(1)
    }
}
/*
** After all content has been added, invoke SHA3Final() to compute
** the final hash.  The function returns a pointer to the binary
** hash value.
*/
unsafe extern "C" fn SHA3Final(mut p: *mut SHA3Context) -> *mut libc::c_uchar {
    let mut i: libc::c_uint = 0;
    if (*p).nLoaded == (*p).nRate.wrapping_sub(1 as libc::c_int as libc::c_uint) {
        let c1: libc::c_uchar = 0x86 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c1, 1 as libc::c_int as libc::c_uint);
    } else {
        let c2: libc::c_uchar = 0x6 as libc::c_int as libc::c_uchar;
        let c3: libc::c_uchar = 0x80 as libc::c_int as libc::c_uchar;
        SHA3Update(p, &c2, 1 as libc::c_int as libc::c_uint);
        (*p).nLoaded = (*p).nRate.wrapping_sub(1 as libc::c_int as libc::c_uint);
        SHA3Update(p, &c3, 1 as libc::c_int as libc::c_uint);
    }
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*p).nRate {
        (*p).u.x.deref_mut().deref_mut()[i.wrapping_add((*p).nRate) as usize] = (*p).u.x.deref_mut()[(i ^ (*p).ixMask) as usize];
        i = i.wrapping_add(1)
    }
    return &mut *(*p).u.x.deref_mut().deref_mut().as_mut_ptr().offset((*p).nRate as isize) as *mut libc::c_uchar;
}
/* End of the hashing logic
*****************************************************************************/
/*
** Implementation of the sha3(X,SIZE) function.
**
** Return a BLOB which is the SIZE-bit SHA3 hash of X.  The default
** size is 256.  If X is a BLOB, it is hashed as is.
** For all other non-NULL types of input, X is converted into a UTF-8 string
** and the string is hashed without the trailing 0x00 terminator.  The hash
** of a NULL value is NULL.
*/
unsafe extern "C" fn sha3Func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: ManuallyDrop::new([0; 25]) },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut eType: libc::c_int = sqlite3_value_type(*argv.offset(0 as libc::c_int as isize));
    let mut nByte: libc::c_int = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int
            && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int
            && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\x00" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if eType == 5 as libc::c_int {
        return;
    } else {
        SHA3Init(&mut cx, iSize);
        if eType == 4 as libc::c_int {
            SHA3Update(
                &mut cx,
                sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_uchar,
                nByte as libc::c_uint,
            );
        } else {
            SHA3Update(
                &mut cx,
                sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)),
                nByte as libc::c_uint,
            );
        }
        sqlite3_result_blob(
            context,
            SHA3Final(&mut cx) as *const libc::c_void,
            iSize / 8 as libc::c_int,
            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                -(1 as libc::c_int) as libc::intptr_t,
            ),
        );
        return;
    };
}
/* Compute a string using sqlite3_vsnprintf() with a maximum length
** of 50 bytes and add it to the hash.
*/
unsafe extern "C" fn hash_step_vformat(
    mut p: *mut SHA3Context,
    mut zFormat: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    let mut n: libc::c_int = 0;
    let mut zBuf: [libc::c_char; 50] = [0; 50];
    ap = args.clone();
    sqlite3_vsnprintf(
        ::std::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong as libc::c_int,
        zBuf.as_mut_ptr(),
        zFormat,
        ap.as_va_list(),
    );
    n = strlen(zBuf.as_mut_ptr()) as libc::c_int;
    SHA3Update(
        p,
        zBuf.as_mut_ptr() as *mut libc::c_uchar,
        n as libc::c_uint,
    );
}
/*
** Implementation of the sha3_query(SQL,SIZE) function.
**
** This function compiles and runs the SQL statement(s) given in the
** argument. The results are hashed using a SIZE-bit SHA3.  The default
** size is 256.
**
** The format of the byte stream that is hashed is summarized as follows:
**
**       S<n>:<sql>
**       R
**       N
**       I<int>
**       F<ieee-float>
**       B<size>:<bytes>
**       T<size>:<text>
**
** <sql> is the original SQL text for each statement run and <n> is
** the size of that text.  The SQL text is UTF-8.  A single R character
** occurs before the start of each row.  N means a NULL value.
** I mean an 8-byte little-endian integer <int>.  F is a floating point
** number with an 8-byte little-endian IEEE floating point value <ieee-float>.
** B means blobs of <size> bytes.  T means text rendered as <size>
** bytes of UTF-8.  The <n> and <size> values are expressed as an ASCII
** text integers.
**
** For each SQL statement in the X input, there is one S segment.  Each
** S segment is followed by zero or more R segments, one for each row in the
** result set.  After each R, there are one or more N, I, F, B, or T segments,
** one for each column in the result set.  Segments are concatentated directly
** with no delimiters of any kind.
*/
unsafe extern "C" fn sha3QueryFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(context); /* Number of columns in the result set */
    let mut zSql: *const libc::c_char =
        sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char; /* Loop counter */
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut cx: SHA3Context = SHA3Context {
        u: C2RustUnnamed_15 { s: ManuallyDrop::new([0; 25]) },
        nRate: 0,
        nLoaded: 0,
        ixMask: 0,
    };
    let mut iSize: libc::c_int = 0;
    if argc == 1 as libc::c_int {
        iSize = 256 as libc::c_int
    } else {
        iSize = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
        if iSize != 224 as libc::c_int
            && iSize != 256 as libc::c_int
            && iSize != 384 as libc::c_int
            && iSize != 512 as libc::c_int
        {
            sqlite3_result_error(
                context,
                b"SHA3 size should be one of: 224 256 384 512\x00" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
            );
            return;
        }
    }
    if zSql.is_null() {
        return;
    } else {
        SHA3Init(&mut cx, iSize);
        while *zSql.offset(0 as libc::c_int as isize) != 0 {
            rc = sqlite3_prepare_v2(db, zSql, -(1 as libc::c_int), &mut pStmt, &mut zSql);
            if rc != 0 {
                let mut zMsg: *mut libc::c_char = sqlite3_mprintf(
                    b"error SQL statement [%s]: %s\x00" as *const u8 as *const libc::c_char,
                    zSql,
                    sqlite3_errmsg(db),
                );
                sqlite3_finalize(pStmt);
                sqlite3_result_error(context, zMsg, -(1 as libc::c_int));
                sqlite3_free(zMsg as *mut libc::c_void);
                return;
            } else if sqlite3_stmt_readonly(pStmt) == 0 {
                let mut zMsg_0: *mut libc::c_char = sqlite3_mprintf(
                    b"non-query: [%s]\x00" as *const u8 as *const libc::c_char,
                    sqlite3_sql(pStmt),
                );
                sqlite3_finalize(pStmt);
                sqlite3_result_error(context, zMsg_0, -(1 as libc::c_int));
                sqlite3_free(zMsg_0 as *mut libc::c_void);
                return;
            } else {
                nCol = sqlite3_column_count(pStmt);
                z = sqlite3_sql(pStmt);
                if !z.is_null() {
                    n = strlen(z) as libc::c_int;
                    hash_step_vformat(
                        &mut cx as *mut SHA3Context,
                        b"S%d:\x00" as *const u8 as *const libc::c_char,
                        n,
                    );
                    SHA3Update(&mut cx, z as *mut libc::c_uchar, n as libc::c_uint);
                }
                /* Compute a hash over the result of the query */
                while 100 as libc::c_int == sqlite3_step(pStmt) {
                    SHA3Update(
                        &mut cx,
                        b"R\x00" as *const u8 as *const libc::c_char as *const libc::c_uchar,
                        1 as libc::c_int as libc::c_uint,
                    ); /* Unused parameter */
                    i = 0 as libc::c_int;
                    while i < nCol {
                        match sqlite3_column_type(pStmt, i) {
                            5 => {
                                SHA3Update(
                                    &mut cx,
                                    b"N\x00" as *const u8 as *const libc::c_char
                                        as *const libc::c_uchar,
                                    1 as libc::c_int as libc::c_uint,
                                );
                            }
                            1 => {
                                let mut u: sqlite3_uint64 = 0;
                                let mut j: libc::c_int = 0;
                                let mut x: [libc::c_uchar; 9] = [0; 9];
                                let mut v: sqlite3_int64 = sqlite3_column_int64(pStmt, i);
                                memcpy(
                                    &mut u as *mut sqlite3_uint64 as *mut libc::c_void,
                                    &mut v as *mut sqlite3_int64 as *const libc::c_void,
                                    8 as libc::c_int as libc::c_ulong,
                                );
                                j = 8 as libc::c_int;
                                while j >= 1 as libc::c_int {
                                    x[j as usize] = (u & 0xff as libc::c_int as libc::c_ulonglong)
                                        as libc::c_uchar;
                                    u >>= 8 as libc::c_int;
                                    j -= 1
                                }
                                x[0 as libc::c_int as usize] = 'I' as i32 as libc::c_uchar;
                                SHA3Update(
                                    &mut cx,
                                    x.as_mut_ptr(),
                                    9 as libc::c_int as libc::c_uint,
                                );
                            }
                            2 => {
                                let mut u_0: sqlite3_uint64 = 0;
                                let mut j_0: libc::c_int = 0;
                                let mut x_0: [libc::c_uchar; 9] = [0; 9];
                                let mut r: libc::c_double = sqlite3_column_double(pStmt, i);
                                memcpy(
                                    &mut u_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                                    &mut r as *mut libc::c_double as *const libc::c_void,
                                    8 as libc::c_int as libc::c_ulong,
                                );
                                j_0 = 8 as libc::c_int;
                                while j_0 >= 1 as libc::c_int {
                                    x_0[j_0 as usize] = (u_0
                                        & 0xff as libc::c_int as libc::c_ulonglong)
                                        as libc::c_uchar;
                                    u_0 >>= 8 as libc::c_int;
                                    j_0 -= 1
                                }
                                x_0[0 as libc::c_int as usize] = 'F' as i32 as libc::c_uchar;
                                SHA3Update(
                                    &mut cx,
                                    x_0.as_mut_ptr(),
                                    9 as libc::c_int as libc::c_uint,
                                );
                            }
                            3 => {
                                let mut n2: libc::c_int = sqlite3_column_bytes(pStmt, i);
                                let mut z2: *const libc::c_uchar = sqlite3_column_text(pStmt, i);
                                hash_step_vformat(
                                    &mut cx as *mut SHA3Context,
                                    b"T%d:\x00" as *const u8 as *const libc::c_char,
                                    n2,
                                );
                                SHA3Update(&mut cx, z2, n2 as libc::c_uint);
                            }
                            4 => {
                                let mut n2_0: libc::c_int = sqlite3_column_bytes(pStmt, i);
                                let mut z2_0: *const libc::c_uchar =
                                    sqlite3_column_blob(pStmt, i) as *const libc::c_uchar;
                                hash_step_vformat(
                                    &mut cx as *mut SHA3Context,
                                    b"B%d:\x00" as *const u8 as *const libc::c_char,
                                    n2_0,
                                );
                                SHA3Update(&mut cx, z2_0, n2_0 as libc::c_uint);
                            }
                            _ => {}
                        }
                        i += 1
                    }
                }
                sqlite3_finalize(pStmt);
            }
        }
        sqlite3_result_blob(
            context,
            SHA3Final(&mut cx) as *const libc::c_void,
            iSize / 8 as libc::c_int,
            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                -(1 as libc::c_int) as libc::intptr_t,
            ),
        );
        return;
    };
}
pub unsafe extern "C" fn sqlite3_shathree_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sha3\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sha3Func
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3\x00" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3Func
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\x00" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sha3_query\x00" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sha3QueryFunc
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    return rc;
}
/* Path is relative to this directory */
/*
** Set the result stored by context ctx to a blob containing the
** contents of file zName.  Or, leave the result unchanged (NULL)
** if the file does not exist or is unreadable.
**
** If the file exceeds the SQLite blob size limit, through an
** SQLITE_TOOBIG error.
**
** Throw an SQLITE_IOERR if there are difficulties pulling the file
** off of disk.
*/
unsafe extern "C" fn readFileContents(
    mut ctx: *mut sqlite3_context,
    mut zName: *const libc::c_char,
) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut nIn: sqlite3_int64 = 0;
    let mut pBuf: *mut libc::c_void = 0 as *mut libc::c_void;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut mxBlob: libc::c_int = 0;
    in_0 = fopen(zName, b"rb\x00" as *const u8 as *const libc::c_char);
    if in_0.is_null() {
        /* File does not exist or is unreadable. Leave the result set to NULL. */
        return;
    } else {
        fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        nIn = ftell(in_0) as sqlite3_int64;
        rewind(in_0);
        db = sqlite3_context_db_handle(ctx);
        mxBlob = sqlite3_limit(db, 0 as libc::c_int, -(1 as libc::c_int));
        if nIn > mxBlob as libc::c_longlong {
            sqlite3_result_error_code(ctx, 18 as libc::c_int);
            fclose(in_0);
            return;
        } else {
            pBuf = sqlite3_malloc64(if nIn != 0 {
                nIn
            } else {
                1 as libc::c_int as libc::c_longlong
            } as sqlite3_uint64);
            if pBuf.is_null() {
                sqlite3_result_error_nomem(ctx);
                fclose(in_0);
                return;
            } else {
                if nIn
                    == fread(pBuf, 1 as libc::c_int as libc::c_ulong, nIn as size_t, in_0)
                        as sqlite3_int64
                {
                    sqlite3_result_blob64(
                        ctx,
                        pBuf,
                        nIn as sqlite3_uint64,
                        Some(sqlite3_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
                    );
                } else {
                    sqlite3_result_error_code(ctx, 10 as libc::c_int);
                    sqlite3_free(pBuf);
                }
                fclose(in_0);
                return;
            }
        }
    };
}
/*
** Implementation of the "readfile(X)" SQL function.  The entire content
** of the file named X is read and returned as a BLOB.  NULL is returned
** if the file does not exist or is unreadable.
*/
unsafe extern "C" fn readfileFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char = 0 as *const libc::c_char; /* Unused parameter */
    zName = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    if zName.is_null() {
        return;
    } else {
        readFileContents(context, zName);
        return;
    };
}
/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/
unsafe extern "C" fn ctxErrorMsg(
    mut ctx: *mut sqlite3_context,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
/*
** This function is used in place of stat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls stat().
*/
unsafe extern "C" fn fileStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return stat(zPath, pStatBuf);
}
/*
** This function is used in place of lstat().  On Windows, special handling
** is required in order for the included time to be returned as UTC.  On all
** other systems, this function simply calls lstat().
*/
unsafe extern "C" fn fileLinkStat(
    mut zPath: *const libc::c_char,
    mut pStatBuf: *mut stat,
) -> libc::c_int {
    return lstat(zPath, pStatBuf);
}
/*
** Argument zFile is the name of a file that will be created and/or written
** by SQL function writefile(). This function ensures that the directory
** zFile will be written to exists, creating it if required. The permissions
** for any path components created by this function are set in accordance
** with the current umask.
**
** If an OOM condition is encountered, SQLITE_NOMEM is returned. Otherwise,
** SQLITE_OK is returned if the directory is successfully created, or
** SQLITE_ERROR otherwise.
*/
unsafe extern "C" fn makeDirectory(mut zFile: *const libc::c_char) -> libc::c_int {
    let mut zCopy: *mut libc::c_char =
        sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, zFile);
    let mut rc: libc::c_int = 0 as libc::c_int;
    if zCopy.is_null() {
        rc = 7 as libc::c_int
    } else {
        let mut nCopy: libc::c_int = strlen(zCopy) as libc::c_int;
        let mut i: libc::c_int = 1 as libc::c_int;
        while rc == 0 as libc::c_int {
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_mtim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_ctim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                __glibc_reserved: [0; 3],
            };
            let mut rc2: libc::c_int = 0;
            while *zCopy.offset(i as isize) as libc::c_int != '/' as i32 && i < nCopy {
                i += 1
            }
            if i == nCopy {
                break;
            }
            *zCopy.offset(i as isize) = '\u{0}' as i32 as libc::c_char;
            rc2 = fileStat(zCopy, &mut sStat);
            if rc2 != 0 as libc::c_int {
                if mkdir(zCopy, 0o777 as libc::c_int as __mode_t) != 0 {
                    rc = 1 as libc::c_int
                }
            } else if !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                == 0o40000 as libc::c_int as libc::c_uint)
            {
                rc = 1 as libc::c_int
            }
            *zCopy.offset(i as isize) = '/' as i32 as libc::c_char;
            i += 1
        }
        sqlite3_free(zCopy as *mut libc::c_void);
    }
    return rc;
}
/*
** This function does the work for the writefile() UDF. Refer to
** header comments at the top of this file for details.
*/
unsafe extern "C" fn writeFile(
    mut pCtx: *mut sqlite3_context,
    mut zFile: *const libc::c_char,
    mut pData: *mut sqlite3_value,
    mut mode: mode_t,
    mut mtime: sqlite3_int64,
) -> libc::c_int
/* MTIME parameter (or -1 to not set time) */ {
    if mode & 0o170000 as libc::c_int as libc::c_uint == 0o120000 as libc::c_int as libc::c_uint {
        let mut zTo: *const libc::c_char = sqlite3_value_text(pData) as *const libc::c_char;
        if symlink(zTo, zFile) < 0 as libc::c_int {
            return 1 as libc::c_int;
        }
    } else if mode & 0o170000 as libc::c_int as libc::c_uint
        == 0o40000 as libc::c_int as libc::c_uint
    {
        if mkdir(zFile, mode) != 0 {
            /* The mkdir() call to create the directory failed. This might not
             ** be an error though - if there is already a directory at the same
             ** path and either the permissions already match or can be changed
             ** to do so using chmod(), it is not an error.  */
            let mut sStat: stat = stat {
                st_dev: 0,
                st_ino: 0,
                st_nlink: 0,
                st_mode: 0,
                st_uid: 0,
                st_gid: 0,
                __pad0: 0,
                st_rdev: 0,
                st_size: 0,
                st_blksize: 0,
                st_blocks: 0,
                st_atim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_mtim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                st_ctim: timespec {
                    tv_sec: 0,
                    tv_nsec: 0,
                },
                __glibc_reserved: [0; 3],
            };
            if *__errno_location() != 17 as libc::c_int
                || 0 as libc::c_int != fileStat(zFile, &mut sStat)
                || !(sStat.st_mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint)
                || sStat.st_mode & 0o777 as libc::c_int as libc::c_uint
                    != mode & 0o777 as libc::c_int as libc::c_uint
                    && 0 as libc::c_int != chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint)
            {
                return 1 as libc::c_int;
            }
        }
    } else {
        let mut nWrite: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
        let mut z: *const libc::c_char = 0 as *const libc::c_char;
        let mut rc: libc::c_int = 0 as libc::c_int;
        let mut out: *mut FILE = fopen(zFile, b"wb\x00" as *const u8 as *const libc::c_char);
        if out.is_null() {
            return 1 as libc::c_int;
        } else {
            z = sqlite3_value_blob(pData) as *const libc::c_char;
            if !z.is_null() {
                let mut n: sqlite3_int64 = fwrite(
                    z as *const libc::c_void,
                    1 as libc::c_int as libc::c_ulong,
                    sqlite3_value_bytes(pData) as libc::c_ulong,
                    out,
                ) as sqlite3_int64;
                nWrite = sqlite3_value_bytes(pData) as sqlite3_int64;
                if nWrite != n {
                    rc = 1 as libc::c_int
                }
            }
            fclose(out);
            if rc == 0 as libc::c_int
                && mode != 0
                && chmod(zFile, mode & 0o777 as libc::c_int as libc::c_uint) != 0
            {
                rc = 1 as libc::c_int
            }
            if rc != 0 {
                return 2 as libc::c_int;
            } else {
                sqlite3_result_int64(pCtx, nWrite);
            }
        }
    }
    if mtime >= 0 as libc::c_int as libc::c_longlong {
        /* utimensat() is not universally available */
        /* Legacy unix */
        let mut times: [timeval; 2] = [timeval {
            tv_sec: 0,
            tv_usec: 0,
        }; 2];
        times[1 as libc::c_int as usize].tv_usec = 0 as libc::c_int as __suseconds_t;
        times[0 as libc::c_int as usize].tv_usec = times[1 as libc::c_int as usize].tv_usec;
        times[0 as libc::c_int as usize].tv_sec = time(0 as *mut time_t);
        times[1 as libc::c_int as usize].tv_sec = mtime as __time_t;
        if utimes(zFile, times.as_mut_ptr() as *const timeval) != 0 {
            return 1 as libc::c_int;
        }
    }
    return 0 as libc::c_int;
}
/*
** Implementation of the "writefile(W,X[,Y[,Z]]])" SQL function.
** Refer to header comments at the top of this file for details.
*/
unsafe extern "C" fn writefileFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut mode: mode_t = 0 as libc::c_int as mode_t;
    let mut res: libc::c_int = 0;
    let mut mtime: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    if argc < 2 as libc::c_int || argc > 4 as libc::c_int {
        sqlite3_result_error(
            context,
            b"wrong number of arguments to function writefile()\x00" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    } else {
        zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
        if zFile.is_null() {
            return;
        } else {
            if argc >= 3 as libc::c_int {
                mode = sqlite3_value_int(*argv.offset(2 as libc::c_int as isize)) as mode_t
            }
            if argc == 4 as libc::c_int {
                mtime = sqlite3_value_int64(*argv.offset(3 as libc::c_int as isize))
            }
            res = writeFile(
                context,
                zFile,
                *argv.offset(1 as libc::c_int as isize),
                mode,
                mtime,
            );
            if res == 1 as libc::c_int && *__errno_location() == 2 as libc::c_int {
                if makeDirectory(zFile) == 0 as libc::c_int {
                    res = writeFile(
                        context,
                        zFile,
                        *argv.offset(1 as libc::c_int as isize),
                        mode,
                        mtime,
                    )
                }
            }
            if argc > 2 as libc::c_int && res != 0 as libc::c_int {
                if mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o120000 as libc::c_int as libc::c_uint
                {
                    ctxErrorMsg(
                        context,
                        b"failed to create symlink: %s\x00" as *const u8 as *const libc::c_char,
                        zFile,
                    );
                } else if mode & 0o170000 as libc::c_int as libc::c_uint
                    == 0o40000 as libc::c_int as libc::c_uint
                {
                    ctxErrorMsg(
                        context,
                        b"failed to create directory: %s\x00" as *const u8 as *const libc::c_char,
                        zFile,
                    );
                } else {
                    ctxErrorMsg(
                        context,
                        b"failed to write file: %s\x00" as *const u8 as *const libc::c_char,
                        zFile,
                    );
                }
            }
            return;
        }
    };
}
/*
** SQL function:   lsmode(MODE)
**
** Given a numberic st_mode from stat(), convert it into a human-readable
** text string in the style of "ls -l".
*/
unsafe extern "C" fn lsModeFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut i: libc::c_int = 0;
    let mut iMode: libc::c_int = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    let mut z: [libc::c_char; 16] = [0; 16];
    if iMode & 0o170000 as libc::c_int == 0o120000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'l' as i32 as libc::c_char
    } else if iMode & 0o170000 as libc::c_int == 0o100000 as libc::c_int {
        z[0 as libc::c_int as usize] = '-' as i32 as libc::c_char
    } else if iMode & 0o170000 as libc::c_int == 0o40000 as libc::c_int {
        z[0 as libc::c_int as usize] = 'd' as i32 as libc::c_char
    } else {
        z[0 as libc::c_int as usize] = '?' as i32 as libc::c_char
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        let mut m: libc::c_int = iMode >> (2 as libc::c_int - i) * 3 as libc::c_int;
        let mut a: *mut libc::c_char = &mut *z
            .as_mut_ptr()
            .offset((1 as libc::c_int + i * 3 as libc::c_int) as isize)
            as *mut libc::c_char;
        *a.offset(0 as libc::c_int as isize) = if m & 0x4 as libc::c_int != 0 {
            'r' as i32
        } else {
            '-' as i32
        } as libc::c_char;
        *a.offset(1 as libc::c_int as isize) = if m & 0x2 as libc::c_int != 0 {
            'w' as i32
        } else {
            '-' as i32
        } as libc::c_char;
        *a.offset(2 as libc::c_int as isize) = if m & 0x1 as libc::c_int != 0 {
            'x' as i32
        } else {
            '-' as i32
        } as libc::c_char;
        i += 1
    }
    z[10 as libc::c_int as usize] = '\u{0}' as i32 as libc::c_char;
    sqlite3_result_text(
        context,
        z.as_mut_ptr(),
        -(1 as libc::c_int),
        ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
            -(1 as libc::c_int) as libc::intptr_t,
        ),
    );
}
/* Base class - must be first */
/*
** Construct a new fsdir virtual table object.
*/
unsafe extern "C" fn fsdirConnect(
    mut db: *mut sqlite3,
    mut _pAux: *mut libc::c_void,
    mut _argc: libc::c_int,
    mut _argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut fsdir_tab = 0 as *mut fsdir_tab;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(name,mode,mtime,data,path HIDDEN,dir HIDDEN)\x00" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(::std::mem::size_of::<fsdir_tab>() as libc::c_ulong as libc::c_int)
            as *mut fsdir_tab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<fsdir_tab>() as libc::c_ulong,
            );
            sqlite3_vtab_config(db, 3 as libc::c_int);
        }
    }
    *ppVtab = pNew as *mut sqlite3_vtab;
    return rc;
}
/*
** This method is the destructor for fsdir vtab objects.
*/
unsafe extern "C" fn fsdirDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Constructor for a new fsdir_cursor object.
*/
unsafe extern "C" fn fsdirOpen(
    mut _p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = 0 as *mut fsdir_cursor;
    pCur = sqlite3_malloc(::std::mem::size_of::<fsdir_cursor>() as libc::c_ulong as libc::c_int)
        as *mut fsdir_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    } else {
        memset(
            pCur as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<fsdir_cursor>() as libc::c_ulong,
        );
        (*pCur).iLvl = -(1 as libc::c_int);
        *ppCursor = &mut (*pCur).base;
        return 0 as libc::c_int;
    };
}
/*
** Reset a cursor back to the state it was in when first returned
** by fsdirOpen().
*/
unsafe extern "C" fn fsdirResetCursor(mut pCur: *mut fsdir_cursor) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i <= (*pCur).iLvl {
        let mut pLvl: *mut FsdirLevel = &mut *(*pCur).aLvl.offset(i as isize) as *mut FsdirLevel;
        if !(*pLvl).pDir.is_null() {
            closedir((*pLvl).pDir);
        }
        sqlite3_free((*pLvl).zDir as *mut libc::c_void);
        i += 1
    }
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    sqlite3_free((*pCur).aLvl as *mut libc::c_void);
    (*pCur).aLvl = 0 as *mut FsdirLevel;
    (*pCur).zPath = 0 as *mut libc::c_char;
    (*pCur).zBase = 0 as *const libc::c_char;
    (*pCur).nBase = 0 as libc::c_int;
    (*pCur).nLvl = 0 as libc::c_int;
    (*pCur).iLvl = -(1 as libc::c_int);
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
}
/*
** Destructor for an fsdir_cursor.
*/
unsafe extern "C" fn fsdirClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    sqlite3_free(pCur as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Set the error message for the virtual table associated with cursor
** pCur to the results of vprintf(zFmt, ...).
*/
unsafe extern "C" fn fsdirSetErrmsg(
    mut pCur: *mut fsdir_cursor,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    (*(*pCur).base.pVtab).zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
/*
** Advance an fsdir_cursor to its next row of output.
*/
unsafe extern "C" fn fsdirNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    let mut m: mode_t = (*pCur).sStat.st_mode;
    (*pCur).iRowid += 1;
    if m & 0o170000 as libc::c_int as libc::c_uint == 0o40000 as libc::c_int as libc::c_uint {
        /* Descend into this directory */
        let mut iNew: libc::c_int = (*pCur).iLvl + 1 as libc::c_int;
        let mut pLvl: *mut FsdirLevel = 0 as *mut FsdirLevel;
        if iNew >= (*pCur).nLvl {
            let mut nNew: libc::c_int = iNew + 1 as libc::c_int;
            let mut nByte: sqlite3_int64 = (nNew as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                as sqlite3_int64;
            let mut aNew: *mut FsdirLevel =
                sqlite3_realloc64((*pCur).aLvl as *mut libc::c_void, nByte as sqlite3_uint64)
                    as *mut FsdirLevel;
            if aNew.is_null() {
                return 7 as libc::c_int;
            } else {
                memset(
                    &mut *aNew.offset((*pCur).nLvl as isize) as *mut FsdirLevel
                        as *mut libc::c_void,
                    0 as libc::c_int,
                    (::std::mem::size_of::<FsdirLevel>() as libc::c_ulong)
                        .wrapping_mul((nNew - (*pCur).nLvl) as libc::c_ulong),
                );
                (*pCur).aLvl = aNew;
                (*pCur).nLvl = nNew
            }
        }
        (*pCur).iLvl = iNew;
        pLvl = &mut *(*pCur).aLvl.offset(iNew as isize) as *mut FsdirLevel;
        (*pLvl).zDir = (*pCur).zPath;
        (*pCur).zPath = 0 as *mut libc::c_char;
        (*pLvl).pDir = opendir((*pLvl).zDir);
        if (*pLvl).pDir.is_null() {
            fsdirSetErrmsg(
                pCur,
                b"cannot read directory: %s\x00" as *const u8 as *const libc::c_char,
                (*pCur).zPath,
            );
            return 1 as libc::c_int;
        }
    }
    while (*pCur).iLvl >= 0 as libc::c_int {
        let mut pLvl_0: *mut FsdirLevel =
            &mut *(*pCur).aLvl.offset((*pCur).iLvl as isize) as *mut FsdirLevel;
        let mut pEntry: *mut dirent = readdir((*pLvl_0).pDir);
        if !pEntry.is_null() {
            if (*pEntry).d_name[0 as libc::c_int as usize] as libc::c_int == '.' as i32 {
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int == '.' as i32
                    && (*pEntry).d_name[2 as libc::c_int as usize] as libc::c_int == '\u{0}' as i32
                {
                    continue;
                }
                if (*pEntry).d_name[1 as libc::c_int as usize] as libc::c_int == '\u{0}' as i32 {
                    continue;
                }
            }
            sqlite3_free((*pCur).zPath as *mut libc::c_void);
            (*pCur).zPath = sqlite3_mprintf(
                b"%s/%s\x00" as *const u8 as *const libc::c_char,
                (*pLvl_0).zDir,
                (*pEntry).d_name.as_mut_ptr(),
            );
            if (*pCur).zPath.is_null() {
                return 7 as libc::c_int;
            } else if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
                fsdirSetErrmsg(
                    pCur,
                    b"cannot stat file: %s\x00" as *const u8 as *const libc::c_char,
                    (*pCur).zPath,
                );
                return 1 as libc::c_int;
            } else {
                return 0 as libc::c_int;
            }
        } else {
            closedir((*pLvl_0).pDir);
            sqlite3_free((*pLvl_0).zDir as *mut libc::c_void);
            (*pLvl_0).pDir = 0 as *mut DIR;
            (*pLvl_0).zDir = 0 as *mut libc::c_char;
            (*pCur).iLvl -= 1
        }
    }
    /* EOF */
    sqlite3_free((*pCur).zPath as *mut libc::c_void);
    (*pCur).zPath = 0 as *mut libc::c_char;
    return 0 as libc::c_int;
}
/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/
unsafe extern "C" fn fsdirColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int
/* Which column to return */ {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                &mut *(*pCur).zPath.offset((*pCur).nBase as isize),
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        1 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mode as sqlite3_int64);
        }
        2 => {
            sqlite3_result_int64(ctx, (*pCur).sStat.st_mtim.tv_sec as sqlite3_int64);
        }
        3 => {
            let mut m: mode_t = (*pCur).sStat.st_mode;
            if m & 0o170000 as libc::c_int as libc::c_uint == 0o40000 as libc::c_int as libc::c_uint
            {
                sqlite3_result_null(ctx);
            } else if m & 0o170000 as libc::c_int as libc::c_uint
                == 0o120000 as libc::c_int as libc::c_uint
            {
                let mut aStatic: [libc::c_char; 64] = [0; 64];
                let mut aBuf: *mut libc::c_char = aStatic.as_mut_ptr();
                let mut nBuf: sqlite3_int64 = 64 as libc::c_int as sqlite3_int64;
                let mut n: libc::c_int = 0;
                loop {
                    n = readlink((*pCur).zPath, aBuf, nBuf as size_t) as libc::c_int;
                    if (n as libc::c_longlong) < nBuf {
                        break;
                    }
                    if aBuf != aStatic.as_mut_ptr() {
                        sqlite3_free(aBuf as *mut libc::c_void);
                    }
                    nBuf = nBuf * 2 as libc::c_int as libc::c_longlong;
                    aBuf = sqlite3_malloc64(nBuf as sqlite3_uint64) as *mut libc::c_char;
                    if !aBuf.is_null() {
                        continue;
                    }
                    sqlite3_result_error_nomem(ctx);
                    return 7 as libc::c_int;
                }
                sqlite3_result_text(
                    ctx,
                    aBuf,
                    n,
                    ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                        -(1 as libc::c_int) as libc::intptr_t,
                    ),
                );
                if aBuf != aStatic.as_mut_ptr() {
                    sqlite3_free(aBuf as *mut libc::c_void);
                }
            } else {
                readFileContents(ctx, (*pCur).zPath);
            }
        }
        4 | _ => {}
    }
    /* The FSDIR_COLUMN_PATH and FSDIR_COLUMN_DIR are input parameters.
     ** always return their values as NULL */
    return 0 as libc::c_int;
}
/*
** Return the rowid for the current row. In this implementation, the
** first row returned is assigned rowid value 1, and each subsequent
** row a value 1 more than that of the previous.
*/
unsafe extern "C" fn fsdirRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/
unsafe extern "C" fn fsdirEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    return ((*pCur).zPath == 0 as *mut libc::c_char) as libc::c_int;
}
/*
** xFilter callback.
**
** idxNum==1   PATH parameter only
** idxNum==2   Both PATH and DIR supplied
*/
unsafe extern "C" fn fsdirFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut _idxStr: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut zDir: *const libc::c_char = 0 as *const libc::c_char;
    let mut pCur: *mut fsdir_cursor = cur as *mut fsdir_cursor;
    fsdirResetCursor(pCur);
    if idxNum == 0 as libc::c_int {
        fsdirSetErrmsg(
            pCur,
            b"table function fsdir requires an argument\x00" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else {
        zDir = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
        if zDir.is_null() {
            fsdirSetErrmsg(
                pCur,
                b"table function fsdir requires a non-NULL argument\x00" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        } else {
            if argc == 2 as libc::c_int {
                (*pCur).zBase = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
                    as *const libc::c_char
            }
            if !(*pCur).zBase.is_null() {
                (*pCur).nBase = strlen((*pCur).zBase) as libc::c_int + 1 as libc::c_int;
                (*pCur).zPath = sqlite3_mprintf(
                    b"%s/%s\x00" as *const u8 as *const libc::c_char,
                    (*pCur).zBase,
                    zDir,
                )
            } else {
                (*pCur).zPath = sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, zDir)
            }
            if (*pCur).zPath.is_null() {
                return 7 as libc::c_int;
            } else if fileLinkStat((*pCur).zPath, &mut (*pCur).sStat) != 0 {
                fsdirSetErrmsg(
                    pCur,
                    b"cannot stat file: %s\x00" as *const u8 as *const libc::c_char,
                    (*pCur).zPath,
                );
                return 1 as libc::c_int;
            } else {
                return 0 as libc::c_int;
            }
        }
    };
}
/*
** SQLite will invoke this method one or more times while planning a query
** that uses the generate_series virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** The query plan is represented by values of idxNum:
**
**  (1)  The path value is supplied by argv[0]
**  (2)  Path is in argv[0] and dir is in argv[1]
*/
unsafe extern "C" fn fsdirBestIndex(
    mut _tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut current_block: u64; /* Loop over constraints */
    let mut i: libc::c_int = 0; /* Index in pIdxInfo->aConstraint of PATH= */
    let mut idxPath: libc::c_int = -(1 as libc::c_int); /* Index in pIdxInfo->aConstraint of DIR= */
    let mut idxDir: libc::c_int = -(1 as libc::c_int); /* True if an unusable PATH= constraint is seen */
    let mut seenPath: libc::c_int = 0 as libc::c_int; /* True if an unusable DIR= constraint is seen */
    let mut seenDir: libc::c_int = 0 as libc::c_int;
    let mut pConstraint: *const sqlite3_index_constraint = 0 as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
            match (*pConstraint).iColumn {
                4 => {
                    current_block = 13513818773234778473;
                    match current_block {
                        13513818773234778473 => {
                            if (*pConstraint).usable != 0 {
                                idxPath = i;
                                seenPath = 0 as libc::c_int
                            } else if idxPath < 0 as libc::c_int {
                                seenPath = 1 as libc::c_int
                            }
                        }
                        _ => {
                            if (*pConstraint).usable != 0 {
                                idxDir = i;
                                seenDir = 0 as libc::c_int
                            } else if idxDir < 0 as libc::c_int {
                                seenDir = 1 as libc::c_int
                            }
                        }
                    }
                }
                5 => {
                    current_block = 17860125682698302841;
                    match current_block {
                        13513818773234778473 => {
                            if (*pConstraint).usable != 0 {
                                idxPath = i;
                                seenPath = 0 as libc::c_int
                            } else if idxPath < 0 as libc::c_int {
                                seenPath = 1 as libc::c_int
                            }
                        }
                        _ => {
                            if (*pConstraint).usable != 0 {
                                idxDir = i;
                                seenDir = 0 as libc::c_int
                            } else if idxDir < 0 as libc::c_int {
                                seenDir = 1 as libc::c_int
                            }
                        }
                    }
                }
                _ => {}
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1)
    }
    if seenPath != 0 || seenDir != 0 {
        /* If input parameters are unusable, disallow this plan */
        return 19 as libc::c_int;
    } else {
        if idxPath < 0 as libc::c_int {
            (*pIdxInfo).idxNum = 0 as libc::c_int;
            /* The pIdxInfo->estimatedCost should have been initialized to a huge
             ** number.  Leave it unchanged. */
            (*pIdxInfo).estimatedRows = 0x7fffffff as libc::c_int as sqlite3_int64
        } else {
            (*(*pIdxInfo).aConstraintUsage.offset(idxPath as isize)).omit =
                1 as libc::c_int as libc::c_uchar;
            (*(*pIdxInfo).aConstraintUsage.offset(idxPath as isize)).argvIndex = 1 as libc::c_int;
            if idxDir >= 0 as libc::c_int {
                (*(*pIdxInfo).aConstraintUsage.offset(idxDir as isize)).omit =
                    1 as libc::c_int as libc::c_uchar;
                (*(*pIdxInfo).aConstraintUsage.offset(idxDir as isize)).argvIndex =
                    2 as libc::c_int;
                (*pIdxInfo).idxNum = 2 as libc::c_int;
                (*pIdxInfo).estimatedCost = 10.0f64
            } else {
                (*pIdxInfo).idxNum = 1 as libc::c_int;
                (*pIdxInfo).estimatedCost = 100.0f64
            }
        }
        return 0 as libc::c_int;
    };
}
/*
** Register the "fsdir" virtual table.
*/
unsafe extern "C" fn fsdirRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut fsdirModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    fsdirConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    fsdirBestIndex
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    fsdirDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    fsdirOpen
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    fsdirClose as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    fsdirFilter
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: libc::c_int,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    fsdirNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    fsdirEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    fsdirColumn
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    fsdirRowid
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"fsdir\x00" as *const u8 as *const libc::c_char,
        &mut fsdirModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
/* SQLITE_OMIT_VIRTUALTABLE */
pub unsafe extern "C" fn sqlite3_fileio_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int; /* Unused parameter */
    rc = sqlite3_create_function(
        db,
        b"readfile\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x80000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            readfileFunc
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"writefile\x00" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int | 0x80000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                writefileFunc
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"lsmode\x00" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                lsModeFunc
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    if rc == 0 as libc::c_int {
        rc = fsdirRegister(db)
    }
    return rc;
}
/*
** The completionConnect() method is invoked to create a new
** completion_vtab that describes the completion virtual table.
**
** Think of this routine as the constructor for completion_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the completion_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against completion will look like.
*/
unsafe extern "C" fn completionConnect(
    mut db: *mut sqlite3,
    mut _pAux: *mut libc::c_void,
    mut _argc: libc::c_int,
    mut _argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut completion_vtab = 0 as *mut completion_vtab; /* Unused parameter */
    let mut rc: libc::c_int = 0; /* Unused parameter */
    sqlite3_vtab_config(db, 2 as libc::c_int); /* Unused parameter */
    rc =
        sqlite3_declare_vtab(db,
                             b"CREATE TABLE x(  candidate TEXT,  prefix TEXT HIDDEN,  wholeline TEXT HIDDEN,  phase INT HIDDEN)\x00"
                                 as *const u8 as
                                 *const libc::c_char); /* Unused parameter */
    if rc == 0 as libc::c_int {
        pNew = sqlite3_malloc(
            ::std::mem::size_of::<completion_vtab>() as libc::c_ulong as libc::c_int
        ) as *mut completion_vtab;
        *ppVtab = pNew as *mut sqlite3_vtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<completion_vtab>() as libc::c_ulong,
            );
            (*pNew).db = db
        }
    }
    return rc;
}
/* Column numbers */
/* Suggested completion of the input */
/* Prefix of the word to be completed */
/* Entire line seen so far */
/* ePhase - used for debugging only */
/*
** This method is the destructor for completion_cursor objects.
*/
unsafe extern "C" fn completionDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Constructor for a new completion_cursor object.
*/
unsafe extern "C" fn completionOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = 0 as *mut completion_cursor;
    pCur = sqlite3_malloc(::std::mem::size_of::<completion_cursor>() as libc::c_ulong as libc::c_int)
        as *mut completion_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    } else {
        memset(
            pCur as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<completion_cursor>() as libc::c_ulong,
        );
        (*pCur).db = (*(p as *mut completion_vtab)).db;
        *ppCursor = &mut (*pCur).base;
        return 0 as libc::c_int;
    };
}
/*
** Reset the completion_cursor.
*/
unsafe extern "C" fn completionCursorReset(mut pCur: *mut completion_cursor) {
    sqlite3_free((*pCur).zPrefix as *mut libc::c_void);
    (*pCur).zPrefix = 0 as *mut libc::c_char;
    (*pCur).nPrefix = 0 as libc::c_int;
    sqlite3_free((*pCur).zLine as *mut libc::c_void);
    (*pCur).zLine = 0 as *mut libc::c_char;
    (*pCur).nLine = 0 as libc::c_int;
    sqlite3_finalize((*pCur).pStmt);
    (*pCur).pStmt = 0 as *mut sqlite3_stmt;
    (*pCur).j = 0 as libc::c_int;
}
/*
** Destructor for a completion_cursor.
*/
unsafe extern "C" fn completionClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    completionCursorReset(cur as *mut completion_cursor);
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Advance a completion_cursor to its next row of output.
**
** The ->ePhase, ->j, and ->pStmt fields of the completion_cursor object
** record the current state of the scan.  This routine sets ->zCurrentRow
** to the current row of output and then returns.  If no more rows remain,
** then ->ePhase is set to COMPLETION_EOF which will signal the virtual
** table that has reached the end of its scan.
**
** The current implementation just lists potential identifiers and
** keywords and filters them by zPrefix.  Future enhancements should
** take zLine into account to try to restrict the set of identifiers and
** keywords based on what would be legal at the current point of input.
*/
unsafe extern "C" fn completionNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor; /* Next phase to try if current phase reaches end */
    let mut eNextPhase: libc::c_int = 0 as libc::c_int; /* If >=0, step pCur->pStmt and use the i-th column */
    let mut iCol: libc::c_int = -(1 as libc::c_int);
    (*pCur).iRowid += 1;
    while (*pCur).ePhase != 11 as libc::c_int {
        match (*pCur).ePhase {
            1 => {
                if (*pCur).j >= sqlite3_keyword_count() {
                    (*pCur).zCurrentRow = 0 as *const libc::c_char;
                    (*pCur).ePhase = 7 as libc::c_int
                } else {
                    let fresh5 = (*pCur).j;
                    (*pCur).j = (*pCur).j + 1;
                    sqlite3_keyword_name(fresh5, &mut (*pCur).zCurrentRow, &mut (*pCur).szRow);
                }
                iCol = -(1 as libc::c_int)
            }
            7 => {
                if (*pCur).pStmt.is_null() {
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\x00" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                }
                iCol = 1 as libc::c_int;
                eNextPhase = 8 as libc::c_int
            }
            8 => {
                if (*pCur).pStmt.is_null() {
                    let mut pS2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep: *const libc::c_char = b"\x00" as *const u8 as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\x00" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2) == 100 as libc::c_int {
                        let mut zDb: *const libc::c_char =
                            sqlite3_column_text(pS2, 1 as libc::c_int) as *const libc::c_char;
                        zSql = sqlite3_mprintf(
                            b"%z%sSELECT name FROM \"%w\".sqlite_schema\x00" as *const u8
                                as *const libc::c_char,
                            zSql,
                            zSep,
                            zDb,
                        );
                        if zSql.is_null() {
                            return 7 as libc::c_int;
                        } else {
                            zSep = b" UNION \x00" as *const u8 as *const libc::c_char
                        }
                    }
                    sqlite3_finalize(pS2);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 9 as libc::c_int
            }
            9 => {
                if (*pCur).pStmt.is_null() {
                    let mut pS2_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut zSep_0: *const libc::c_char =
                        b"\x00" as *const u8 as *const libc::c_char;
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        b"PRAGMA database_list\x00" as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pS2_0,
                        0 as *mut *const libc::c_char,
                    );
                    while sqlite3_step(pS2_0) == 100 as libc::c_int {
                        let mut zDb_0: *const libc::c_char =
                            sqlite3_column_text(pS2_0, 1 as libc::c_int) as *const libc::c_char;
                        zSql_0 =
                            sqlite3_mprintf(b"%z%sSELECT pti.name FROM \"%w\".sqlite_schema AS sm JOIN pragma_table_info(sm.name,%Q) AS pti WHERE sm.type=\'table\'\x00"
                                                as *const u8 as
                                                *const libc::c_char, zSql_0,
                                            zSep_0, zDb_0, zDb_0);
                        if zSql_0.is_null() {
                            return 7 as libc::c_int;
                        } else {
                            zSep_0 = b" UNION \x00" as *const u8 as *const libc::c_char
                        }
                    }
                    sqlite3_finalize(pS2_0);
                    sqlite3_prepare_v2(
                        (*pCur).db,
                        zSql_0,
                        -(1 as libc::c_int),
                        &mut (*pCur).pStmt,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_0 as *mut libc::c_void);
                }
                iCol = 0 as libc::c_int;
                eNextPhase = 11 as libc::c_int
            }
            _ => {}
        }
        if iCol < 0 as libc::c_int {
            /* This case is when the phase presets zCurrentRow */
            if (*pCur).zCurrentRow.is_null() {
                continue;
            }
        } else if sqlite3_step((*pCur).pStmt) == 100 as libc::c_int {
            /* Extract the next row of content */
            (*pCur).zCurrentRow = sqlite3_column_text((*pCur).pStmt, iCol) as *const libc::c_char;
            (*pCur).szRow = sqlite3_column_bytes((*pCur).pStmt, iCol)
        } else {
            /* When all rows are finished, advance to the next phase */
            sqlite3_finalize((*pCur).pStmt);
            (*pCur).pStmt = 0 as *mut sqlite3_stmt;
            (*pCur).ePhase = eNextPhase;
            continue;
        }
        if (*pCur).nPrefix == 0 as libc::c_int {
            break;
        }
        if (*pCur).nPrefix <= (*pCur).szRow
            && sqlite3_strnicmp((*pCur).zPrefix, (*pCur).zCurrentRow, (*pCur).nPrefix)
                == 0 as libc::c_int
        {
            break;
        }
    }
    return 0 as libc::c_int;
}
/*
** Return values of columns for the row at which the completion_cursor
** is currently pointing.
*/
unsafe extern "C" fn completionColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int
/* Which column to return */ {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    match i {
        0 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zCurrentRow,
                (*pCur).szRow,
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        1 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zPrefix,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        2 => {
            sqlite3_result_text(
                ctx,
                (*pCur).zLine,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        3 => {
            sqlite3_result_int(ctx, (*pCur).ePhase);
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
/*
** Return the rowid for the current row.  In this implementation, the
** rowid is the same as the output value.
*/
unsafe extern "C" fn completionRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/
unsafe extern "C" fn completionEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut completion_cursor = cur as *mut completion_cursor;
    return ((*pCur).ePhase >= 11 as libc::c_int) as libc::c_int;
}
/*
** This method is called to "rewind" the completion_cursor object back
** to the first row of output.  This method is always called at least
** once prior to any call to completionColumn() or completionRowid() or
** completionEof().
*/
unsafe extern "C" fn completionFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut _idxStr: *const libc::c_char,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut completion_cursor = pVtabCursor as *mut completion_cursor; /* Unused parameter */
    let mut iArg: libc::c_int = 0 as libc::c_int; /* Unused parameter */
    completionCursorReset(pCur);
    if idxNum & 1 as libc::c_int != 0 {
        (*pCur).nPrefix = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur).zPrefix = sqlite3_mprintf(
                b"%s\x00" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if (*pCur).zPrefix.is_null() {
                return 7 as libc::c_int;
            }
        }
        iArg = 1 as libc::c_int
    }
    if idxNum & 2 as libc::c_int != 0 {
        (*pCur).nLine = sqlite3_value_bytes(*argv.offset(iArg as isize));
        if (*pCur).nLine > 0 as libc::c_int {
            (*pCur).zLine = sqlite3_mprintf(
                b"%s\x00" as *const u8 as *const libc::c_char,
                sqlite3_value_text(*argv.offset(iArg as isize)),
            );
            if (*pCur).zLine.is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    if !(*pCur).zLine.is_null() && (*pCur).zPrefix.is_null() {
        let mut i: libc::c_int = (*pCur).nLine;
        while i > 0 as libc::c_int
            && (*(*__ctype_b_loc()).offset(
                *(*pCur).zLine.offset((i - 1 as libc::c_int) as isize) as libc::c_int as isize
            ) as libc::c_int
                & _ISalnum as libc::c_int as libc::c_ushort as libc::c_int
                != 0
                || *(*pCur).zLine.offset((i - 1 as libc::c_int) as isize) as libc::c_int
                    == '_' as i32)
        {
            i -= 1
        }
        (*pCur).nPrefix = (*pCur).nLine - i;
        if (*pCur).nPrefix > 0 as libc::c_int {
            (*pCur).zPrefix = sqlite3_mprintf(
                b"%.*s\x00" as *const u8 as *const libc::c_char,
                (*pCur).nPrefix,
                (*pCur).zLine.offset(i as isize),
            );
            if (*pCur).zPrefix.is_null() {
                return 7 as libc::c_int;
            }
        }
    }
    (*pCur).iRowid = 0 as libc::c_int as sqlite3_int64;
    (*pCur).ePhase = 1 as libc::c_int;
    return completionNext(pVtabCursor);
}
/*
** SQLite will invoke this method one or more times while planning a query
** that uses the completion virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** There are two hidden parameters that act as arguments to the table-valued
** function:  "prefix" and "wholeline".  Bit 0 of idxNum is set if "prefix"
** is available and bit 1 is set if "wholeline" is available.
*/
unsafe extern "C" fn completionBestIndex(
    mut _tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut current_block: u64; /* Loop over constraints */
    let mut i: libc::c_int = 0; /* The query plan bitmask */
    let mut idxNum: libc::c_int = 0 as libc::c_int; /* Index of the start= constraint, or -1 if none */
    let mut prefixIdx: libc::c_int = -(1 as libc::c_int); /* Index of the stop= constraint, or -1 if none */
    let mut wholelineIdx: libc::c_int = -(1 as libc::c_int); /* Number of arguments that completeFilter() expects */
    let mut nArg: libc::c_int = 0 as libc::c_int; /* Unused parameter */
    let mut pConstraint: *const sqlite3_index_constraint = 0 as *const sqlite3_index_constraint;
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        if !((*pConstraint).usable as libc::c_int == 0 as libc::c_int) {
            if !((*pConstraint).op as libc::c_int != 2 as libc::c_int) {
                match (*pConstraint).iColumn {
                    1 => {
                        current_block = 599305113726267737;
                        match current_block {
                            14872679949619733878 => {
                                wholelineIdx = i;
                                idxNum |= 2 as libc::c_int
                            }
                            _ => {
                                prefixIdx = i;
                                idxNum |= 1 as libc::c_int
                            }
                        }
                    }
                    2 => {
                        current_block = 14872679949619733878;
                        match current_block {
                            14872679949619733878 => {
                                wholelineIdx = i;
                                idxNum |= 2 as libc::c_int
                            }
                            _ => {
                                prefixIdx = i;
                                idxNum |= 1 as libc::c_int
                            }
                        }
                    }
                    _ => {}
                }
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1)
    }
    if prefixIdx >= 0 as libc::c_int {
        nArg += 1;
        (*(*pIdxInfo).aConstraintUsage.offset(prefixIdx as isize)).argvIndex = nArg;
        (*(*pIdxInfo).aConstraintUsage.offset(prefixIdx as isize)).omit =
            1 as libc::c_int as libc::c_uchar
    }
    if wholelineIdx >= 0 as libc::c_int {
        nArg += 1;
        (*(*pIdxInfo).aConstraintUsage.offset(wholelineIdx as isize)).argvIndex = nArg;
        (*(*pIdxInfo).aConstraintUsage.offset(wholelineIdx as isize)).omit =
            1 as libc::c_int as libc::c_uchar
    }
    (*pIdxInfo).idxNum = idxNum;
    (*pIdxInfo).estimatedCost =
        5000 as libc::c_int as libc::c_double - (1000 as libc::c_int * nArg) as libc::c_double;
    (*pIdxInfo).estimatedRows = (500 as libc::c_int - 100 as libc::c_int * nArg) as sqlite3_int64;
    return 0 as libc::c_int;
}
/*
** This following structure defines all the methods for the
** completion virtual table.
*/
static mut completionModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                completionConnect
                    as unsafe extern "C" fn(
                        _: *mut sqlite3,
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: *const *const libc::c_char,
                        _: *mut *mut sqlite3_vtab,
                        _: *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                completionBestIndex
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab,
                        _: *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                completionDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                completionOpen
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab,
                        _: *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                completionClose as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                completionFilter
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: libc::c_int,
                        _: *const libc::c_char,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                completionNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                completionEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                completionColumn
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                completionRowid
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
/* SQLITE_OMIT_VIRTUALTABLE */
pub unsafe extern "C" fn sqlite3CompletionVtabInit(mut db: *mut sqlite3) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int; /* Unused parameter */
    rc = sqlite3_create_module(
        db,
        b"completion\x00" as *const u8 as *const libc::c_char,
        &mut completionModule,
        0 as *mut libc::c_void,
    );
    return rc;
}
pub unsafe extern "C" fn sqlite3_completion_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3CompletionVtabInit(db);
    return rc;
}
static mut apnd_vfs: sqlite3_vfs = unsafe {
    {
        let mut init = sqlite3_vfs {
            iVersion: 3 as libc::c_int,
            szOsFile: 0 as libc::c_int,
            mxPathname: 1024 as libc::c_int,
            pNext: 0 as *const sqlite3_vfs as *mut sqlite3_vfs,
            zName: b"apndvfs\x00" as *const u8 as *const libc::c_char,
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
            xOpen: Some(
                apndOpen
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                        _: *mut sqlite3_file,
                        _: libc::c_int,
                        _: *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xDelete: Some(
                apndDelete
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                        _: libc::c_int,
                    ) -> libc::c_int,
            ),
            xAccess: Some(
                apndAccess
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                        _: libc::c_int,
                        _: *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFullPathname: Some(
                apndFullPathname
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                        _: libc::c_int,
                        _: *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xDlOpen: Some(
                apndDlOpen
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                    ) -> *mut libc::c_void,
            ),
            xDlError: Some(
                apndDlError
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: libc::c_int,
                        _: *mut libc::c_char,
                    ) -> (),
            ),
            xDlSym: Some(
                apndDlSym
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *mut libc::c_void,
                        _: *const libc::c_char,
                    )
                        -> Option<unsafe extern "C" fn() -> ()>,
            ),
            xDlClose: Some(
                apndDlClose
                    as unsafe extern "C" fn(_: *mut sqlite3_vfs, _: *mut libc::c_void) -> (),
            ),
            xRandomness: Some(
                apndRandomness
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: libc::c_int,
                        _: *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xSleep: Some(
                apndSleep
                    as unsafe extern "C" fn(_: *mut sqlite3_vfs, _: libc::c_int) -> libc::c_int,
            ),
            xCurrentTime: Some(
                apndCurrentTime
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *mut libc::c_double,
                    ) -> libc::c_int,
            ),
            xGetLastError: Some(
                apndGetLastError
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: libc::c_int,
                        _: *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xCurrentTimeInt64: Some(
                apndCurrentTimeInt64
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xSetSystemCall: Some(
                apndSetSystemCall
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                        _: sqlite3_syscall_ptr,
                    ) -> libc::c_int,
            ),
            xGetSystemCall: Some(
                apndGetSystemCall
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                    ) -> sqlite3_syscall_ptr,
            ),
            xNextSystemCall: Some(
                apndNextSystemCall
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vfs,
                        _: *const libc::c_char,
                    ) -> *const libc::c_char,
            ),
        };
        init
    }
};
static mut apnd_io_methods: sqlite3_io_methods = unsafe {
    {
        let mut init = sqlite3_io_methods {
            iVersion: 3 as libc::c_int,
            xClose: Some(apndClose as unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int),
            xRead: Some(
                apndRead
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xWrite: Some(
                apndWrite
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: *const libc::c_void,
                        _: libc::c_int,
                        _: sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xTruncate: Some(
                apndTruncate
                    as unsafe extern "C" fn(_: *mut sqlite3_file, _: sqlite3_int64) -> libc::c_int,
            ),
            xSync: Some(
                apndSync
                    as unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int,
            ),
            xFileSize: Some(
                apndFileSize
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: *mut sqlite3_int64,
                    ) -> libc::c_int,
            ),
            xLock: Some(
                apndLock
                    as unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int,
            ),
            xUnlock: Some(
                apndUnlock
                    as unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int,
            ),
            xCheckReservedLock: Some(
                apndCheckReservedLock
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: *mut libc::c_int,
                    ) -> libc::c_int,
            ),
            xFileControl: Some(
                apndFileControl
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: libc::c_int,
                        _: *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xSectorSize: Some(
                apndSectorSize as unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int,
            ),
            xDeviceCharacteristics: Some(
                apndDeviceCharacteristics
                    as unsafe extern "C" fn(_: *mut sqlite3_file) -> libc::c_int,
            ),
            xShmMap: Some(
                apndShmMap
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: libc::c_int,
                        _: libc::c_int,
                        _: libc::c_int,
                        _: *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xShmLock: Some(
                apndShmLock
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: libc::c_int,
                        _: libc::c_int,
                        _: libc::c_int,
                    ) -> libc::c_int,
            ),
            xShmBarrier: Some(apndShmBarrier as unsafe extern "C" fn(_: *mut sqlite3_file) -> ()),
            xShmUnmap: Some(
                apndShmUnmap
                    as unsafe extern "C" fn(_: *mut sqlite3_file, _: libc::c_int) -> libc::c_int,
            ),
            xFetch: Some(
                apndFetch
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: sqlite3_int64,
                        _: libc::c_int,
                        _: *mut *mut libc::c_void,
                    ) -> libc::c_int,
            ),
            xUnfetch: Some(
                apndUnfetch
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_file,
                        _: sqlite3_int64,
                        _: *mut libc::c_void,
                    ) -> libc::c_int,
            ),
        };
        init
    }
};
/* Offset of the append mark.  -1 if unwritten */
/* Always followed by another sqlite3_file that describes the whole file */
/*
** Methods for ApndFile
*/
/*
** Close an apnd-file.
*/
unsafe extern "C" fn apndClose(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xClose
        .expect("non-null function pointer")(pFile);
}
/*
** Read data from an apnd-file.
*/
unsafe extern "C" fn apndRead(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *mut libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xRead
        .expect("non-null function pointer")(pFile, zBuf, iAmt, (*paf).iPgOne + iOfst);
}
/*
** Add the append-mark onto what should become the end of the file.
*  If and only if this succeeds, internal ApndFile.iMark is updated.
*  Parameter iWriteEnd is the appendvfs-relative offset of the new mark.
*/
unsafe extern "C" fn apndWriteMark(
    mut paf: *mut ApndFile,
    mut pFile: *mut sqlite3_file,
    mut iWriteEnd: sqlite_int64,
) -> libc::c_int {
    let mut iPgOne: sqlite_int64 = (*paf).iPgOne;
    let mut a: [libc::c_uchar; 25] = [0; 25];
    let mut i: libc::c_int = 8 as libc::c_int;
    let mut rc: libc::c_int = 0;
    memcpy(
        a.as_mut_ptr() as *mut libc::c_void,
        b"Start-Of-SQLite3-\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
        17 as libc::c_int as libc::c_ulong,
    );
    loop {
        i -= 1;
        if !(i >= 0 as libc::c_int) {
            break;
        }
        a[(17 as libc::c_int + i) as usize] =
            (iPgOne & 0xff as libc::c_int as libc::c_longlong) as libc::c_uchar;
        iPgOne >>= 8 as libc::c_int
    }
    iWriteEnd += (*paf).iPgOne;
    rc = (*(*pFile).pMethods)
        .xWrite
        .expect("non-null function pointer")(
        pFile,
        a.as_mut_ptr() as *const libc::c_void,
        17 as libc::c_int + 8 as libc::c_int,
        iWriteEnd,
    );
    if 0 as libc::c_int == rc {
        (*paf).iMark = iWriteEnd
    }
    return rc;
}
/*
** Write data to an apnd-file.
*/
unsafe extern "C" fn apndWrite(
    mut pFile: *mut sqlite3_file,
    mut zBuf: *const libc::c_void,
    mut iAmt: libc::c_int,
    mut iOfst: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut iWriteEnd: sqlite_int64 = iOfst + iAmt as libc::c_longlong;
    if iWriteEnd >= 0x40000000 as libc::c_int as libc::c_longlong {
        return 13 as libc::c_int;
    } else {
        pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
        /* If append-mark is absent or will be overwritten, write it. */
        if (*paf).iMark < 0 as libc::c_int as libc::c_longlong
            || (*paf).iPgOne + iWriteEnd > (*paf).iMark
        {
            let mut rc: libc::c_int = apndWriteMark(paf, pFile, iWriteEnd);
            if 0 as libc::c_int != rc {
                return rc;
            }
        }
        return (*(*pFile).pMethods)
            .xWrite
            .expect("non-null function pointer")(
            pFile, zBuf, iAmt, (*paf).iPgOne + iOfst
        );
    };
}
/*
** Truncate an apnd-file.
*/
unsafe extern "C" fn apndTruncate(
    mut pFile: *mut sqlite3_file,
    mut size: sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    /* The append mark goes out first so truncate failure does not lose it. */
    if 0 as libc::c_int != apndWriteMark(paf, pFile, size) {
        return 10 as libc::c_int;
    } else {
        /* Truncate underlying file just past append mark */
        return (*(*pFile).pMethods)
            .xTruncate
            .expect("non-null function pointer")(
            pFile,
            (*paf).iMark + (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
        );
    };
}
/*
** Sync an apnd-file.
*/
unsafe extern "C" fn apndSync(mut pFile: *mut sqlite3_file, mut flags: libc::c_int) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xSync
        .expect("non-null function pointer")(pFile, flags);
}
/*
** Return the current file-size of an apnd-file.
** If the append mark is not yet there, the file-size is 0.
*/
unsafe extern "C" fn apndFileSize(
    mut pFile: *mut sqlite3_file,
    mut pSize: *mut sqlite_int64,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    *pSize = if (*paf).iMark >= 0 as libc::c_int as libc::c_longlong {
        ((*paf).iMark) - (*paf).iPgOne
    } else {
        0 as libc::c_int as libc::c_longlong
    };
    return 0 as libc::c_int;
}
/*
** Lock an apnd-file.
*/
unsafe extern "C" fn apndLock(mut pFile: *mut sqlite3_file, mut eLock: libc::c_int) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xLock
        .expect("non-null function pointer")(pFile, eLock);
}
/*
** Unlock an apnd-file.
*/
unsafe extern "C" fn apndUnlock(
    mut pFile: *mut sqlite3_file,
    mut eLock: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xUnlock
        .expect("non-null function pointer")(pFile, eLock);
}
/*
** Check if another file-handle holds a RESERVED lock on an apnd-file.
*/
unsafe extern "C" fn apndCheckReservedLock(
    mut pFile: *mut sqlite3_file,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xCheckReservedLock
        .expect("non-null function pointer")(pFile, pResOut);
}
/*
** File control method. For custom operations on an apnd-file.
*/
unsafe extern "C" fn apndFileControl(
    mut pFile: *mut sqlite3_file,
    mut op: libc::c_int,
    mut pArg: *mut libc::c_void,
) -> libc::c_int {
    let mut paf: *mut ApndFile = pFile as *mut ApndFile;
    let mut rc: libc::c_int = 0;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    if op == 5 as libc::c_int {
        let ref mut fresh6 = *(pArg as *mut sqlite3_int64);
        *fresh6 += (*paf).iPgOne
    }
    rc = (*(*pFile).pMethods)
        .xFileControl
        .expect("non-null function pointer")(pFile, op, pArg);
    if rc == 0 as libc::c_int && op == 12 as libc::c_int {
        let ref mut fresh7 = *(pArg as *mut *mut libc::c_char);
        *fresh7 = sqlite3_mprintf(
            b"apnd(%lld)/%z\x00" as *const u8 as *const libc::c_char,
            (*paf).iPgOne,
            *(pArg as *mut *mut libc::c_char),
        )
    }
    return rc;
}
/*
** Return the sector-size in bytes for an apnd-file.
*/
unsafe extern "C" fn apndSectorSize(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xSectorSize
        .expect("non-null function pointer")(pFile);
}
/*
** Return the device characteristic flags supported by an apnd-file.
*/
unsafe extern "C" fn apndDeviceCharacteristics(mut pFile: *mut sqlite3_file) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xDeviceCharacteristics
        .expect("non-null function pointer")(pFile);
}
/* Create a shared memory file mapping */
unsafe extern "C" fn apndShmMap(
    mut pFile: *mut sqlite3_file,
    mut iPg: libc::c_int,
    mut pgsz: libc::c_int,
    mut bExtend: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xShmMap
        .expect("non-null function pointer")(pFile, iPg, pgsz, bExtend, pp);
}
/* Perform locking on a shared-memory segment */
unsafe extern "C" fn apndShmLock(
    mut pFile: *mut sqlite3_file,
    mut offset: libc::c_int,
    mut n: libc::c_int,
    mut flags: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xShmLock
        .expect("non-null function pointer")(pFile, offset, n, flags);
}
/* Memory barrier operation on shared memory */
unsafe extern "C" fn apndShmBarrier(mut pFile: *mut sqlite3_file) {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    (*(*pFile).pMethods)
        .xShmBarrier
        .expect("non-null function pointer")(pFile);
}
/* Unmap a shared memory segment */
unsafe extern "C" fn apndShmUnmap(
    mut pFile: *mut sqlite3_file,
    mut deleteFlag: libc::c_int,
) -> libc::c_int {
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xShmUnmap
        .expect("non-null function pointer")(pFile, deleteFlag);
}
/* Fetch a page of a memory-mapped file */
unsafe extern "C" fn apndFetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut iAmt: libc::c_int,
    mut pp: *mut *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    if (*p).iMark < 0 as libc::c_int as libc::c_longlong
        || iOfst + iAmt as libc::c_longlong > (*p).iMark
    {
        return 10 as libc::c_int;
        /* Cannot read what is not yet there. */
    } else {
        pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
        return (*(*pFile).pMethods)
            .xFetch
            .expect("non-null function pointer")(
            pFile, iOfst + (*p).iPgOne, iAmt, pp
        );
    };
}
/* Release a memory-mapped page */
unsafe extern "C" fn apndUnfetch(
    mut pFile: *mut sqlite3_file,
    mut iOfst: sqlite3_int64,
    mut pPage: *mut libc::c_void,
) -> libc::c_int {
    let mut p: *mut ApndFile = pFile as *mut ApndFile;
    pFile = (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    return (*(*pFile).pMethods)
        .xUnfetch
        .expect("non-null function pointer")(pFile, iOfst + (*p).iPgOne, pPage);
}
/*
** Try to read the append-mark off the end of a file.  Return the
** start of the appended database if the append-mark is present.
** If there is no valid append-mark, return -1;
**
** An append-mark is only valid if the NNNNNNNN start-of-database offset
** indicates that the appended database contains at least one page.  The
** start-of-database value must be a multiple of 512.
*/
unsafe extern "C" fn apndReadMark(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> sqlite3_int64 {
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iMark: sqlite3_int64 = 0;
    let mut msbs: libc::c_int = 8 as libc::c_int * (8 as libc::c_int - 1 as libc::c_int);
    let mut a: [libc::c_uchar; 25] = [0; 25];
    if (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
        != sz & 0x1ff as libc::c_int as libc::c_longlong
    {
        return -(1 as libc::c_int) as sqlite3_int64;
    } else {
        rc = (*(*pFile).pMethods)
            .xRead
            .expect("non-null function pointer")(
            pFile,
            a.as_mut_ptr() as *mut libc::c_void,
            17 as libc::c_int + 8 as libc::c_int,
            sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong,
        );
        if rc != 0 {
            return -(1 as libc::c_int) as sqlite3_int64;
        } else if memcmp(
            a.as_mut_ptr() as *const libc::c_void,
            b"Start-Of-SQLite3-\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
            17 as libc::c_int as libc::c_ulong,
        ) != 0 as libc::c_int
        {
            return -(1 as libc::c_int) as sqlite3_int64;
        } else {
            iMark = ((a[17 as libc::c_int as usize] as libc::c_int & 0x7f as libc::c_int)
                as sqlite3_int64)
                << msbs;
            i = 1 as libc::c_int;
            while i < 8 as libc::c_int {
                msbs -= 8 as libc::c_int;
                iMark |= (a[(17 as libc::c_int + i) as usize] as sqlite3_int64) << msbs;
                i += 1
            }
            if iMark
                > sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
                    - 512 as libc::c_int as libc::c_longlong
            {
                return -(1 as libc::c_int) as sqlite3_int64;
            } else if iMark & 0x1ff as libc::c_int as libc::c_longlong != 0 {
                return -(1 as libc::c_int) as sqlite3_int64;
            } else {
                return iMark;
            }
        }
    };
}
static mut apvfsSqliteHdr: [libc::c_char; 16] =
    unsafe { *::std::mem::transmute::<&[u8; 16], &[libc::c_char; 16]>(b"SQLite format 3\x00") };
/*
** Check to see if the file is an appendvfs SQLite database file.
** Return true iff it is such. Parameter sz is the file's size.
*/
unsafe extern "C" fn apndIsAppendvfsDatabase(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    let mut iMark: sqlite3_int64 = apndReadMark(sz, pFile);
    if iMark >= 0 as libc::c_int as libc::c_longlong {
        /* If file has the correct end-marker, the expected odd size, and the
         ** SQLite DB type marker where the end-marker puts it, then it
         ** is an appendvfs database.
         */
        rc = (*(*pFile).pMethods)
            .xRead
            .expect("non-null function pointer")(
            pFile,
            zHdr.as_mut_ptr() as *mut libc::c_void,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as libc::c_int,
            iMark,
        );
        if 0 as libc::c_int == rc
            && memcmp(
                zHdr.as_mut_ptr() as *const libc::c_void,
                apvfsSqliteHdr.as_ptr() as *const libc::c_void,
                ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
            ) == 0 as libc::c_int
            && sz & 0x1ff as libc::c_int as libc::c_longlong
                == (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong
            && sz
                >= (512 as libc::c_int + (17 as libc::c_int + 8 as libc::c_int)) as libc::c_longlong
        {
            return 1 as libc::c_int;
            /* It's an appendvfs database */
        }
    }
    return 0 as libc::c_int;
}
/*
** Check to see if the file is an ordinary SQLite database file.
** Return true iff so. Parameter sz is the file's size.
*/
unsafe extern "C" fn apndIsOrdinaryDatabaseFile(
    mut sz: sqlite3_int64,
    mut pFile: *mut sqlite3_file,
) -> libc::c_int {
    let mut zHdr: [libc::c_char; 16] = [0; 16];
    if apndIsAppendvfsDatabase(sz, pFile) != 0
        || sz & 0x1ff as libc::c_int as libc::c_longlong != 0 as libc::c_int as libc::c_longlong
        || 0 as libc::c_int
            != (*(*pFile).pMethods)
                .xRead
                .expect("non-null function pointer")(
                pFile,
                zHdr.as_mut_ptr() as *mut libc::c_void,
                ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong as libc::c_int,
                0 as libc::c_int as sqlite3_int64,
            )
        || memcmp(
            zHdr.as_mut_ptr() as *const libc::c_void,
            apvfsSqliteHdr.as_ptr() as *const libc::c_void,
            ::std::mem::size_of::<[libc::c_char; 16]>() as libc::c_ulong,
        ) != 0 as libc::c_int
    {
        return 0 as libc::c_int;
    } else {
        return 1 as libc::c_int;
    };
}
/*
** Methods for ApndVfs
*/
/*
** Open an apnd file handle.
*/
unsafe extern "C" fn apndOpen(
    mut pApndVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pFile: *mut sqlite3_file,
    mut flags: libc::c_int,
    mut pOutFlags: *mut libc::c_int,
) -> libc::c_int {
    let mut pApndFile: *mut ApndFile = pFile as *mut ApndFile;
    let mut pBaseFile: *mut sqlite3_file =
        (pFile as *mut ApndFile).offset(1 as libc::c_int as isize) as *mut sqlite3_file;
    let mut pBaseVfs: *mut sqlite3_vfs = (*pApndVfs).pAppData as *mut sqlite3_vfs;
    let mut rc: libc::c_int = 0;
    let mut sz: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    if flags & 0x100 as libc::c_int == 0 as libc::c_int {
        /* The appendvfs is not to be used for transient or temporary databases.
         ** Just use the base VFS open to initialize the given file object and
         ** open the underlying file. (Appendvfs is then unused for this file.)
         */
        return (*pBaseVfs).xOpen.expect("non-null function pointer")(
            pBaseVfs, zName, pFile, flags, pOutFlags,
        );
    } else {
        memset(
            pApndFile as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ApndFile>() as libc::c_ulong,
        ); /* Append mark not yet written */
        (*pFile).pMethods = &apnd_io_methods;
        (*pApndFile).iMark = -(1 as libc::c_int) as sqlite3_int64;
        rc = (*pBaseVfs).xOpen.expect("non-null function pointer")(
            pBaseVfs, zName, pBaseFile, flags, pOutFlags,
        );
        if rc == 0 as libc::c_int {
            rc = (*(*pBaseFile).pMethods)
                .xFileSize
                .expect("non-null function pointer")(pBaseFile, &mut sz);
            if rc != 0 {
                (*(*pBaseFile).pMethods)
                    .xClose
                    .expect("non-null function pointer")(pBaseFile);
            }
        }
        if rc != 0 {
            (*pFile).pMethods = 0 as *const sqlite3_io_methods;
            return rc;
        } else if apndIsOrdinaryDatabaseFile(sz, pBaseFile) != 0 {
            /* The file being opened appears to be just an ordinary DB. Copy
             ** the base dispatch-table so this instance mimics the base VFS.
             */
            memmove(
                pApndFile as *mut libc::c_void,
                pBaseFile as *const libc::c_void,
                (*pBaseVfs).szOsFile as libc::c_ulong,
            ); /* Append mark found */
            return 0 as libc::c_int;
        } else {
            (*pApndFile).iPgOne = apndReadMark(sz, pFile);
            if (*pApndFile).iPgOne >= 0 as libc::c_int as libc::c_longlong {
                (*pApndFile).iMark =
                    sz - (17 as libc::c_int + 8 as libc::c_int) as libc::c_longlong;
                return 0 as libc::c_int;
            } else {
                if flags & 0x4 as libc::c_int == 0 as libc::c_int {
                    (*(*pBaseFile).pMethods)
                        .xClose
                        .expect("non-null function pointer")(pBaseFile);
                    rc = 14 as libc::c_int;
                    (*pFile).pMethods = 0 as *const sqlite3_io_methods
                } else {
                    /* Round newly added appendvfs location to #define'd page boundary.
                     ** Note that nothing has yet been written to the underlying file.
                     ** The append mark will be written along with first content write.
                     ** Until then, paf->iMark value indicates it is not yet written.
                     */
                    (*pApndFile).iPgOne = sz
                        + (4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64
                        & !((4096 as libc::c_int - 1 as libc::c_int) as sqlite3_int64)
                }
                return rc;
            }
        }
    };
}
/*
** Delete an apnd file.
** For an appendvfs, this could mean delete the appendvfs portion,
** leaving the appendee as it was before it gained an appendvfs.
** For now, this code deletes the underlying file too.
*/
unsafe extern "C" fn apndDelete(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut dirSync: libc::c_int,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xDelete
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, zPath, dirSync
    );
}
/*
** All other VFS methods are pass-thrus.
*/
unsafe extern "C" fn apndAccess(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut flags: libc::c_int,
    mut pResOut: *mut libc::c_int,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xAccess
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs,
        zPath,
        flags,
        pResOut,
    );
}
unsafe extern "C" fn apndFullPathname(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
    mut nOut: libc::c_int,
    mut zOut: *mut libc::c_char,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xFullPathname
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs,
        zPath,
        nOut,
        zOut,
    );
}
unsafe extern "C" fn apndDlOpen(
    mut pVfs: *mut sqlite3_vfs,
    mut zPath: *const libc::c_char,
) -> *mut libc::c_void {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xDlOpen
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, zPath
    );
}
unsafe extern "C" fn apndDlError(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zErrMsg: *mut libc::c_char,
) {
    (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xDlError
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, nByte, zErrMsg
    );
}
unsafe extern "C" fn apndDlSym(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut libc::c_void,
    mut zSym: *const libc::c_char,
) -> Option<unsafe extern "C" fn() -> ()> {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xDlSym
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, p, zSym
    );
}
unsafe extern "C" fn apndDlClose(mut pVfs: *mut sqlite3_vfs, mut pHandle: *mut libc::c_void) {
    (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xDlClose
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, pHandle);
}
unsafe extern "C" fn apndRandomness(
    mut pVfs: *mut sqlite3_vfs,
    mut nByte: libc::c_int,
    mut zBufOut: *mut libc::c_char,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xRandomness
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, nByte, zBufOut
    );
}
unsafe extern "C" fn apndSleep(mut pVfs: *mut sqlite3_vfs, mut nMicro: libc::c_int) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xSleep
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, nMicro
    );
}
unsafe extern "C" fn apndCurrentTime(
    mut pVfs: *mut sqlite3_vfs,
    mut pTimeOut: *mut libc::c_double,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xCurrentTime
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, pTimeOut
    );
}
unsafe extern "C" fn apndGetLastError(
    mut pVfs: *mut sqlite3_vfs,
    mut a: libc::c_int,
    mut b: *mut libc::c_char,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xGetLastError
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, a, b);
}
unsafe extern "C" fn apndCurrentTimeInt64(
    mut pVfs: *mut sqlite3_vfs,
    mut p: *mut sqlite3_int64,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xCurrentTimeInt64
        .expect("non-null function pointer")((*pVfs).pAppData as *mut sqlite3_vfs, p);
}
unsafe extern "C" fn apndSetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
    mut pCall: sqlite3_syscall_ptr,
) -> libc::c_int {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xSetSystemCall
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, zName, pCall
    );
}
unsafe extern "C" fn apndGetSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> sqlite3_syscall_ptr {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xGetSystemCall
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, zName
    );
}
unsafe extern "C" fn apndNextSystemCall(
    mut pVfs: *mut sqlite3_vfs,
    mut zName: *const libc::c_char,
) -> *const libc::c_char {
    return (*((*pVfs).pAppData as *mut sqlite3_vfs))
        .xNextSystemCall
        .expect("non-null function pointer")(
        (*pVfs).pAppData as *mut sqlite3_vfs, zName
    );
}
/*
** This routine is called when the extension is loaded.
** Register the new VFS.
*/
pub unsafe extern "C" fn sqlite3_appendvfs_init(
    mut _db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pOrig: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
    pOrig = sqlite3_vfs_find(0 as *const libc::c_char);
    if pOrig.is_null() {
        return 1 as libc::c_int;
    } else {
        apnd_vfs.iVersion = (*pOrig).iVersion;
        apnd_vfs.pAppData = pOrig as *mut libc::c_void;
        apnd_vfs.szOsFile = ((*pOrig).szOsFile as libc::c_ulong)
            .wrapping_add(::std::mem::size_of::<ApndFile>() as libc::c_ulong)
            as libc::c_int;
        rc = sqlite3_vfs_register(&mut apnd_vfs, 0 as libc::c_int);
        if rc == 0 as libc::c_int {
            rc = 0 as libc::c_int | (1 as libc::c_int) << 8 as libc::c_int
        }
        return rc;
    };
}
/* ************************ End ../ext/misc/appendvfs.c ********************/
/* ************************ Begin ../ext/misc/memtrace.c ******************/
/*
** 2019-01-21
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
*************************************************************************
**
** This file implements an extension that uses the SQLITE_CONFIG_MALLOC
** mechanism to add a tracing layer on top of SQLite.  If this extension
** is registered prior to sqlite3_initialize(), it will cause all memory
** allocation activities to be logged on standard output, or to some other
** FILE specified by the initializer.
**
** This file needs to be compiled into the application that uses it.
**
** This extension is used to implement the --memtrace option of the
** command-line shell.
*/
/* The original memory allocation routines */
static mut memtraceBase: sqlite3_mem_methods = sqlite3_mem_methods {
    xMalloc: None,
    xFree: None,
    xRealloc: None,
    xSize: None,
    xRoundup: None,
    xInit: None,
    xShutdown: None,
    pAppData: 0 as *const libc::c_void as *mut libc::c_void,
};
static mut memtraceOut: *mut FILE = 0 as *const FILE as *mut FILE;
/* Methods that trace memory allocations */
unsafe extern "C" fn memtraceMalloc(mut n: libc::c_int) -> *mut libc::c_void {
    if !memtraceOut.is_null() {
        fprintf(
            memtraceOut,
            b"MEMTRACE: allocate %d bytes\n\x00" as *const u8 as *const libc::c_char,
            memtraceBase.xRoundup.expect("non-null function pointer")(n),
        );
    }
    return memtraceBase.xMalloc.expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceFree(mut p: *mut libc::c_void) {
    if p.is_null() {
        return;
    } else {
        if !memtraceOut.is_null() {
            fprintf(
                memtraceOut,
                b"MEMTRACE: free %d bytes\n\x00" as *const u8 as *const libc::c_char,
                memtraceBase.xSize.expect("non-null function pointer")(p),
            );
        }
        memtraceBase.xFree.expect("non-null function pointer")(p);
        return;
    };
}
unsafe extern "C" fn memtraceRealloc(
    mut p: *mut libc::c_void,
    mut n: libc::c_int,
) -> *mut libc::c_void {
    if p.is_null() {
        return memtraceMalloc(n);
    } else if n == 0 as libc::c_int {
        memtraceFree(p);
        return 0 as *mut libc::c_void;
    } else {
        if !memtraceOut.is_null() {
            fprintf(
                memtraceOut,
                b"MEMTRACE: resize %d -> %d bytes\n\x00" as *const u8 as *const libc::c_char,
                memtraceBase.xSize.expect("non-null function pointer")(p),
                memtraceBase.xRoundup.expect("non-null function pointer")(n),
            );
        }
        return memtraceBase.xRealloc.expect("non-null function pointer")(p, n);
    };
}
unsafe extern "C" fn memtraceSize(mut p: *mut libc::c_void) -> libc::c_int {
    return memtraceBase.xSize.expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceRoundup(mut n: libc::c_int) -> libc::c_int {
    return memtraceBase.xRoundup.expect("non-null function pointer")(n);
}
unsafe extern "C" fn memtraceInit(mut p: *mut libc::c_void) -> libc::c_int {
    return memtraceBase.xInit.expect("non-null function pointer")(p);
}
unsafe extern "C" fn memtraceShutdown(mut p: *mut libc::c_void) {
    memtraceBase.xShutdown.expect("non-null function pointer")(p);
}
/* The substitute memory allocator */
static mut ersaztMethods: sqlite3_mem_methods = unsafe {
    {
        let mut init = sqlite3_mem_methods {
            xMalloc: Some(
                memtraceMalloc as unsafe extern "C" fn(_: libc::c_int) -> *mut libc::c_void,
            ),
            xFree: Some(memtraceFree as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
            xRealloc: Some(
                memtraceRealloc
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_int,
                    ) -> *mut libc::c_void,
            ),
            xSize: Some(memtraceSize as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int),
            xRoundup: Some(memtraceRoundup as unsafe extern "C" fn(_: libc::c_int) -> libc::c_int),
            xInit: Some(memtraceInit as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int),
            xShutdown: Some(memtraceShutdown as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
            pAppData: 0 as *const libc::c_void as *mut libc::c_void,
        };
        init
    }
};
/* Begin tracing memory allocations to out. */
pub unsafe extern "C" fn sqlite3MemTraceActivate(mut out: *mut FILE) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if memtraceBase.xMalloc.is_none() {
        rc = sqlite3_config(
            5 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            rc = sqlite3_config(
                4 as libc::c_int,
                &mut ersaztMethods as *mut sqlite3_mem_methods,
            )
        }
    }
    memtraceOut = out;
    return rc;
}
/* Deactivate memory tracing */
pub unsafe extern "C" fn sqlite3MemTraceDeactivate() -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if memtraceBase.xMalloc.is_some() {
        rc = sqlite3_config(
            4 as libc::c_int,
            &mut memtraceBase as *mut sqlite3_mem_methods,
        );
        if rc == 0 as libc::c_int {
            memset(
                &mut memtraceBase as *mut sqlite3_mem_methods as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<sqlite3_mem_methods>() as libc::c_ulong,
            );
        }
    }
    memtraceOut = 0 as *mut FILE;
    return rc;
}
/* ************************ End ../ext/misc/memtrace.c ********************/
/* ************************ Begin ../ext/misc/uint.c ******************/
/*
** 2020-04-14
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements the UINT collating sequence.
**
** UINT works like BINARY for text, except that embedded strings
** of digits compare in numeric order.
**
**     *   Leading zeros are handled properly, in the sense that
**         they do not mess of the maginitude comparison of embedded
**         strings of digits.  "x00123y" is equal to "x123y".
**
**     *   Only unsigned integers are recognized.  Plus and minus
**         signs are ignored.  Decimal points and exponential notation
**         are ignored.
**
**     *   Embedded integers can be of arbitrary length.  Comparison
**         is *not* limited integers that can be expressed as a
**         64-bit machine integer.
*/
/* #include "sqlite3ext.h" */
/*
** Compare text in lexicographic order, except strings of digits
** compare in numeric order.
*/
unsafe extern "C" fn uintCollFunc(
    mut _notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar; /* Unused parameter */
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut x: libc::c_int = 0;
    while i < nKey1 && j < nKey2 {
        x = *zA.offset(i as isize) as libc::c_int - *zB.offset(j as isize) as libc::c_int;
        if *(*__ctype_b_loc()).offset(*zA.offset(i as isize) as libc::c_int as isize) as libc::c_int
            & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            let mut k: libc::c_int = 0;
            if *(*__ctype_b_loc()).offset(*zB.offset(j as isize) as libc::c_int as isize)
                as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return x;
            } else {
                while i < nKey1 && *zA.offset(i as isize) as libc::c_int == '0' as i32 {
                    i += 1
                }
                while j < nKey2 && *zB.offset(j as isize) as libc::c_int == '0' as i32 {
                    j += 1
                }
                k = 0 as libc::c_int;
                while i + k < nKey1
                    && *(*__ctype_b_loc())
                        .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                    && j + k < nKey2
                    && *(*__ctype_b_loc())
                        .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                {
                    k += 1
                }
                if i + k < nKey1
                    && *(*__ctype_b_loc())
                        .offset(*zA.offset((i + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                {
                    return 1 as libc::c_int;
                } else if j + k < nKey2
                    && *(*__ctype_b_loc())
                        .offset(*zB.offset((j + k) as isize) as libc::c_int as isize)
                        as libc::c_int
                        & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                {
                    return -(1 as libc::c_int);
                } else {
                    x = memcmp(
                        zA.offset(i as isize) as *const libc::c_void,
                        zB.offset(j as isize) as *const libc::c_void,
                        k as libc::c_ulong,
                    );
                    if x != 0 {
                        return x;
                    } else {
                        i += k;
                        j += k
                    }
                }
            }
        } else if x != 0 {
            return x;
        } else {
            i += 1;
            j += 1
        }
    }
    return nKey1 - i - (nKey2 - j);
}
pub unsafe extern "C" fn sqlite3_uint_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3_create_collation(
        db,
        b"uint\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            uintCollFunc
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: libc::c_int,
                    _: *const libc::c_void,
                    _: libc::c_int,
                    _: *const libc::c_void,
                ) -> libc::c_int,
        ),
    );
}
/* Array of digits.  Most significant first. */
/*
** Release memory held by a Decimal, but do not free the object itself.
*/
unsafe extern "C" fn decimal_clear(mut p: *mut Decimal) {
    sqlite3_free((*p).a as *mut libc::c_void);
}
/*
** Destroy a Decimal object
*/
unsafe extern "C" fn decimal_free(mut p: *mut Decimal) {
    if !p.is_null() {
        decimal_clear(p);
        sqlite3_free(p as *mut libc::c_void);
    };
}
/*
** Allocate a new Decimal object.  Initialize it to the number given
** by the input string.
*/
unsafe extern "C" fn decimal_new(
    mut pCtx: *mut sqlite3_context,
    mut pIn: *mut sqlite3_value,
    mut nAlt: libc::c_int,
    mut zAlt: *const libc::c_uchar,
) -> *mut Decimal {
    let mut current_block: u64;
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut n: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut zIn: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut iExp: libc::c_int = 0 as libc::c_int;
    p = sqlite3_malloc(::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int)
        as *mut Decimal;
    if !p.is_null() {
        (*p).sign = 0 as libc::c_int as libc::c_char;
        (*p).oom = 0 as libc::c_int as libc::c_char;
        (*p).isInit = 1 as libc::c_int as libc::c_char;
        (*p).isNull = 0 as libc::c_int as libc::c_char;
        (*p).nDigit = 0 as libc::c_int;
        (*p).nFrac = 0 as libc::c_int;
        if !zAlt.is_null() {
            n = nAlt;
            zIn = zAlt
        } else if sqlite3_value_type(pIn) == 5 as libc::c_int {
            (*p).a = 0 as *mut libc::c_schar;
            (*p).isNull = 1 as libc::c_int as libc::c_char;
            return p;
        } else {
            n = sqlite3_value_bytes(pIn);
            zIn = sqlite3_value_text(pIn)
        }
        (*p).a = sqlite3_malloc64((n + 1 as libc::c_int) as sqlite3_uint64) as *mut libc::c_schar;
        if !(*p).a.is_null() {
            i = 0 as libc::c_int;
            while *(*__ctype_b_loc()).offset(*zIn.offset(i as isize) as libc::c_int as isize)
                as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                != 0
            {
                i += 1
            }
            if *zIn.offset(i as isize) as libc::c_int == '-' as i32 {
                (*p).sign = 1 as libc::c_int as libc::c_char;
                i += 1
            } else if *zIn.offset(i as isize) as libc::c_int == '+' as i32 {
                i += 1
            }
            while i < n && *zIn.offset(i as isize) as libc::c_int == '0' as i32 {
                i += 1
            }
            while i < n {
                let mut c: libc::c_char = *zIn.offset(i as isize) as libc::c_char;
                if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '9' as i32 {
                    let fresh8 = (*p).nDigit;
                    (*p).nDigit = (*p).nDigit + 1;
                    *(*p).a.offset(fresh8 as isize) =
                        (c as libc::c_int - '0' as i32) as libc::c_schar
                } else if c as libc::c_int == '.' as i32 {
                    (*p).nFrac = (*p).nDigit + 1 as libc::c_int
                } else if c as libc::c_int == 'e' as i32 || c as libc::c_int == 'E' as i32 {
                    let mut j: libc::c_int = i + 1 as libc::c_int;
                    let mut neg: libc::c_int = 0 as libc::c_int;
                    if j >= n {
                        break;
                    }
                    if *zIn.offset(j as isize) as libc::c_int == '-' as i32 {
                        neg = 1 as libc::c_int;
                        j += 1
                    } else if *zIn.offset(j as isize) as libc::c_int == '+' as i32 {
                        j += 1
                    }
                    while j < n && iExp < 1000000 as libc::c_int {
                        if *zIn.offset(j as isize) as libc::c_int >= '0' as i32
                            && *zIn.offset(j as isize) as libc::c_int <= '9' as i32
                        {
                            iExp = iExp * 10 as libc::c_int + *zIn.offset(j as isize) as libc::c_int
                                - '0' as i32
                        }
                        j += 1
                    }
                    if !(neg != 0) {
                        break;
                    }
                    iExp = -iExp;
                    break;
                }
                i += 1
            }
            if (*p).nFrac != 0 {
                (*p).nFrac = (*p).nDigit - ((*p).nFrac - 1 as libc::c_int)
            }
            if iExp > 0 as libc::c_int {
                if (*p).nFrac > 0 as libc::c_int {
                    if iExp <= (*p).nFrac {
                        (*p).nFrac -= iExp;
                        iExp = 0 as libc::c_int
                    } else {
                        iExp -= (*p).nFrac;
                        (*p).nFrac = 0 as libc::c_int
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p).a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if (*p).a.is_null() {
                        current_block = 7182204040450740154;
                    } else {
                        memset(
                            (*p).a.offset((*p).nDigit as isize) as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        current_block = 10778260831612459202;
                    }
                } else {
                    current_block = 10778260831612459202;
                }
            } else if iExp < 0 as libc::c_int {
                let mut nExtra: libc::c_int = 0;
                iExp = -iExp;
                nExtra = (*p).nDigit - (*p).nFrac - 1 as libc::c_int;
                if nExtra != 0 {
                    if nExtra >= iExp {
                        (*p).nFrac += iExp;
                        iExp = 0 as libc::c_int
                    } else {
                        iExp -= nExtra;
                        (*p).nFrac = (*p).nDigit - 1 as libc::c_int
                    }
                }
                if iExp > 0 as libc::c_int {
                    (*p).a = sqlite3_realloc64(
                        (*p).a as *mut libc::c_void,
                        ((*p).nDigit + iExp + 1 as libc::c_int) as sqlite3_uint64,
                    ) as *mut libc::c_schar;
                    if (*p).a.is_null() {
                        current_block = 7182204040450740154;
                    } else {
                        memmove(
                            (*p).a.offset(iExp as isize) as *mut libc::c_void,
                            (*p).a as *const libc::c_void,
                            (*p).nDigit as libc::c_ulong,
                        );
                        memset(
                            (*p).a as *mut libc::c_void,
                            0 as libc::c_int,
                            iExp as libc::c_ulong,
                        );
                        (*p).nDigit += iExp;
                        (*p).nFrac += iExp;
                        current_block = 10778260831612459202;
                    }
                } else {
                    current_block = 10778260831612459202;
                }
            } else {
                current_block = 10778260831612459202;
            }
            match current_block {
                7182204040450740154 => {}
                _ => return p,
            }
        }
    }
    if !pCtx.is_null() {
        sqlite3_result_error_nomem(pCtx);
    }
    sqlite3_free(p as *mut libc::c_void);
    return 0 as *mut Decimal;
}
/*
** Make the given Decimal the result.
*/
unsafe extern "C" fn decimal_result(mut pCtx: *mut sqlite3_context, mut p: *mut Decimal) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if p.is_null() || (*p).oom as libc::c_int != 0 {
        sqlite3_result_error_nomem(pCtx);
        return;
    } else if (*p).isNull != 0 {
        sqlite3_result_null(pCtx);
        return;
    } else {
        z = sqlite3_malloc((*p).nDigit + 4 as libc::c_int) as *mut libc::c_char;
        if z.is_null() {
            sqlite3_result_error_nomem(pCtx);
            return;
        } else {
            i = 0 as libc::c_int;
            if (*p).nDigit == 0 as libc::c_int
                || (*p).nDigit == 1 as libc::c_int
                    && *(*p).a.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            {
                (*p).sign = 0 as libc::c_int as libc::c_char
            }
            if (*p).sign != 0 {
                *z.offset(0 as libc::c_int as isize) = '-' as i32 as libc::c_char;
                i = 1 as libc::c_int
            }
            n = (*p).nDigit - (*p).nFrac;
            if n <= 0 as libc::c_int {
                let fresh9 = i;
                i = i + 1;
                *z.offset(fresh9 as isize) = '0' as i32 as libc::c_char
            }
            j = 0 as libc::c_int;
            while n > 1 as libc::c_int
                && *(*p).a.offset(j as isize) as libc::c_int == 0 as libc::c_int
            {
                j += 1;
                n -= 1
            }
            while n > 0 as libc::c_int {
                let fresh10 = i;
                i = i + 1;
                *z.offset(fresh10 as isize) =
                    (*(*p).a.offset(j as isize) as libc::c_int + '0' as i32) as libc::c_char;
                j += 1;
                n -= 1
            }
            if (*p).nFrac != 0 {
                let fresh11 = i;
                i = i + 1;
                *z.offset(fresh11 as isize) = '.' as i32 as libc::c_char;
                loop {
                    let fresh12 = i;
                    i = i + 1;
                    *z.offset(fresh12 as isize) =
                        (*(*p).a.offset(j as isize) as libc::c_int + '0' as i32) as libc::c_char;
                    j += 1;
                    if !(j < (*p).nDigit) {
                        break;
                    }
                }
            }
            *z.offset(i as isize) = 0 as libc::c_int as libc::c_char;
            sqlite3_result_text(
                pCtx,
                z,
                i,
                Some(sqlite3_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
            );
            return;
        }
    };
}
/*
** SQL Function:   decimal(X)
**
** Convert input X into decimal and then back into text
*/
unsafe extern "C" fn decimalFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_result(context, p);
    decimal_free(p);
}
/*
** Compare to Decimal objects.  Return negative, 0, or positive if the
** first object is less than, equal to, or greater than the second.
**
** Preconditions for this routine:
**
**    pA!=0
**    pA->isNull==0
**    pB!=0
**    pB->isNull==0
*/
unsafe extern "C" fn decimal_cmp(mut pA: *const Decimal, mut pB: *const Decimal) -> libc::c_int {
    let mut nASig: libc::c_int = 0;
    let mut nBSig: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    if (*pA).sign as libc::c_int != (*pB).sign as libc::c_int {
        return if (*pA).sign as libc::c_int != 0 {
            -(1 as libc::c_int)
        } else {
            1 as libc::c_int
        };
    } else {
        if (*pA).sign != 0 {
            let mut pTemp: *const Decimal = pA;
            pA = pB;
            pB = pTemp
        }
        nASig = (*pA).nDigit - (*pA).nFrac;
        nBSig = (*pB).nDigit - (*pB).nFrac;
        if nASig != nBSig {
            return nASig - nBSig;
        } else {
            n = (*pA).nDigit;
            if n > (*pB).nDigit {
                n = (*pB).nDigit
            }
            rc = memcmp(
                (*pA).a as *const libc::c_void,
                (*pB).a as *const libc::c_void,
                n as libc::c_ulong,
            );
            if rc == 0 as libc::c_int {
                rc = (*pA).nDigit - (*pB).nDigit
            }
            return rc;
        }
    };
}
/*
** SQL Function:   decimal_cmp(X, Y)
**
** Return negative, zero, or positive if X is less then, equal to, or
** greater than Y.
*/
unsafe extern "C" fn decimalCmpFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = 0 as *mut Decimal;
    let mut pB: *mut Decimal = 0 as *mut Decimal;
    let mut rc: libc::c_int = 0;
    pA = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !(pA.is_null() || (*pA).isNull as libc::c_int != 0) {
        pB = decimal_new(
            context,
            *argv.offset(1 as libc::c_int as isize),
            0 as libc::c_int,
            0 as *const libc::c_uchar,
        );
        if !(pB.is_null() || (*pB).isNull as libc::c_int != 0) {
            rc = decimal_cmp(pA, pB);
            if rc < 0 as libc::c_int {
                rc = -(1 as libc::c_int)
            } else if rc > 0 as libc::c_int {
                rc = 1 as libc::c_int
            }
            sqlite3_result_int(context, rc);
        }
    }
    decimal_free(pA);
    decimal_free(pB);
}
/*
** Expand the Decimal so that it has a least nDigit digits and nFrac
** digits to the right of the decimal point.
*/
unsafe extern "C" fn decimal_expand(
    mut p: *mut Decimal,
    mut nDigit: libc::c_int,
    mut nFrac: libc::c_int,
) {
    let mut nAddSig: libc::c_int = 0;
    let mut nAddFrac: libc::c_int = 0;
    if p.is_null() {
        return;
    } else {
        nAddFrac = nFrac - (*p).nFrac;
        nAddSig = nDigit - (*p).nDigit - nAddFrac;
        if nAddFrac == 0 as libc::c_int && nAddSig == 0 as libc::c_int {
            return;
        } else {
            (*p).a = sqlite3_realloc64(
                (*p).a as *mut libc::c_void,
                (nDigit + 1 as libc::c_int) as sqlite3_uint64,
            ) as *mut libc::c_schar;
            if (*p).a.is_null() {
                (*p).oom = 1 as libc::c_int as libc::c_char;
                return;
            } else {
                if nAddSig != 0 {
                    memmove(
                        (*p).a.offset(nAddSig as isize) as *mut libc::c_void,
                        (*p).a as *const libc::c_void,
                        (*p).nDigit as libc::c_ulong,
                    );
                    memset(
                        (*p).a as *mut libc::c_void,
                        0 as libc::c_int,
                        nAddSig as libc::c_ulong,
                    );
                    (*p).nDigit += nAddSig
                }
                if nAddFrac != 0 {
                    memset(
                        (*p).a.offset((*p).nDigit as isize) as *mut libc::c_void,
                        0 as libc::c_int,
                        nAddFrac as libc::c_ulong,
                    );
                    (*p).nDigit += nAddFrac;
                    (*p).nFrac += nAddFrac
                }
                return;
            }
        }
    };
}
/*
** Add the value pB into pA.
**
** Both pA and pB might become denormalized by this routine.
*/
unsafe extern "C" fn decimal_add(mut pA: *mut Decimal, mut pB: *mut Decimal) {
    let mut nSig: libc::c_int = 0;
    let mut nFrac: libc::c_int = 0;
    let mut nDigit: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    if pA.is_null() {
        return;
    } else if (*pA).oom as libc::c_int != 0 || pB.is_null() || (*pB).oom as libc::c_int != 0 {
        (*pA).oom = 1 as libc::c_int as libc::c_char;
        return;
    } else if (*pA).isNull as libc::c_int != 0 || (*pB).isNull as libc::c_int != 0 {
        (*pA).isNull = 1 as libc::c_int as libc::c_char;
        return;
    } else {
        nSig = (*pA).nDigit - (*pA).nFrac;
        if nSig != 0
            && *(*pA).a.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
        {
            nSig -= 1
        }
        if nSig < (*pB).nDigit - (*pB).nFrac {
            nSig = (*pB).nDigit - (*pB).nFrac
        }
        nFrac = (*pA).nFrac;
        if nFrac < (*pB).nFrac {
            nFrac = (*pB).nFrac
        }
        nDigit = nSig + nFrac + 1 as libc::c_int;
        decimal_expand(pA, nDigit, nFrac);
        decimal_expand(pB, nDigit, nFrac);
        if (*pA).oom as libc::c_int != 0 || (*pB).oom as libc::c_int != 0 {
            (*pA).oom = 1 as libc::c_int as libc::c_char
        } else if (*pA).sign as libc::c_int == (*pB).sign as libc::c_int {
            let mut carry: libc::c_int = 0 as libc::c_int;
            i = nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut x: libc::c_int = *(*pA).a.offset(i as isize) as libc::c_int
                    + *(*pB).a.offset(i as isize) as libc::c_int
                    + carry;
                if x >= 10 as libc::c_int {
                    carry = 1 as libc::c_int;
                    *(*pA).a.offset(i as isize) = (x - 10 as libc::c_int) as libc::c_schar
                } else {
                    carry = 0 as libc::c_int;
                    *(*pA).a.offset(i as isize) = x as libc::c_schar
                }
                i -= 1
            }
        } else {
            let mut aA: *mut libc::c_schar = 0 as *mut libc::c_schar;
            let mut aB: *mut libc::c_schar = 0 as *mut libc::c_schar;
            let mut borrow: libc::c_int = 0 as libc::c_int;
            rc = memcmp(
                (*pA).a as *const libc::c_void,
                (*pB).a as *const libc::c_void,
                nDigit as libc::c_ulong,
            );
            if rc < 0 as libc::c_int {
                aA = (*pB).a;
                aB = (*pA).a;
                (*pA).sign = ((*pA).sign == 0) as libc::c_int as libc::c_char
            } else {
                aA = (*pA).a;
                aB = (*pB).a
            }
            i = nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut x_0: libc::c_int = *aA.offset(i as isize) as libc::c_int
                    - *aB.offset(i as isize) as libc::c_int
                    - borrow;
                if x_0 < 0 as libc::c_int {
                    *(*pA).a.offset(i as isize) = (x_0 + 10 as libc::c_int) as libc::c_schar;
                    borrow = 1 as libc::c_int
                } else {
                    *(*pA).a.offset(i as isize) = x_0 as libc::c_schar;
                    borrow = 0 as libc::c_int
                }
                i -= 1
            }
        }
        return;
    };
}
/*
** Compare text in decimal order.
*/
unsafe extern "C" fn decimalCollFunc(
    mut _notUsed: *mut libc::c_void,
    mut nKey1: libc::c_int,
    mut pKey1: *const libc::c_void,
    mut nKey2: libc::c_int,
    mut pKey2: *const libc::c_void,
) -> libc::c_int {
    let mut zA: *const libc::c_uchar = pKey1 as *const libc::c_uchar;
    let mut zB: *const libc::c_uchar = pKey2 as *const libc::c_uchar;
    let mut pA: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey1,
        zA,
    );
    let mut pB: *mut Decimal = decimal_new(
        0 as *mut sqlite3_context,
        0 as *mut sqlite3_value,
        nKey2,
        zB,
    );
    let mut rc: libc::c_int = 0;
    if pA.is_null() || pB.is_null() {
        rc = 0 as libc::c_int
    } else {
        rc = decimal_cmp(pA, pB)
    }
    decimal_free(pA);
    decimal_free(pB);
    return rc;
}
/*
** SQL Function:   decimal_add(X, Y)
**                 decimal_sub(X, Y)
**
** Return the sum or difference of X and Y.
*/
unsafe extern "C" fn decimalAddFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    decimal_add(pA, pB);
    decimal_result(context, pA);
    decimal_free(pA);
    decimal_free(pB);
}
unsafe extern "C" fn decimalSubFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    if !pB.is_null() {
        (*pB).sign = ((*pB).sign == 0) as libc::c_int as libc::c_char;
        decimal_add(pA, pB);
        decimal_result(context, pA);
    }
    decimal_free(pA);
    decimal_free(pB);
}
/* Aggregate funcion:   decimal_sum(X)
**
** Works like sum() except that it uses decimal arithmetic for unlimited
** precision.
*/
unsafe extern "C" fn decimalSumStep(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    } else {
        if (*p).isInit == 0 {
            (*p).isInit = 1 as libc::c_int as libc::c_char;
            (*p).a = sqlite3_malloc(2 as libc::c_int) as *mut libc::c_schar;
            if (*p).a.is_null() {
                (*p).oom = 1 as libc::c_int as libc::c_char
            } else {
                *(*p).a.offset(0 as libc::c_int as isize) = 0 as libc::c_int as libc::c_schar
            }
            (*p).nDigit = 1 as libc::c_int;
            (*p).nFrac = 0 as libc::c_int
        }
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
            return;
        } else {
            pArg = decimal_new(
                context,
                *argv.offset(0 as libc::c_int as isize),
                0 as libc::c_int,
                0 as *const libc::c_uchar,
            );
            decimal_add(p, pArg);
            decimal_free(pArg);
            return;
        }
    };
}
unsafe extern "C" fn decimalSumInverse(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut Decimal = 0 as *mut Decimal;
    let mut pArg: *mut Decimal = 0 as *mut Decimal;
    p = sqlite3_aggregate_context(
        context,
        ::std::mem::size_of::<Decimal>() as libc::c_ulong as libc::c_int,
    ) as *mut Decimal;
    if p.is_null() {
        return;
    } else if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        return;
    } else {
        pArg = decimal_new(
            context,
            *argv.offset(0 as libc::c_int as isize),
            0 as libc::c_int,
            0 as *const libc::c_uchar,
        );
        if !pArg.is_null() {
            (*pArg).sign = ((*pArg).sign == 0) as libc::c_int as libc::c_char
        }
        decimal_add(p, pArg);
        decimal_free(pArg);
        return;
    };
}
unsafe extern "C" fn decimalSumValue(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int) as *mut Decimal;
    if p.is_null() {
        return;
    } else {
        decimal_result(context, p);
        return;
    };
}
unsafe extern "C" fn decimalSumFinalize(mut context: *mut sqlite3_context) {
    let mut p: *mut Decimal = sqlite3_aggregate_context(context, 0 as libc::c_int) as *mut Decimal;
    if p.is_null() {
        return;
    } else {
        decimal_result(context, p);
        decimal_clear(p);
        return;
    };
}
/*
** SQL Function:   decimal_mul(X, Y)
**
** Return the product of X and Y.
**
** All significant digits after the decimal point are retained.
** Trailing zeros after the decimal point are omitted as long as
** the number of digits after the decimal point is no less than
** either the number of digits in either input.
*/
unsafe extern "C" fn decimalMulFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pA: *mut Decimal = decimal_new(
        context,
        *argv.offset(0 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    ); /* Unused parameter */
    let mut pB: *mut Decimal = decimal_new(
        context,
        *argv.offset(1 as libc::c_int as isize),
        0 as libc::c_int,
        0 as *const libc::c_uchar,
    );
    let mut acc: *mut libc::c_schar = 0 as *mut libc::c_schar;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut minFrac: libc::c_int = 0;
    if !(pA.is_null()
        || (*pA).oom as libc::c_int != 0
        || (*pA).isNull as libc::c_int != 0
        || pB.is_null()
        || (*pB).oom as libc::c_int != 0
        || (*pB).isNull as libc::c_int != 0)
    {
        acc = sqlite3_malloc64(((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as sqlite3_uint64)
            as *mut libc::c_schar;
        if acc.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            memset(
                acc as *mut libc::c_void,
                0 as libc::c_int,
                ((*pA).nDigit + (*pB).nDigit + 2 as libc::c_int) as libc::c_ulong,
            );
            minFrac = (*pA).nFrac;
            if (*pB).nFrac < minFrac {
                minFrac = (*pB).nFrac
            }
            i = (*pA).nDigit - 1 as libc::c_int;
            while i >= 0 as libc::c_int {
                let mut f: libc::c_schar = *(*pA).a.offset(i as isize);
                let mut carry: libc::c_int = 0 as libc::c_int;
                let mut x: libc::c_int = 0;
                j = (*pB).nDigit - 1 as libc::c_int;
                k = i + j + 3 as libc::c_int;
                while j >= 0 as libc::c_int {
                    x = *acc.offset(k as isize) as libc::c_int
                        + f as libc::c_int * *(*pB).a.offset(j as isize) as libc::c_int
                        + carry;
                    *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                    carry = x / 10 as libc::c_int;
                    j -= 1;
                    k -= 1
                }
                x = *acc.offset(k as isize) as libc::c_int + carry;
                *acc.offset(k as isize) = (x % 10 as libc::c_int) as libc::c_schar;
                let ref mut fresh13 = *acc.offset((k - 1 as libc::c_int) as isize);
                *fresh13 = (*fresh13 as libc::c_int + x / 10 as libc::c_int) as libc::c_schar;
                i -= 1
            }
            sqlite3_free((*pA).a as *mut libc::c_void);
            (*pA).a = acc;
            acc = 0 as *mut libc::c_schar;
            (*pA).nDigit += (*pB).nDigit + 2 as libc::c_int;
            (*pA).nFrac += (*pB).nFrac;
            (*pA).sign = ((*pA).sign as libc::c_int ^ (*pB).sign as libc::c_int) as libc::c_char;
            while (*pA).nFrac > minFrac
                && *(*pA).a.offset(((*pA).nDigit - 1 as libc::c_int) as isize) as libc::c_int
                    == 0 as libc::c_int
            {
                (*pA).nFrac -= 1;
                (*pA).nDigit -= 1
            }
            decimal_result(context, pA);
        }
    }
    sqlite3_free(acc as *mut libc::c_void);
    decimal_free(pA);
    decimal_free(pB);
}
pub unsafe extern "C" fn sqlite3_decimal_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    static mut aFunc: [C2RustUnnamed_16; 5] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal\x00" as *const u8 as *const libc::c_char,
                    nArg: 1 as libc::c_int,
                    xFunc: Some(
                        decimalFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_cmp\x00" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalCmpFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_add\x00" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalAddFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_sub\x00" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalSubFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_16 {
                    zFuncName: b"decimal_mul\x00" as *const u8 as *const libc::c_char,
                    nArg: 2 as libc::c_int,
                    xFunc: Some(
                        decimalMulFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[C2RustUnnamed_16; 5]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_16>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFuncName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1)
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_window_function(
            db,
            b"decimal_sum\x00" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int | 0x800 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalSumStep
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(decimalSumFinalize as unsafe extern "C" fn(_: *mut sqlite3_context) -> ()),
            Some(decimalSumValue as unsafe extern "C" fn(_: *mut sqlite3_context) -> ()),
            Some(
                decimalSumInverse
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_collation(
            db,
            b"decimal\x00" as *const u8 as *const libc::c_char,
            1 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                decimalCollFunc
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: *const libc::c_void,
                        _: libc::c_int,
                        _: *const libc::c_void,
                    ) -> libc::c_int,
            ),
        )
    }
    return rc;
}
/* ************************ End ../ext/misc/decimal.c ********************/
/* ************************ Begin ../ext/misc/ieee754.c ******************/
/*
** 2013-04-17
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** This SQLite extension implements functions for the exact display
** and input of IEEE754 Binary64 floating-point numbers.
**
**   ieee754(X)
**   ieee754(Y,Z)
**
** In the first form, the value X should be a floating-point number.
** The function will return a string of the form 'ieee754(Y,Z)' where
** Y and Z are integers such that X==Y*pow(2,Z).
**
** In the second form, Y and Z are integers which are the mantissa and
** base-2 exponent of a new floating point number.  The function returns
** a floating-point value equal to Y*pow(2,Z).
**
** Examples:
**
**     ieee754(2.0)             ->     'ieee754(2,0)'
**     ieee754(45.25)           ->     'ieee754(181,-2)'
**     ieee754(2, 0)            ->     2.0
**     ieee754(181, -2)         ->     45.25
**
** Two additional functions break apart the one-argument ieee754()
** result into separate integer values:
**
**     ieee754_mantissa(45.25)  ->     181
**     ieee754_exponent(45.25)  ->     -2
**
** These functions convert binary64 numbers into blobs and back again.
**
**     ieee754_from_blob(x'3ff0000000000000')  ->  1.0
**     ieee754_to_blob(1.0)                    ->  x'3ff0000000000000'
**
** In all single-argument functions, if the argument is an 8-byte blob
** then that blob is interpreted as a big-endian binary64 value.
**
**
** EXACT DECIMAL REPRESENTATION OF BINARY64 VALUES
** -----------------------------------------------
**
** This extension in combination with the separate 'decimal' extension
** can be used to compute the exact decimal representation of binary64
** values.  To begin, first compute a table of exponent values:
**
**    CREATE TABLE pow2(x INTEGER PRIMARY KEY, v TEXT);
**    WITH RECURSIVE c(x,v) AS (
**      VALUES(0,'1')
**      UNION ALL
**      SELECT x+1, decimal_mul(v,'2') FROM c WHERE x+1<=971
**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
**    WITH RECURSIVE c(x,v) AS (
**      VALUES(-1,'0.5')
**      UNION ALL
**      SELECT x-1, decimal_mul(v,'0.5') FROM c WHERE x-1>=-1075
**    ) INSERT INTO pow2(x,v) SELECT x, v FROM c;
**
** Then, to compute the exact decimal representation of a floating
** point value (the value 47.49 is used in the example) do:
**
**    WITH c(n) AS (VALUES(47.49))
**          ---------------^^^^^---- Replace with whatever you want
**    SELECT decimal_mul(ieee754_mantissa(c.n),pow2.v)
**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.n);
**
** Here is a query to show various boundry values for the binary64
** number format:
**
**    WITH c(name,bin) AS (VALUES
**       ('minimum positive value',        x'0000000000000001'),
**       ('maximum subnormal value',       x'000fffffffffffff'),
**       ('mininum positive nornal value', x'0010000000000000'),
**       ('maximum value',                 x'7fefffffffffffff'))
**    SELECT c.name, decimal_mul(ieee754_mantissa(c.bin),pow2.v)
**      FROM pow2, c WHERE pow2.x=ieee754_exponent(c.bin);
**
*/
/* #include "sqlite3ext.h" */
/* Mark a function parameter as unused, to suppress nuisance compiler
** warnings. */
/*
** Implementation of the ieee754() function
*/
unsafe extern "C" fn ieee754func(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut current_block: u64;
    if argc == 1 as libc::c_int {
        let mut m: sqlite3_int64 = 0;
        let mut a: sqlite3_int64 = 0;
        let mut r: libc::c_double = 0.;
        let mut e: libc::c_int = 0;
        let mut isNeg: libc::c_int = 0;
        let mut zResult: [libc::c_char; 100] = [0; 100];
        if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int
            && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as libc::c_ulong
                == ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
        {
            let mut x: *const libc::c_uchar =
                sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_uchar;
            let mut i: libc::c_uint = 0;
            let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            i = 0 as libc::c_int as libc::c_uint;
            while (i as libc::c_ulong) < ::std::mem::size_of::<libc::c_double>() as libc::c_ulong {
                v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
                i = i.wrapping_add(1)
            }
            memcpy(
                &mut r as *mut libc::c_double as *mut libc::c_void,
                &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
            );
        } else {
            r = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize))
        }
        if r < 0.0f64 {
            isNeg = 1 as libc::c_int;
            r = -r
        } else {
            isNeg = 0 as libc::c_int
        }
        memcpy(
            &mut a as *mut sqlite3_int64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::std::mem::size_of::<sqlite3_int64>() as libc::c_ulong,
        );
        if a == 0 as libc::c_int as libc::c_longlong {
            e = 0 as libc::c_int;
            m = 0 as libc::c_int as sqlite3_int64
        } else {
            e = (a >> 52 as libc::c_int) as libc::c_int;
            m = a
                & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                    - 1 as libc::c_int as libc::c_longlong;
            if e == 0 as libc::c_int {
                m <<= 1 as libc::c_int
            } else {
                m |= (1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int
            }
            while e < 1075 as libc::c_int
                && m > 0 as libc::c_int as libc::c_longlong
                && m & 1 as libc::c_int as libc::c_longlong == 0 as libc::c_int as libc::c_longlong
            {
                m >>= 1 as libc::c_int;
                e += 1
            }
            if isNeg != 0 {
                m = -m
            }
        }
        match *(sqlite3_user_data(context) as *mut libc::c_int) {
            0 => {
                current_block = 18021469141773511333;
                match current_block {
                    12258012267434151447 => {
                        sqlite3_result_int(context, e - 1075 as libc::c_int);
                    }
                    6673300824729775352 => {
                        sqlite3_result_int64(context, m);
                    }
                    _ => {
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                                as libc::c_int,
                            zResult.as_mut_ptr(),
                            b"ieee754(%lld,%d)\x00" as *const u8 as *const libc::c_char,
                            m,
                            e - 1075 as libc::c_int,
                        );
                        sqlite3_result_text(
                            context,
                            zResult.as_mut_ptr(),
                            -(1 as libc::c_int),
                            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                                -(1 as libc::c_int) as libc::intptr_t,
                            ),
                        );
                    }
                }
            }
            1 => {
                current_block = 6673300824729775352;
                match current_block {
                    12258012267434151447 => {
                        sqlite3_result_int(context, e - 1075 as libc::c_int);
                    }
                    6673300824729775352 => {
                        sqlite3_result_int64(context, m);
                    }
                    _ => {
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                                as libc::c_int,
                            zResult.as_mut_ptr(),
                            b"ieee754(%lld,%d)\x00" as *const u8 as *const libc::c_char,
                            m,
                            e - 1075 as libc::c_int,
                        );
                        sqlite3_result_text(
                            context,
                            zResult.as_mut_ptr(),
                            -(1 as libc::c_int),
                            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                                -(1 as libc::c_int) as libc::intptr_t,
                            ),
                        );
                    }
                }
            }
            2 => {
                current_block = 12258012267434151447;
                match current_block {
                    12258012267434151447 => {
                        sqlite3_result_int(context, e - 1075 as libc::c_int);
                    }
                    6673300824729775352 => {
                        sqlite3_result_int64(context, m);
                    }
                    _ => {
                        sqlite3_snprintf(
                            ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                                as libc::c_int,
                            zResult.as_mut_ptr(),
                            b"ieee754(%lld,%d)\x00" as *const u8 as *const libc::c_char,
                            m,
                            e - 1075 as libc::c_int,
                        );
                        sqlite3_result_text(
                            context,
                            zResult.as_mut_ptr(),
                            -(1 as libc::c_int),
                            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                                -(1 as libc::c_int) as libc::intptr_t,
                            ),
                        );
                    }
                }
            }
            _ => {}
        }
    } else {
        let mut m_0: sqlite3_int64 = 0;
        let mut e_0: sqlite3_int64 = 0;
        let mut a_0: sqlite3_int64 = 0;
        let mut r_0: libc::c_double = 0.;
        let mut isNeg_0: libc::c_int = 0 as libc::c_int;
        m_0 = sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize));
        e_0 = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize));
        /* Limit the range of e.  Ticket 22dea1cfdb9151e4 2021-03-02 */
        if e_0 > 10000 as libc::c_int as libc::c_longlong {
            e_0 = 10000 as libc::c_int as sqlite3_int64
        } else if e_0 < -(10000 as libc::c_int) as libc::c_longlong {
            e_0 = -(10000 as libc::c_int) as sqlite3_int64
        }
        if m_0 < 0 as libc::c_int as libc::c_longlong {
            isNeg_0 = 1 as libc::c_int;
            m_0 = -m_0;
            if m_0 < 0 as libc::c_int as libc::c_longlong {
                return;
            }
        } else if m_0 == 0 as libc::c_int as libc::c_longlong
            && e_0 > -(1000 as libc::c_int) as libc::c_longlong
            && e_0 < 1000 as libc::c_int as libc::c_longlong
        {
            sqlite3_result_double(context, 0.0f64);
            return;
        }
        while m_0 >> 32 as libc::c_int & 0xffe00000 as libc::c_uint as libc::c_longlong != 0 {
            m_0 >>= 1 as libc::c_int;
            e_0 += 1
        }
        while m_0 != 0 as libc::c_int as libc::c_longlong
            && m_0 >> 32 as libc::c_int & 0xfff00000 as libc::c_uint as libc::c_longlong
                == 0 as libc::c_int as libc::c_longlong
        {
            m_0 <<= 1 as libc::c_int;
            e_0 -= 1
        }
        e_0 += 1075 as libc::c_int as libc::c_longlong;
        if e_0 <= 0 as libc::c_int as libc::c_longlong {
            /* Subnormal */
            if 1 as libc::c_int as libc::c_longlong - e_0 >= 64 as libc::c_int as libc::c_longlong {
                m_0 = 0 as libc::c_int as sqlite3_int64
            } else {
                m_0 >>= 1 as libc::c_int as libc::c_longlong - e_0
            }
            e_0 = 0 as libc::c_int as sqlite3_int64
        } else if e_0 > 0x7ff as libc::c_int as libc::c_longlong {
            e_0 = 0x7ff as libc::c_int as sqlite3_int64
        }
        a_0 = m_0
            & ((1 as libc::c_int as sqlite3_int64) << 52 as libc::c_int)
                - 1 as libc::c_int as libc::c_longlong;
        a_0 |= e_0 << 52 as libc::c_int;
        if isNeg_0 != 0 {
            a_0 = (a_0 as libc::c_ulonglong
                | (1 as libc::c_int as sqlite3_uint64) << 63 as libc::c_int)
                as sqlite3_int64
        }
        memcpy(
            &mut r_0 as *mut libc::c_double as *mut libc::c_void,
            &mut a_0 as *mut sqlite3_int64 as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r_0);
    };
}
/*
** Functions to convert between blobs and floats.
*/
unsafe extern "C" fn ieee754func_from_blob(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int
        && sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as libc::c_ulong
            == ::std::mem::size_of::<libc::c_double>() as libc::c_ulong
    {
        let mut r: libc::c_double = 0.; /* Unused parameter */
        let mut x: *const libc::c_uchar =
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_uchar;
        let mut i: libc::c_uint = 0;
        let mut v: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
        i = 0 as libc::c_int as libc::c_uint;
        while (i as libc::c_ulong) < ::std::mem::size_of::<libc::c_double>() as libc::c_ulong {
            v = v << 8 as libc::c_int | *x.offset(i as isize) as libc::c_ulonglong;
            i = i.wrapping_add(1)
        }
        memcpy(
            &mut r as *mut libc::c_double as *mut libc::c_void,
            &mut v as *mut sqlite3_uint64 as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        sqlite3_result_double(context, r);
    };
}
unsafe extern "C" fn ieee754func_to_blob(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 2 as libc::c_int
        || sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 1 as libc::c_int
    {
        let mut r: libc::c_double = sqlite3_value_double(*argv.offset(0 as libc::c_int as isize));
        let mut v: sqlite3_uint64 = 0;
        let mut a: [libc::c_uchar; 8] = [0; 8];
        let mut i: libc::c_uint = 0;
        memcpy(
            &mut v as *mut sqlite3_uint64 as *mut libc::c_void,
            &mut r as *mut libc::c_double as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
        );
        i = 1 as libc::c_int as libc::c_uint;
        while i as libc::c_ulong <= ::std::mem::size_of::<libc::c_double>() as libc::c_ulong {
            a[(::std::mem::size_of::<libc::c_double>() as libc::c_ulong)
                .wrapping_sub(i as libc::c_ulong) as usize] =
                (v & 0xff as libc::c_int as libc::c_ulonglong) as libc::c_uchar;
            v >>= 8 as libc::c_int;
            i = i.wrapping_add(1)
        }
        sqlite3_result_blob(
            context,
            a.as_mut_ptr() as *const libc::c_void,
            ::std::mem::size_of::<libc::c_double>() as libc::c_ulong as libc::c_int,
            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                -(1 as libc::c_int) as libc::intptr_t,
            ),
        );
    };
}
pub unsafe extern "C" fn sqlite3_ieee_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    static mut aFunc: [C2RustUnnamed_17; 6] = unsafe {
        [
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    nArg: 2 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_mantissa\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 1 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_exponent\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 2 as libc::c_int,
                    xFunc: Some(
                        ieee754func
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_to_blob\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_to_blob
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
            {
                let mut init = C2RustUnnamed_17 {
                    zFName: b"ieee754_from_blob\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    nArg: 1 as libc::c_int,
                    iAux: 0 as libc::c_int,
                    xFunc: Some(
                        ieee754func_from_blob
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                };
                init
            },
        ]
    };
    let mut i: libc::c_uint = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int as libc::c_uint;
    while (i as libc::c_ulong)
        < (::std::mem::size_of::<[C2RustUnnamed_17; 6]>() as libc::c_ulong)
            .wrapping_div(::std::mem::size_of::<C2RustUnnamed_17>() as libc::c_ulong)
        && rc == 0 as libc::c_int
    {
        rc = sqlite3_create_function(
            db,
            aFunc[i as usize].zFName,
            aFunc[i as usize].nArg,
            1 as libc::c_int | 0x200000 as libc::c_int,
            &(*aFunc.as_ptr().offset(i as isize)).iAux as *const libc::c_int as *mut libc::c_void,
            aFunc[i as usize].xFunc,
            None,
            None,
        );
        i = i.wrapping_add(1)
    }
    return rc;
}
/* Increment ("step") */
/*
** The seriesConnect() method is invoked to create a new
** series_vtab that describes the generate_series virtual table.
**
** Think of this routine as the constructor for series_vtab objects.
**
** All this routine needs to do is:
**
**    (1) Allocate the series_vtab object and initialize all fields.
**
**    (2) Tell SQLite (via the sqlite3_declare_vtab() interface) what the
**        result set of queries against generate_series will look like.
*/
unsafe extern "C" fn seriesConnect(
    mut db: *mut sqlite3,
    mut _pUnused: *mut libc::c_void,
    mut _argcUnused: libc::c_int,
    mut _argvUnused: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut _pzErrUnused: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pNew: *mut sqlite3_vtab = 0 as *mut sqlite3_vtab;
    let mut rc: libc::c_int = 0;
    /* Column numbers */
    rc = sqlite3_declare_vtab(
        db,
        b"CREATE TABLE x(value,start hidden,stop hidden,step hidden)\x00" as *const u8
            as *const libc::c_char,
    );
    if rc == 0 as libc::c_int {
        *ppVtab =
            sqlite3_malloc(::std::mem::size_of::<sqlite3_vtab>() as libc::c_ulong as libc::c_int)
                as *mut sqlite3_vtab;
        pNew = *ppVtab;
        if pNew.is_null() {
            return 7 as libc::c_int;
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<sqlite3_vtab>() as libc::c_ulong,
            );
            sqlite3_vtab_config(db, 2 as libc::c_int);
        }
    }
    return rc;
}
/*
** This method is the destructor for series_cursor objects.
*/
unsafe extern "C" fn seriesDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Constructor for a new series_cursor object.
*/
unsafe extern "C" fn seriesOpen(
    mut _pUnused: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = 0 as *mut series_cursor;
    pCur = sqlite3_malloc(::std::mem::size_of::<series_cursor>() as libc::c_ulong as libc::c_int)
        as *mut series_cursor;
    if pCur.is_null() {
        return 7 as libc::c_int;
    } else {
        memset(
            pCur as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<series_cursor>() as libc::c_ulong,
        );
        *ppCursor = &mut (*pCur).base;
        return 0 as libc::c_int;
    };
}
/*
** Destructor for a series_cursor.
*/
unsafe extern "C" fn seriesClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    sqlite3_free(cur as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Advance a series_cursor to its next row of output.
*/
unsafe extern "C" fn seriesNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        (*pCur).iValue -= (*pCur).iStep
    } else {
        (*pCur).iValue += (*pCur).iStep
    }
    (*pCur).iRowid += 1;
    return 0 as libc::c_int;
}
/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/
unsafe extern "C" fn seriesColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int
/* Which column to return */ {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    let mut x: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    match i {
        1 => x = (*pCur).mnValue,
        2 => x = (*pCur).mxValue,
        3 => x = (*pCur).iStep,
        _ => x = (*pCur).iValue,
    }
    sqlite3_result_int64(ctx, x);
    return 0 as libc::c_int;
}
/*
** Return the rowid for the current row. In this implementation, the
** first row returned is assigned rowid value 1, and each subsequent
** row a value 1 more than that of the previous.
*/
unsafe extern "C" fn seriesRowid(
    mut cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    *pRowid = (*pCur).iRowid;
    return 0 as libc::c_int;
}
/*
** Return TRUE if the cursor has been moved off of the last
** row of output.
*/
unsafe extern "C" fn seriesEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCur: *mut series_cursor = cur as *mut series_cursor;
    if (*pCur).isDesc != 0 {
        return ((*pCur).iValue < (*pCur).mnValue) as libc::c_int;
    } else {
        return ((*pCur).iValue > (*pCur).mxValue) as libc::c_int;
    };
}
/*
** This method is called to "rewind" the series_cursor object back
** to the first row of output.  This method is always called at least
** once prior to any call to seriesColumn() or seriesRowid() or
** seriesEof().
**
** The query plan selected by seriesBestIndex is passed in the idxNum
** parameter.  (idxStr is not used in this implementation.)  idxNum
** is a bitmask showing which constraints are available:
**
**    1:    start=VALUE
**    2:    stop=VALUE
**    4:    step=VALUE
**
** Also, if bit 8 is set, that means that the series should be output
** in descending order rather than in ascending order.  If bit 16 is
** set, then output must appear in ascending order.
**
** This routine should initialize the cursor and position it so that it
** is pointing at the first row, or pointing off the end of the table
** (so that seriesEof() will return true) if the table is empty.
*/
unsafe extern "C" fn seriesFilter(
    mut pVtabCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut _idxStrUnused: *const libc::c_char,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCur: *mut series_cursor = pVtabCursor as *mut series_cursor;
    let mut i: libc::c_int = 0 as libc::c_int;
    if idxNum & 1 as libc::c_int != 0 {
        let fresh14 = i;
        i = i + 1;
        (*pCur).mnValue = sqlite3_value_int64(*argv.offset(fresh14 as isize))
    } else {
        (*pCur).mnValue = 0 as libc::c_int as sqlite3_int64
    }
    if idxNum & 2 as libc::c_int != 0 {
        let fresh15 = i;
        i = i + 1;
        (*pCur).mxValue = sqlite3_value_int64(*argv.offset(fresh15 as isize))
    } else {
        (*pCur).mxValue = 0xffffffff as libc::c_uint as sqlite3_int64
    }
    if idxNum & 4 as libc::c_int != 0 {
        let fresh16 = i;
        i = i + 1;
        (*pCur).iStep = sqlite3_value_int64(*argv.offset(fresh16 as isize));
        if (*pCur).iStep == 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = 1 as libc::c_int as sqlite3_int64
        } else if (*pCur).iStep < 0 as libc::c_int as libc::c_longlong {
            (*pCur).iStep = -(*pCur).iStep;
            if idxNum & 16 as libc::c_int == 0 as libc::c_int {
                idxNum |= 8 as libc::c_int
            }
        }
    } else {
        (*pCur).iStep = 1 as libc::c_int as sqlite3_int64
    }
    i = 0 as libc::c_int;
    while i < argc {
        if sqlite3_value_type(*argv.offset(i as isize)) == 5 as libc::c_int {
            /* If any of the constraints have a NULL value, then return no rows.
             ** See ticket https://www.sqlite.org/src/info/fac496b61722daf2 */
            (*pCur).mnValue = 1 as libc::c_int as sqlite3_int64;
            (*pCur).mxValue = 0 as libc::c_int as sqlite3_int64;
            break;
        } else {
            i += 1
        }
    }
    if idxNum & 8 as libc::c_int != 0 {
        (*pCur).isDesc = 1 as libc::c_int;
        (*pCur).iValue = (*pCur).mxValue;
        if (*pCur).iStep > 0 as libc::c_int as libc::c_longlong {
            (*pCur).iValue -= ((*pCur).mxValue - (*pCur).mnValue) % (*pCur).iStep
        }
    } else {
        (*pCur).isDesc = 0 as libc::c_int;
        (*pCur).iValue = (*pCur).mnValue
    }
    (*pCur).iRowid = 1 as libc::c_int as sqlite3_int64;
    return 0 as libc::c_int;
}
/*
** SQLite will invoke this method one or more times while planning a query
** that uses the generate_series virtual table.  This routine needs to create
** a query plan for each invocation and compute an estimated cost for that
** plan.
**
** In this implementation idxNum is used to represent the
** query plan.  idxStr is unused.
**
** The query plan is represented by bits in idxNum:
**
**  (1)  start = $value  -- constraint exists
**  (2)  stop = $value   -- constraint exists
**  (4)  step = $value   -- constraint exists
**  (8)  output in descending order
*/
unsafe extern "C" fn seriesBestIndex(
    mut pVTab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0; /* Loop over constraints */
    let mut j: libc::c_int = 0; /* The query plan bitmask */
    let mut idxNum: libc::c_int = 0 as libc::c_int; /* EQ constraint seen on the START column */
    let mut bStartSeen: libc::c_int = 0 as libc::c_int; /* Mask of unusable constraints */
    let mut unusableMask: libc::c_int = 0 as libc::c_int; /* Number of arguments that seriesFilter() expects */
    let mut nArg: libc::c_int = 0 as libc::c_int; /* Constraints on start, stop, and step */
    let mut aIdx: [libc::c_int; 3] = [0; 3];
    let mut pConstraint: *const sqlite3_index_constraint = 0 as *const sqlite3_index_constraint;
    /* This implementation assumes that the start, stop, and step columns
     ** are the last three columns in the virtual table. */
    aIdx[2 as libc::c_int as usize] = -(1 as libc::c_int); /* 0 for start, 1 for stop, 2 for step */
    aIdx[1 as libc::c_int as usize] = aIdx[2 as libc::c_int as usize]; /* bitmask for those column */
    aIdx[0 as libc::c_int as usize] = aIdx[1 as libc::c_int as usize];
    pConstraint = (*pIdxInfo).aConstraint;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut iCol: libc::c_int = 0;
        let mut iMask: libc::c_int = 0;
        if !((*pConstraint).iColumn < 1 as libc::c_int) {
            iCol = (*pConstraint).iColumn - 1 as libc::c_int;
            iMask = (1 as libc::c_int) << iCol;
            if iCol == 0 as libc::c_int {
                bStartSeen = 1 as libc::c_int
            }
            if (*pConstraint).usable as libc::c_int == 0 as libc::c_int {
                unusableMask |= iMask
            } else if (*pConstraint).op as libc::c_int == 2 as libc::c_int {
                idxNum |= iMask;
                aIdx[iCol as usize] = i
            }
        }
        i += 1;
        pConstraint = pConstraint.offset(1)
    }
    i = 0 as libc::c_int;
    while i < 3 as libc::c_int {
        j = aIdx[i as usize];
        if j >= 0 as libc::c_int {
            nArg += 1;
            (*(*pIdxInfo).aConstraintUsage.offset(j as isize)).argvIndex = nArg;
            (*(*pIdxInfo).aConstraintUsage.offset(j as isize)).omit =
                (0 as libc::c_int == 0) as libc::c_int as libc::c_uchar
        }
        i += 1
    }
    /* The current generate_column() implementation requires at least one
     ** argument (the START value).  Legacy versions assumed START=0 if the
     ** first argument was omitted.  Compile with -DZERO_ARGUMENT_GENERATE_SERIES
     ** to obtain the legacy behavior */
    if bStartSeen == 0 {
        sqlite3_free((*pVTab).zErrMsg as *mut libc::c_void);
        (*pVTab).zErrMsg = sqlite3_mprintf(
            b"first argument to \"generate_series()\" missing or unusable\x00" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else if unusableMask & !idxNum != 0 as libc::c_int {
        /* The start, stop, and step columns are inputs.  Therefore if there
         ** are unusable constraints on any of start, stop, or step then
         ** this plan is unusable */
        return 19 as libc::c_int;
    } else {
        if idxNum & 3 as libc::c_int == 3 as libc::c_int {
            /* Both start= and stop= boundaries are available.  This is the
             ** the preferred case */
            (*pIdxInfo).estimatedCost = (2 as libc::c_int
                - (idxNum & 4 as libc::c_int != 0 as libc::c_int) as libc::c_int)
                as libc::c_double;
            (*pIdxInfo).estimatedRows = 1000 as libc::c_int as sqlite3_int64;
            if (*pIdxInfo).nOrderBy == 1 as libc::c_int {
                if (*(*pIdxInfo).aOrderBy.offset(0 as libc::c_int as isize)).desc != 0 {
                    idxNum |= 8 as libc::c_int
                } else {
                    idxNum |= 16 as libc::c_int
                }
                (*pIdxInfo).orderByConsumed = 1 as libc::c_int
            }
        } else {
            /* If either boundary is missing, we have to generate a huge span
             ** of numbers.  Make this case very expensive so that the query
             ** planner will work hard to avoid it. */
            (*pIdxInfo).estimatedRows = 2147483647 as libc::c_int as sqlite3_int64
        }
        (*pIdxInfo).idxNum = idxNum;
        return 0 as libc::c_int;
    };
}
/*
** This following structure defines all the methods for the
** generate_series virtual table.
*/
static mut seriesModule: sqlite3_module = unsafe {
    {
        let mut init = sqlite3_module {
            iVersion: 0 as libc::c_int,
            xCreate: None,
            xConnect: Some(
                seriesConnect
                    as unsafe extern "C" fn(
                        _: *mut sqlite3,
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: *const *const libc::c_char,
                        _: *mut *mut sqlite3_vtab,
                        _: *mut *mut libc::c_char,
                    ) -> libc::c_int,
            ),
            xBestIndex: Some(
                seriesBestIndex
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab,
                        _: *mut sqlite3_index_info,
                    ) -> libc::c_int,
            ),
            xDisconnect: Some(
                seriesDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
            ),
            xDestroy: None,
            xOpen: Some(
                seriesOpen
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab,
                        _: *mut *mut sqlite3_vtab_cursor,
                    ) -> libc::c_int,
            ),
            xClose: Some(
                seriesClose as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xFilter: Some(
                seriesFilter
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: libc::c_int,
                        _: *const libc::c_char,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> libc::c_int,
            ),
            xNext: Some(
                seriesNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xEof: Some(
                seriesEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
            ),
            xColumn: Some(
                seriesColumn
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                    ) -> libc::c_int,
            ),
            xRowid: Some(
                seriesRowid
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_vtab_cursor,
                        _: *mut sqlite_int64,
                    ) -> libc::c_int,
            ),
            xUpdate: None,
            xBegin: None,
            xSync: None,
            xCommit: None,
            xRollback: None,
            xFindFunction: None,
            xRename: None,
            xSavepoint: None,
            xRelease: None,
            xRollbackTo: None,
            xShadowName: None,
        };
        init
    }
};
/* SQLITE_OMIT_VIRTUALTABLE */
pub unsafe extern "C" fn sqlite3_series_init(
    mut db: *mut sqlite3,
    mut pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sqlite3_libversion_number() < 3008012 as libc::c_int && !pzErrMsg.is_null() {
        *pzErrMsg = sqlite3_mprintf(
            b"generate_series() requires SQLite 3.8.12 or later\x00" as *const u8
                as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else {
        rc = sqlite3_create_module(
            db,
            b"generate_series\x00" as *const u8 as *const libc::c_char,
            &mut seriesModule,
            0 as *mut libc::c_void,
        );
        return rc;
    };
}
/* Slots allocated for aOp[] and aArg[] */
/* Add a state to the given state set if it is not already there */
unsafe extern "C" fn re_add_state(mut pSet: *mut ReStateSet, mut newState: libc::c_int) {
    let mut i: libc::c_uint = 0;
    i = 0 as libc::c_int as libc::c_uint;
    while i < (*pSet).nState {
        if *(*pSet).aState.offset(i as isize) as libc::c_int == newState {
            return;
        } else {
            i = i.wrapping_add(1)
        }
    }
    let fresh17 = (*pSet).nState;
    (*pSet).nState = (*pSet).nState.wrapping_add(1);
    *(*pSet).aState.offset(fresh17 as isize) = newState as ReStateNumber;
}
/* Extract the next unicode character from *pzIn and return it.  Advance
** *pzIn to the first byte past the end of the character returned.  To
** be clear:  this routine converts utf8 to unicode.  This routine is
** optimized for the common case where the next character is a single byte.
*/
unsafe extern "C" fn re_next_char(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = 0;
    if (*p).i >= (*p).mx {
        return 0 as libc::c_int as libc::c_uint;
    } else {
        let fresh18 = (*p).i;
        (*p).i = (*p).i + 1;
        c = *(*p).z.offset(fresh18 as isize) as libc::c_uint;
        if c >= 0x80 as libc::c_int as libc::c_uint {
            if c & 0xe0 as libc::c_int as libc::c_uint == 0xc0 as libc::c_int as libc::c_uint
                && (*p).i < (*p).mx
                && *(*p).z.offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
            {
                let fresh19 = (*p).i;
                (*p).i = (*p).i + 1;
                c = (c & 0x1f as libc::c_int as libc::c_uint) << 6 as libc::c_int
                    | (*(*p).z.offset(fresh19 as isize) as libc::c_int & 0x3f as libc::c_int)
                        as libc::c_uint;
                if c < 0x80 as libc::c_int as libc::c_uint {
                    c = 0xfffd as libc::c_int as libc::c_uint
                }
            } else if c & 0xf0 as libc::c_int as libc::c_uint == 0xe0 as libc::c_int as libc::c_uint
                && ((*p).i + 1 as libc::c_int) < (*p).mx
                && *(*p).z.offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
                && *(*p).z.offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
            {
                c = (c & 0xf as libc::c_int as libc::c_uint) << 12 as libc::c_int
                    | ((*(*p).z.offset((*p).i as isize) as libc::c_int & 0x3f as libc::c_int)
                        << 6 as libc::c_int) as libc::c_uint
                    | (*(*p).z.offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0x3f as libc::c_int) as libc::c_uint;
                (*p).i += 2 as libc::c_int;
                if c <= 0x7ff as libc::c_int as libc::c_uint
                    || c >= 0xd800 as libc::c_int as libc::c_uint
                        && c <= 0xdfff as libc::c_int as libc::c_uint
                {
                    c = 0xfffd as libc::c_int as libc::c_uint
                }
            } else if c & 0xf8 as libc::c_int as libc::c_uint == 0xf0 as libc::c_int as libc::c_uint
                && ((*p).i + 3 as libc::c_int) < (*p).mx
                && *(*p).z.offset((*p).i as isize) as libc::c_int & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
                && *(*p).z.offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                    & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
                && *(*p).z.offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                    & 0xc0 as libc::c_int
                    == 0x80 as libc::c_int
            {
                c = (c & 0x7 as libc::c_int as libc::c_uint) << 18 as libc::c_int
                    | ((*(*p).z.offset((*p).i as isize) as libc::c_int & 0x3f as libc::c_int)
                        << 12 as libc::c_int) as libc::c_uint
                    | ((*(*p).z.offset(((*p).i + 1 as libc::c_int) as isize) as libc::c_int
                        & 0x3f as libc::c_int)
                        << 6 as libc::c_int) as libc::c_uint
                    | (*(*p).z.offset(((*p).i + 2 as libc::c_int) as isize) as libc::c_int
                        & 0x3f as libc::c_int) as libc::c_uint;
                (*p).i += 3 as libc::c_int;
                if c <= 0xffff as libc::c_int as libc::c_uint
                    || c > 0x10ffff as libc::c_int as libc::c_uint
                {
                    c = 0xfffd as libc::c_int as libc::c_uint
                }
            } else {
                c = 0xfffd as libc::c_int as libc::c_uint
            }
        }
        return c;
    };
}
unsafe extern "C" fn re_next_char_nocase(mut p: *mut ReInput) -> libc::c_uint {
    let mut c: libc::c_uint = re_next_char(p);
    if c >= 'A' as i32 as libc::c_uint && c <= 'Z' as i32 as libc::c_uint {
        c = c.wrapping_add(('a' as i32 - 'A' as i32) as libc::c_uint)
    }
    return c;
}
/* Return true if c is a perl "word" character:  [A-Za-z0-9_] */
unsafe extern "C" fn re_word_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32
        || c >= 'a' as i32 && c <= 'z' as i32
        || c >= 'A' as i32 && c <= 'Z' as i32
        || c == '_' as i32) as libc::c_int;
}
/* Return true if c is a "digit" character:  [0-9] */
unsafe extern "C" fn re_digit_char(mut c: libc::c_int) -> libc::c_int {
    return (c >= '0' as i32 && c <= '9' as i32) as libc::c_int;
}
/* Return true if c is a perl "space" character:  [ \t\r\n\v\f] */
unsafe extern "C" fn re_space_char(mut c: libc::c_int) -> libc::c_int {
    return (c == ' ' as i32
        || c == '\t' as i32
        || c == '\n' as i32
        || c == '\r' as i32
        || c == '\u{b}' as i32
        || c == '\u{c}' as i32) as libc::c_int;
}
/* Run a compiled regular expression on the zero-terminated input
** string zIn[].  Return true on a match and false if there is no match.
*/
unsafe extern "C" fn sqlite3re_match(
    mut pRe: *mut ReCompiled,
    mut zIn: *const libc::c_uchar,
    mut nIn: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut aStateSet: [ReStateSet; 2] = [ReStateSet {
        nState: 0,
        aState: 0 as *mut ReStateNumber,
    }; 2];
    let mut pThis: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut pNext: *mut ReStateSet = 0 as *mut ReStateSet;
    let mut aSpace: [ReStateNumber; 100] = [0; 100];
    let mut pToFree: *mut ReStateNumber = 0 as *mut ReStateNumber;
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut iSwap: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut c: libc::c_int = 0 as libc::c_int + 1 as libc::c_int;
    let mut cPrev: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut in_0: ReInput = ReInput {
        z: 0 as *const libc::c_uchar,
        i: 0,
        mx: 0,
    };
    in_0.z = zIn;
    in_0.i = 0 as libc::c_int;
    in_0.mx = if nIn >= 0 as libc::c_int {
        nIn
    } else {
        strlen(zIn as *const libc::c_char) as libc::c_int
    };
    /* Look for the initial prefix match, if there is one. */
    if (*pRe).nInit != 0 {
        let mut x: libc::c_uchar = (*pRe).zInit[0 as libc::c_int as usize];
        while in_0.i + (*pRe).nInit <= in_0.mx
            && (*zIn.offset(in_0.i as isize) as libc::c_int != x as libc::c_int
                || strncmp(
                    (zIn as *const libc::c_char).offset(in_0.i as isize),
                    (*pRe).zInit.as_mut_ptr() as *const libc::c_char,
                    (*pRe).nInit as libc::c_ulong,
                ) != 0 as libc::c_int)
        {
            in_0.i += 1
        }
        if in_0.i + (*pRe).nInit > in_0.mx {
            return 0 as libc::c_int;
        }
    }
    if (*pRe).nState as libc::c_ulong
        <= (::std::mem::size_of::<[ReStateNumber; 100]>() as libc::c_ulong).wrapping_div(
            (::std::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong),
        )
    {
        pToFree = 0 as *mut ReStateNumber;
        aStateSet[0 as libc::c_int as usize].aState = aSpace.as_mut_ptr()
    } else {
        pToFree = sqlite3_malloc64(
            (::std::mem::size_of::<ReStateNumber>() as libc::c_ulong)
                .wrapping_mul(2 as libc::c_int as libc::c_ulong)
                .wrapping_mul((*pRe).nState as libc::c_ulong) as sqlite3_uint64,
        ) as *mut ReStateNumber;
        if pToFree.is_null() {
            return -(1 as libc::c_int);
        } else {
            aStateSet[0 as libc::c_int as usize].aState = pToFree
        }
    }
    aStateSet[1 as libc::c_int as usize].aState =
        &mut *(*aStateSet.as_mut_ptr().offset(0 as libc::c_int as isize))
            .aState
            .offset((*pRe).nState as isize) as *mut ReStateNumber;
    pNext = &mut *aStateSet.as_mut_ptr().offset(1 as libc::c_int as isize) as *mut ReStateSet;
    (*pNext).nState = 0 as libc::c_int as libc::c_uint;
    re_add_state(pNext, 0 as libc::c_int);
    's_109: loop {
        if !(c != 0 as libc::c_int && (*pNext).nState > 0 as libc::c_int as libc::c_uint) {
            current_block = 8716029205547827362;
            break;
        }
        cPrev = c;
        c = (*pRe).xNextChar.expect("non-null function pointer")(&mut in_0) as libc::c_int;
        pThis = pNext;
        pNext = &mut *aStateSet.as_mut_ptr().offset(iSwap as isize) as *mut ReStateSet;
        iSwap = (1 as libc::c_int as libc::c_uint).wrapping_sub(iSwap);
        (*pNext).nState = 0 as libc::c_int as libc::c_uint;
        i = 0 as libc::c_int as libc::c_uint;
        while i < (*pThis).nState {
            let mut x_0: libc::c_int = *(*pThis).aState.offset(i as isize) as libc::c_int;
            match *(*pRe).aOp.offset(x_0 as isize) as libc::c_int {
                1 => {
                    if *(*pRe).aArg.offset(x_0 as isize) == c {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                2 => {
                    if c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                11 => {
                    if re_word_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                12 => {
                    if re_word_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                13 => {
                    if re_digit_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                14 => {
                    if re_digit_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                15 => {
                    if re_space_char(c) != 0 {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                16 => {
                    if re_space_char(c) == 0 && c != 0 as libc::c_int {
                        re_add_state(pNext, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                17 => {
                    if re_word_char(c) != re_word_char(cPrev) {
                        re_add_state(pThis, x_0 + 1 as libc::c_int);
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 11057878835866523405;
                    }
                }
                3 => {
                    re_add_state(pNext, x_0);
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 11057878835866523405;
                }
                4 => {
                    re_add_state(pThis, x_0 + *(*pRe).aArg.offset(x_0 as isize));
                    re_add_state(pThis, x_0 + 1 as libc::c_int);
                    current_block = 11057878835866523405;
                }
                5 => {
                    re_add_state(pThis, x_0 + *(*pRe).aArg.offset(x_0 as isize));
                    current_block = 11057878835866523405;
                }
                6 => {
                    rc = 1 as libc::c_int;
                    current_block = 12638014518832219085;
                    break 's_109;
                }
                8 => {
                    if c == 0 as libc::c_int {
                        current_block = 11057878835866523405;
                    } else {
                        current_block = 9437013279121998969;
                    }
                }
                7 => {
                    current_block = 9437013279121998969;
                }
                _ => {
                    current_block = 11057878835866523405;
                }
            }
            match current_block {
                9437013279121998969 =>
                /* fall-through */
                {
                    let mut j: libc::c_int = 1 as libc::c_int;
                    let mut n: libc::c_int = *(*pRe).aArg.offset(x_0 as isize);
                    let mut hit: libc::c_int = 0 as libc::c_int;
                    j = 1 as libc::c_int;
                    while j > 0 as libc::c_int && j < n {
                        if *(*pRe).aOp.offset((x_0 + j) as isize) as libc::c_int == 9 as libc::c_int
                        {
                            if *(*pRe).aArg.offset((x_0 + j) as isize) == c {
                                hit = 1 as libc::c_int;
                                j = -(1 as libc::c_int)
                            }
                        } else if *(*pRe).aArg.offset((x_0 + j) as isize) <= c
                            && *(*pRe).aArg.offset((x_0 + j + 1 as libc::c_int) as isize) >= c
                        {
                            hit = 1 as libc::c_int;
                            j = -(1 as libc::c_int)
                        } else {
                            j += 1
                        }
                        j += 1
                    }
                    if *(*pRe).aOp.offset(x_0 as isize) as libc::c_int == 8 as libc::c_int {
                        hit = (hit == 0) as libc::c_int
                    }
                    if hit != 0 {
                        re_add_state(pNext, x_0 + n);
                    }
                }
                _ => {}
            }
            i = i.wrapping_add(1)
        }
    }
    match current_block {
        8716029205547827362 => {
            i = 0 as libc::c_int as libc::c_uint;
            while i < (*pNext).nState {
                if *(*pRe)
                    .aOp
                    .offset(*(*pNext).aState.offset(i as isize) as isize)
                    as libc::c_int
                    == 6 as libc::c_int
                {
                    rc = 1 as libc::c_int;
                    break;
                } else {
                    i = i.wrapping_add(1)
                }
            }
        }
        _ => {}
    }
    sqlite3_free(pToFree as *mut libc::c_void);
    return rc;
}
/* Resize the opcode and argument arrays for an RE under construction.
*/
unsafe extern "C" fn re_resize(mut p: *mut ReCompiled, mut N: libc::c_int) -> libc::c_int {
    let mut aOp: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut aArg: *mut libc::c_int = 0 as *mut libc::c_int;
    aOp = sqlite3_realloc64(
        (*p).aOp as *mut libc::c_void,
        (N as libc::c_ulong).wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut libc::c_char;
    if aOp.is_null() {
        return 1 as libc::c_int;
    } else {
        (*p).aOp = aOp;
        aArg = sqlite3_realloc64(
            (*p).aArg as *mut libc::c_void,
            (N as libc::c_ulong).wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                as sqlite3_uint64,
        ) as *mut libc::c_int;
        if aArg.is_null() {
            return 1 as libc::c_int;
        } else {
            (*p).aArg = aArg;
            (*p).nAlloc = N as libc::c_uint;
            return 0 as libc::c_int;
        }
    };
}
/* Insert a new opcode and argument into an RE under construction.  The
** insertion point is just prior to existing opcode iBefore.
*/
unsafe extern "C" fn re_insert(
    mut p: *mut ReCompiled,
    mut iBefore: libc::c_int,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if (*p).nAlloc <= (*p).nState
        && re_resize(
            p,
            (*p).nAlloc.wrapping_mul(2 as libc::c_int as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return 0 as libc::c_int;
    } else {
        i = (*p).nState as libc::c_int;
        while i > iBefore {
            *(*p).aOp.offset(i as isize) = *(*p).aOp.offset((i - 1 as libc::c_int) as isize);
            *(*p).aArg.offset(i as isize) = *(*p).aArg.offset((i - 1 as libc::c_int) as isize);
            i -= 1
        }
        (*p).nState = (*p).nState.wrapping_add(1);
        *(*p).aOp.offset(iBefore as isize) = op as libc::c_char;
        *(*p).aArg.offset(iBefore as isize) = arg;
        return iBefore;
    };
}
/* Append a new opcode and argument to the end of the RE under construction.
*/
unsafe extern "C" fn re_append(
    mut p: *mut ReCompiled,
    mut op: libc::c_int,
    mut arg: libc::c_int,
) -> libc::c_int {
    return re_insert(p, (*p).nState as libc::c_int, op, arg);
}
/* Make a copy of N opcodes starting at iStart onto the end of the RE
** under construction.
*/
unsafe extern "C" fn re_copy(mut p: *mut ReCompiled, mut iStart: libc::c_int, mut N: libc::c_int) {
    if (*p).nState.wrapping_add(N as libc::c_uint) >= (*p).nAlloc
        && re_resize(
            p,
            (*p).nAlloc
                .wrapping_mul(2 as libc::c_int as libc::c_uint)
                .wrapping_add(N as libc::c_uint) as libc::c_int,
        ) != 0
    {
        return;
    } else {
        memcpy(
            &mut *(*p).aOp.offset((*p).nState as isize) as *mut libc::c_char as *mut libc::c_void,
            &mut *(*p).aOp.offset(iStart as isize) as *mut libc::c_char as *const libc::c_void,
            (N as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_char>() as libc::c_ulong),
        );
        memcpy(
            &mut *(*p).aArg.offset((*p).nState as isize) as *mut libc::c_int as *mut libc::c_void,
            &mut *(*p).aArg.offset(iStart as isize) as *mut libc::c_int as *const libc::c_void,
            (N as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        (*p).nState = (*p).nState.wrapping_add(N as libc::c_uint);
        return;
    };
}
/* Return true if c is a hexadecimal digit character:  [0-9a-fA-F]
** If c is a hex digit, also set *pV = (*pV)*16 + valueof(c).  If
** c is not a hex digit *pV is unchanged.
*/
unsafe extern "C" fn re_hex(mut c: libc::c_int, mut pV: *mut libc::c_int) -> libc::c_int {
    if c >= '0' as i32 && c <= '9' as i32 {
        c -= '0' as i32
    } else if c >= 'a' as i32 && c <= 'f' as i32 {
        c -= 'a' as i32 - 10 as libc::c_int
    } else if c >= 'A' as i32 && c <= 'F' as i32 {
        c -= 'A' as i32 - 10 as libc::c_int
    } else {
        return 0 as libc::c_int;
    }
    *pV = *pV * 16 as libc::c_int + (c & 0xff as libc::c_int);
    return 1 as libc::c_int;
}
/* A backslash character has been seen, read the next character and
** return its interpretation.
*/
unsafe extern "C" fn re_esc_char(mut p: *mut ReCompiled) -> libc::c_uint {
    static mut zEsc: [libc::c_char; 21] = unsafe {
        *::std::mem::transmute::<&[u8; 21], &[libc::c_char; 21]>(b"afnrtv\\()*.+?[$^{|}]\x00")
    };
    static mut zTrans: [libc::c_char; 7] = unsafe {
        *::std::mem::transmute::<&[u8; 7], &[libc::c_char; 7]>(b"\x07\x0c\n\r\t\x0b\x00")
    };
    let mut i: libc::c_int = 0;
    let mut v: libc::c_int = 0 as libc::c_int;
    let mut c: libc::c_char = 0;
    if (*p).sIn.i >= (*p).sIn.mx {
        return 0 as libc::c_int as libc::c_uint;
    } else {
        c = *(*p).sIn.z.offset((*p).sIn.i as isize) as libc::c_char;
        if c as libc::c_int == 'u' as i32 && ((*p).sIn.i + 4 as libc::c_int) < (*p).sIn.mx {
            let mut zIn: *const libc::c_uchar = (*p).sIn.z.offset((*p).sIn.i as isize);
            if re_hex(
                *zIn.offset(1 as libc::c_int as isize) as libc::c_int,
                &mut v,
            ) != 0
                && re_hex(
                    *zIn.offset(2 as libc::c_int as isize) as libc::c_int,
                    &mut v,
                ) != 0
                && re_hex(
                    *zIn.offset(3 as libc::c_int as isize) as libc::c_int,
                    &mut v,
                ) != 0
                && re_hex(
                    *zIn.offset(4 as libc::c_int as isize) as libc::c_int,
                    &mut v,
                ) != 0
            {
                (*p).sIn.i += 5 as libc::c_int;
                return v as libc::c_uint;
            }
        }
        if c as libc::c_int == 'x' as i32 && ((*p).sIn.i + 2 as libc::c_int) < (*p).sIn.mx {
            let mut zIn_0: *const libc::c_uchar = (*p).sIn.z.offset((*p).sIn.i as isize);
            if re_hex(
                *zIn_0.offset(1 as libc::c_int as isize) as libc::c_int,
                &mut v,
            ) != 0
                && re_hex(
                    *zIn_0.offset(2 as libc::c_int as isize) as libc::c_int,
                    &mut v,
                ) != 0
            {
                (*p).sIn.i += 3 as libc::c_int;
                return v as libc::c_uint;
            }
        }
        i = 0 as libc::c_int;
        while zEsc[i as usize] as libc::c_int != 0
            && zEsc[i as usize] as libc::c_int != c as libc::c_int
        {
            i += 1
        }
        if zEsc[i as usize] != 0 {
            if i < 6 as libc::c_int {
                c = zTrans[i as usize]
            }
            (*p).sIn.i += 1
        } else {
            (*p).zErr = b"unknown \\ escape\x00" as *const u8 as *const libc::c_char
        }
        return c as libc::c_uint;
    };
}
/* Peek at the next byte of input */
unsafe extern "C" fn rePeek(mut p: *mut ReCompiled) -> libc::c_uchar {
    return if (*p).sIn.i < (*p).sIn.mx {
        *(*p).sIn.z.offset((*p).sIn.i as isize) as libc::c_int
    } else {
        0 as libc::c_int
    } as libc::c_uchar;
}
/* Compile RE text into a sequence of opcodes.  Continue up to the
** first unmatched ")" character, then return.  If an error is found,
** return a pointer to the error message string.
*/
unsafe extern "C" fn re_subcompile_re(mut p: *mut ReCompiled) -> *const libc::c_char {
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut iStart: libc::c_int = 0;
    let mut iEnd: libc::c_int = 0;
    let mut iGoto: libc::c_int = 0;
    iStart = (*p).nState as libc::c_int;
    zErr = re_subcompile_string(p);
    if !zErr.is_null() {
        return zErr;
    } else {
        while rePeek(p) as libc::c_int == '|' as i32 {
            iEnd = (*p).nState as libc::c_int;
            re_insert(
                p,
                iStart,
                4 as libc::c_int,
                iEnd + 2 as libc::c_int - iStart,
            );
            iGoto = re_append(p, 5 as libc::c_int, 0 as libc::c_int);
            (*p).sIn.i += 1;
            zErr = re_subcompile_string(p);
            if !zErr.is_null() {
                return zErr;
            } else {
                *(*p).aArg.offset(iGoto as isize) =
                    (*p).nState.wrapping_sub(iGoto as libc::c_uint) as libc::c_int
            }
        }
        return 0 as *const libc::c_char;
    };
}
/* Forward declaration */
/* Compile an element of regular expression text (anything that can be
** an operand to the "|" operator).  Return NULL on success or a pointer
** to the error message if there is a problem.
*/
unsafe extern "C" fn re_subcompile_string(mut p: *mut ReCompiled) -> *const libc::c_char {
    let mut iPrev: libc::c_int = -(1 as libc::c_int);
    let mut iStart: libc::c_int = 0;
    let mut c: libc::c_uint = 0;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    loop {
        c = (*p).xNextChar.expect("non-null function pointer")(&mut (*p).sIn);
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        iStart = (*p).nState as libc::c_int;
        match c {
            124 | 36 | 41 => {
                (*p).sIn.i -= 1;
                return 0 as *const libc::c_char;
            }
            40 => {
                zErr = re_subcompile_re(p);
                if !zErr.is_null() {
                    return zErr;
                } else if rePeek(p) as libc::c_int != ')' as i32 {
                    return b"unmatched \'(\'\x00" as *const u8 as *const libc::c_char;
                } else {
                    (*p).sIn.i += 1
                }
            }
            46 => {
                if rePeek(p) as libc::c_int == '*' as i32 {
                    re_append(p, 3 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1
                } else {
                    re_append(p, 2 as libc::c_int, 0 as libc::c_int);
                }
            }
            42 => {
                if iPrev < 0 as libc::c_int {
                    return b"\'*\' without operand\x00" as *const u8 as *const libc::c_char;
                } else {
                    re_insert(
                        p,
                        iPrev,
                        5 as libc::c_int,
                        (*p).nState
                            .wrapping_sub(iPrev as libc::c_uint)
                            .wrapping_add(1 as libc::c_int as libc::c_uint)
                            as libc::c_int,
                    );
                    re_append(
                        p,
                        4 as libc::c_int,
                        (iPrev as libc::c_uint)
                            .wrapping_sub((*p).nState)
                            .wrapping_add(1 as libc::c_int as libc::c_uint)
                            as libc::c_int,
                    );
                }
            }
            43 => {
                if iPrev < 0 as libc::c_int {
                    return b"\'+\' without operand\x00" as *const u8 as *const libc::c_char;
                } else {
                    re_append(
                        p,
                        4 as libc::c_int,
                        (iPrev as libc::c_uint).wrapping_sub((*p).nState) as libc::c_int,
                    );
                }
            }
            63 => {
                if iPrev < 0 as libc::c_int {
                    return b"\'?\' without operand\x00" as *const u8 as *const libc::c_char;
                } else {
                    re_insert(
                        p,
                        iPrev,
                        4 as libc::c_int,
                        (*p).nState
                            .wrapping_sub(iPrev as libc::c_uint)
                            .wrapping_add(1 as libc::c_int as libc::c_uint)
                            as libc::c_int,
                    );
                }
            }
            123 => {
                let mut m: libc::c_int = 0 as libc::c_int;
                let mut n: libc::c_int = 0 as libc::c_int;
                let mut sz: libc::c_int = 0;
                let mut j: libc::c_int = 0;
                if iPrev < 0 as libc::c_int {
                    return b"\'{m,n}\' without operand\x00" as *const u8 as *const libc::c_char;
                } else {
                    loop {
                        c = rePeek(p) as libc::c_uint;
                        if !(c >= '0' as i32 as libc::c_uint && c <= '9' as i32 as libc::c_uint) {
                            break;
                        }
                        m = ((m * 10 as libc::c_int) as libc::c_uint)
                            .wrapping_add(c)
                            .wrapping_sub('0' as i32 as libc::c_uint)
                            as libc::c_int;
                        (*p).sIn.i += 1
                    }
                    n = m;
                    if c == ',' as i32 as libc::c_uint {
                        (*p).sIn.i += 1;
                        n = 0 as libc::c_int;
                        loop {
                            c = rePeek(p) as libc::c_uint;
                            if !(c >= '0' as i32 as libc::c_uint && c <= '9' as i32 as libc::c_uint)
                            {
                                break;
                            }
                            n = ((n * 10 as libc::c_int) as libc::c_uint)
                                .wrapping_add(c)
                                .wrapping_sub('0' as i32 as libc::c_uint)
                                as libc::c_int;
                            (*p).sIn.i += 1
                        }
                    }
                    if c != '}' as i32 as libc::c_uint {
                        return b"unmatched \'{\'\x00" as *const u8 as *const libc::c_char;
                    } else if n > 0 as libc::c_int && n < m {
                        return b"n less than m in \'{m,n}\'\x00" as *const u8
                            as *const libc::c_char;
                    } else {
                        (*p).sIn.i += 1;
                        sz = (*p).nState.wrapping_sub(iPrev as libc::c_uint) as libc::c_int;
                        if m == 0 as libc::c_int {
                            if n == 0 as libc::c_int {
                                return b"both m and n are zero in \'{m,n}\'\x00" as *const u8
                                    as *const libc::c_char;
                            } else {
                                re_insert(p, iPrev, 4 as libc::c_int, sz + 1 as libc::c_int);
                                n -= 1
                            }
                        } else {
                            j = 1 as libc::c_int;
                            while j < m {
                                re_copy(p, iPrev, sz);
                                j += 1
                            }
                        }
                        j = m;
                        while j < n {
                            re_append(p, 4 as libc::c_int, sz + 1 as libc::c_int);
                            re_copy(p, iPrev, sz);
                            j += 1
                        }
                        if n == 0 as libc::c_int && m > 0 as libc::c_int {
                            re_append(p, 4 as libc::c_int, -sz);
                        }
                    }
                }
            }
            91 => {
                let mut iFirst: libc::c_int = (*p).nState as libc::c_int;
                if rePeek(p) as libc::c_int == '^' as i32 {
                    re_append(p, 8 as libc::c_int, 0 as libc::c_int);
                    (*p).sIn.i += 1
                } else {
                    re_append(p, 7 as libc::c_int, 0 as libc::c_int);
                }
                loop {
                    c = (*p).xNextChar.expect("non-null function pointer")(&mut (*p).sIn);
                    if !(c != 0 as libc::c_int as libc::c_uint) {
                        break;
                    }
                    if c == '[' as i32 as libc::c_uint && rePeek(p) as libc::c_int == ':' as i32 {
                        return b"POSIX character classes not supported\x00" as *const u8
                            as *const libc::c_char;
                    } else {
                        if c == '\\' as i32 as libc::c_uint {
                            c = re_esc_char(p)
                        }
                        if rePeek(p) as libc::c_int == '-' as i32 {
                            re_append(p, 10 as libc::c_int, c as libc::c_int);
                            (*p).sIn.i += 1;
                            c = (*p).xNextChar.expect("non-null function pointer")(&mut (*p).sIn);
                            if c == '\\' as i32 as libc::c_uint {
                                c = re_esc_char(p)
                            }
                            re_append(p, 10 as libc::c_int, c as libc::c_int);
                        } else {
                            re_append(p, 9 as libc::c_int, c as libc::c_int);
                        }
                        if !(rePeek(p) as libc::c_int == ']' as i32) {
                            continue;
                        }
                        (*p).sIn.i += 1;
                        break;
                    }
                }
                if c == 0 as libc::c_int as libc::c_uint {
                    return b"unclosed \'[\'\x00" as *const u8 as *const libc::c_char;
                } else {
                    *(*p).aArg.offset(iFirst as isize) =
                        (*p).nState.wrapping_sub(iFirst as libc::c_uint) as libc::c_int
                }
            }
            92 => {
                let mut specialOp: libc::c_int = 0 as libc::c_int;
                match rePeek(p) as libc::c_int {
                    98 => specialOp = 17 as libc::c_int,
                    100 => specialOp = 13 as libc::c_int,
                    68 => specialOp = 14 as libc::c_int,
                    115 => specialOp = 15 as libc::c_int,
                    83 => specialOp = 16 as libc::c_int,
                    119 => specialOp = 11 as libc::c_int,
                    87 => specialOp = 12 as libc::c_int,
                    _ => {}
                }
                if specialOp != 0 {
                    (*p).sIn.i += 1;
                    re_append(p, specialOp, 0 as libc::c_int);
                } else {
                    c = re_esc_char(p);
                    re_append(p, 1 as libc::c_int, c as libc::c_int);
                }
            }
            _ => {
                re_append(p, 1 as libc::c_int, c as libc::c_int);
            }
        }
        iPrev = iStart
    }
    return 0 as *const libc::c_char;
}
/* Free and reclaim all the memory used by a previously compiled
** regular expression.  Applications should invoke this routine once
** for every call to re_compile() to avoid memory leaks.
*/
unsafe extern "C" fn sqlite3re_free(mut pRe: *mut ReCompiled) {
    if !pRe.is_null() {
        sqlite3_free((*pRe).aOp as *mut libc::c_void);
        sqlite3_free((*pRe).aArg as *mut libc::c_void);
        sqlite3_free(pRe as *mut libc::c_void);
    };
}
/*
** Compile a textual regular expression in zIn[] into a compiled regular
** expression suitable for us by re_match() and return a pointer to the
** compiled regular expression in *ppRe.  Return NULL on success or an
** error message if something goes wrong.
*/
unsafe extern "C" fn sqlite3re_compile(
    mut ppRe: *mut *mut ReCompiled,
    mut zIn: *const libc::c_char,
    mut noCase: libc::c_int,
) -> *const libc::c_char {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled;
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    *ppRe = 0 as *mut ReCompiled;
    pRe = sqlite3_malloc(::std::mem::size_of::<ReCompiled>() as libc::c_ulong as libc::c_int)
        as *mut ReCompiled;
    if pRe.is_null() {
        return b"out of memory\x00" as *const u8 as *const libc::c_char;
    } else {
        memset(
            pRe as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ReCompiled>() as libc::c_ulong,
        );
        (*pRe).xNextChar = if noCase != 0 {
            Some(re_next_char_nocase as unsafe extern "C" fn(_: *mut ReInput) -> libc::c_uint)
        } else {
            Some(re_next_char as unsafe extern "C" fn(_: *mut ReInput) -> libc::c_uint)
        };
        if re_resize(pRe, 30 as libc::c_int) != 0 {
            sqlite3re_free(pRe);
            return b"out of memory\x00" as *const u8 as *const libc::c_char;
        } else {
            if *zIn.offset(0 as libc::c_int as isize) as libc::c_int == '^' as i32 {
                zIn = zIn.offset(1)
            } else {
                re_append(pRe, 3 as libc::c_int, 0 as libc::c_int);
            }
            (*pRe).sIn.z = zIn as *mut libc::c_uchar;
            (*pRe).sIn.i = 0 as libc::c_int;
            (*pRe).sIn.mx = strlen(zIn) as libc::c_int;
            zErr = re_subcompile_re(pRe);
            if !zErr.is_null() {
                sqlite3re_free(pRe);
                return zErr;
            } else {
                if rePeek(pRe) as libc::c_int == '$' as i32
                    && (*pRe).sIn.i + 1 as libc::c_int >= (*pRe).sIn.mx
                {
                    re_append(pRe, 1 as libc::c_int, 0 as libc::c_int);
                    re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
                    *ppRe = pRe
                } else if (*pRe).sIn.i >= (*pRe).sIn.mx {
                    re_append(pRe, 6 as libc::c_int, 0 as libc::c_int);
                    *ppRe = pRe
                } else {
                    sqlite3re_free(pRe);
                    return b"unrecognized character\x00" as *const u8 as *const libc::c_char;
                }
                /* The following is a performance optimization.  If the regex begins with
                 ** ".*" (if the input regex lacks an initial "^") and afterwards there are
                 ** one or more matching characters, enter those matching characters into
                 ** zInit[].  The re_match() routine can then search ahead in the input
                 ** string looking for the initial match without having to run the whole
                 ** regex engine over the string.  Do not worry able trying to match
                 ** unicode characters beyond plane 0 - those are very rare and this is
                 ** just an optimization. */
                if *(*pRe).aOp.offset(0 as libc::c_int as isize) as libc::c_int == 3 as libc::c_int
                    && noCase == 0
                {
                    j = 0 as libc::c_int;
                    i = 1 as libc::c_int;
                    while j < ::std::mem::size_of::<[libc::c_uchar; 12]>() as libc::c_ulong
                        as libc::c_int
                        - 2 as libc::c_int
                        && *(*pRe).aOp.offset(i as isize) as libc::c_int == 1 as libc::c_int
                    {
                        let mut x: libc::c_uint = *(*pRe).aArg.offset(i as isize) as libc::c_uint;
                        if x <= 127 as libc::c_int as libc::c_uint {
                            let fresh20 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh20 as usize] = x as libc::c_uchar
                        } else if x <= 0xfff as libc::c_int as libc::c_uint {
                            let fresh21 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh21 as usize] = (0xc0 as libc::c_int as libc::c_uint
                                | x >> 6 as libc::c_int)
                                as libc::c_uchar;
                            let fresh22 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh22 as usize] = (0x80 as libc::c_int as libc::c_uint
                                | x & 0x3f as libc::c_int as libc::c_uint)
                                as libc::c_uchar
                        } else {
                            if !(x <= 0xffff as libc::c_int as libc::c_uint) {
                                break;
                            }
                            let fresh23 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh23 as usize] = (0xd0 as libc::c_int as libc::c_uint
                                | x >> 12 as libc::c_int)
                                as libc::c_uchar;
                            let fresh24 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh24 as usize] = (0x80 as libc::c_int as libc::c_uint
                                | x >> 6 as libc::c_int & 0x3f as libc::c_int as libc::c_uint)
                                as libc::c_uchar;
                            let fresh25 = j;
                            j = j + 1;
                            (*pRe).zInit[fresh25 as usize] = (0x80 as libc::c_int as libc::c_uint
                                | x & 0x3f as libc::c_int as libc::c_uint)
                                as libc::c_uchar
                        }
                        i += 1
                    }
                    if j > 0 as libc::c_int
                        && (*pRe).zInit[(j - 1 as libc::c_int) as usize] as libc::c_int
                            == 0 as libc::c_int
                    {
                        j -= 1
                    }
                    (*pRe).nInit = j
                }
                return (*pRe).zErr;
            }
        }
    };
}
/*
** Implementation of the regexp() SQL function.  This function implements
** the build-in REGEXP operator.  The first argument to the function is the
** pattern and the second argument is the string.  So, the SQL statements:
**
**       A REGEXP B
**
** is implemented as regexp(B,A).
*/
unsafe extern "C" fn re_sql_func(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pRe: *mut ReCompiled = 0 as *mut ReCompiled; /* Compiled regular expression */
    let mut zPattern: *const libc::c_char = 0 as *const libc::c_char; /* The regular expression */
    let mut zStr: *const libc::c_uchar = 0 as *const libc::c_uchar; /* String being searched */
    let mut zErr: *const libc::c_char = 0 as *const libc::c_char; /* Compile error message */
    let mut setAux: libc::c_int = 0 as libc::c_int; /* True to invoke sqlite3_set_auxdata() */
    pRe = sqlite3_get_auxdata(context, 0 as libc::c_int) as *mut ReCompiled; /* Unused */
    if pRe.is_null() {
        zPattern =
            sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
        if zPattern.is_null() {
            return;
        } else {
            zErr = sqlite3re_compile(
                &mut pRe,
                zPattern,
                (sqlite3_user_data(context) != 0 as *mut libc::c_void) as libc::c_int,
            );
            if !zErr.is_null() {
                sqlite3re_free(pRe);
                sqlite3_result_error(context, zErr, -(1 as libc::c_int));
                return;
            } else if pRe.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            } else {
                setAux = 1 as libc::c_int
            }
        }
    }
    zStr = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize));
    if !zStr.is_null() {
        sqlite3_result_int(context, sqlite3re_match(pRe, zStr, -(1 as libc::c_int)));
    }
    if setAux != 0 {
        sqlite3_set_auxdata(
            context,
            0 as libc::c_int,
            pRe as *mut libc::c_void,
            ::std::mem::transmute::<
                Option<unsafe extern "C" fn(_: *mut ReCompiled) -> ()>,
                Option<unsafe extern "C" fn(_: *mut libc::c_void) -> ()>,
            >(Some(
                sqlite3re_free as unsafe extern "C" fn(_: *mut ReCompiled) -> (),
            )),
        );
    };
}
/*
** Invoke this routine to register the regexp() function with the
** SQLite database connection.
*/
pub unsafe extern "C" fn sqlite3_regexp_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int; /* Unused */
    rc = sqlite3_create_function(
        db,
        b"regexp\x00" as *const u8 as *const libc::c_char,
        2 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            re_sql_func
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        /* The regexpi(PATTERN,STRING) function is a case-insensitive version
         ** of regexp(PATTERN,STRING). */
        rc = sqlite3_create_function(
            db,
            b"regexpi\x00" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int,
            db as *mut libc::c_void,
            Some(
                re_sql_func
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    return rc;
}
/* SQLITE_AMALGAMATION */
/*
** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
**
** In some ways it would be better to obtain these values from system
** header files. But, the dependency is undesirable and (a) these
** have been stable for decades, (b) the values are part of POSIX and
** are also made explicit in [man stat], and (c) are part of the
** file format for zip archives.
*/
static mut ZIPFILE_SCHEMA: [libc::c_char; 91] = unsafe {
    *::std::mem::transmute::<&[u8; 91],
                                 &[libc::c_char; 91]>(b"CREATE TABLE y(name PRIMARY KEY,mode,mtime,sz,rawdata,data,method,z HIDDEN) WITHOUT ROWID;\x00")
};
/* Size of archive at start of transaction */
/*
** Set the error message contained in context ctx to the results of
** vprintf(zFmt, ...).
*/
unsafe extern "C" fn zipfileCtxErrorMsg(
    mut ctx: *mut sqlite3_context,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    zMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
    sqlite3_result_error(ctx, zMsg, -(1 as libc::c_int));
    sqlite3_free(zMsg as *mut libc::c_void);
}
/*
** If string zIn is quoted, dequote it in place. Otherwise, if the string
** is not quoted, do nothing.
*/
unsafe extern "C" fn zipfileDequote(mut zIn: *mut libc::c_char) {
    let mut q: libc::c_char = *zIn.offset(0 as libc::c_int as isize);
    if q as libc::c_int == '\"' as i32
        || q as libc::c_int == '\'' as i32
        || q as libc::c_int == '`' as i32
        || q as libc::c_int == '[' as i32
    {
        let mut iIn: libc::c_int = 1 as libc::c_int;
        let mut iOut: libc::c_int = 0 as libc::c_int;
        if q as libc::c_int == '[' as i32 {
            q = ']' as i32 as libc::c_char
        }
        while *zIn.offset(iIn as isize) != 0 {
            let fresh26 = iIn;
            iIn = iIn + 1;
            let mut c: libc::c_char = *zIn.offset(fresh26 as isize);
            if c as libc::c_int == q as libc::c_int && {
                let fresh27 = iIn;
                iIn = iIn + 1;
                (*zIn.offset(fresh27 as isize) as libc::c_int) != q as libc::c_int
            } {
                break;
            }
            let fresh28 = iOut;
            iOut = iOut + 1;
            *zIn.offset(fresh28 as isize) = c
        }
        *zIn.offset(iOut as isize) = '\u{0}' as i32 as libc::c_char
    };
}
/*
** Construct a new ZipfileTab virtual table object.
**
**   argv[0]   -> module name  ("zipfile")
**   argv[1]   -> database name
**   argv[2]   -> table name
**   argv[...] -> "column name" and other module argument fields.
*/
unsafe extern "C" fn zipfileConnect(
    mut db: *mut sqlite3,
    mut _pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut nByte: libc::c_int = (::std::mem::size_of::<ZipfileTab>() as libc::c_ulong)
        .wrapping_add((64 as libc::c_int * 1024 as libc::c_int) as libc::c_ulong)
        as libc::c_int;
    let mut nFile: libc::c_int = 0 as libc::c_int;
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut pNew: *mut ZipfileTab = 0 as *mut ZipfileTab;
    let mut rc: libc::c_int = 0;
    /* If the table name is not "zipfile", require that the argument be
     ** specified. This stops zipfile tables from being created as:
     **
     **   CREATE VIRTUAL TABLE zzz USING zipfile();
     **
     ** It does not prevent:
     **
     **   CREATE VIRTUAL TABLE zipfile USING zipfile();
     */
    if 0 as libc::c_int
        != sqlite3_stricmp(
            *argv.offset(2 as libc::c_int as isize),
            b"zipfile\x00" as *const u8 as *const libc::c_char,
        )
        && argc < 4 as libc::c_int
        || argc > 4 as libc::c_int
    {
        *pzErr = sqlite3_mprintf(
            b"zipfile constructor requires one argument\x00" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else {
        if argc > 3 as libc::c_int {
            zFile = *argv.offset(3 as libc::c_int as isize);
            nFile = strlen(zFile) as libc::c_int + 1 as libc::c_int
        }
        rc = sqlite3_declare_vtab(db, ZIPFILE_SCHEMA.as_ptr());
        if rc == 0 as libc::c_int {
            pNew = sqlite3_malloc64(
                (nByte as sqlite3_int64 + nFile as libc::c_longlong) as sqlite3_uint64,
            ) as *mut ZipfileTab;
            if pNew.is_null() {
                return 7 as libc::c_int;
            } else {
                memset(
                    pNew as *mut libc::c_void,
                    0 as libc::c_int,
                    (nByte + nFile) as libc::c_ulong,
                );
                (*pNew).db = db;
                (*pNew).aBuffer =
                    &mut *pNew.offset(1 as libc::c_int as isize) as *mut ZipfileTab as *mut u8_0;
                if !zFile.is_null() {
                    (*pNew).zFile = &mut *(*pNew)
                        .aBuffer
                        .offset((64 as libc::c_int * 1024 as libc::c_int) as isize)
                        as *mut u8_0 as *mut libc::c_char;
                    memcpy(
                        (*pNew).zFile as *mut libc::c_void,
                        zFile as *const libc::c_void,
                        nFile as libc::c_ulong,
                    );
                    zipfileDequote((*pNew).zFile);
                }
            }
        }
        sqlite3_vtab_config(db, 3 as libc::c_int);
        *ppVtab = pNew as *mut sqlite3_vtab;
        return rc;
    };
}
/*
** Free the ZipfileEntry structure indicated by the only argument.
*/
unsafe extern "C" fn zipfileEntryFree(mut p: *mut ZipfileEntry) {
    if !p.is_null() {
        sqlite3_free((*p).cds.zFile as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    };
}
/*
** Release resources that should be freed at the end of a write
** transaction.
*/
unsafe extern "C" fn zipfileCleanupTransaction(mut pTab: *mut ZipfileTab) {
    let mut pEntry: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    if !(*pTab).pWriteFd.is_null() {
        fclose((*pTab).pWriteFd);
        (*pTab).pWriteFd = 0 as *mut FILE
    }
    pEntry = (*pTab).pFirstEntry;
    while !pEntry.is_null() {
        pNext = (*pEntry).pNext;
        zipfileEntryFree(pEntry);
        pEntry = pNext
    }
    (*pTab).pFirstEntry = 0 as *mut ZipfileEntry;
    (*pTab).pLastEntry = 0 as *mut ZipfileEntry;
    (*pTab).szCurrent = 0 as libc::c_int as i64_0;
    (*pTab).szOrig = 0 as libc::c_int as i64_0;
}
/*
** This method is the destructor for zipfile vtab objects.
*/
unsafe extern "C" fn zipfileDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    zipfileCleanupTransaction(pVtab as *mut ZipfileTab);
    sqlite3_free(pVtab as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Constructor for a new ZipfileCsr object.
*/
unsafe extern "C" fn zipfileOpen(
    mut p: *mut sqlite3_vtab,
    mut ppCsr: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = p as *mut ZipfileTab;
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = sqlite3_malloc(::std::mem::size_of::<ZipfileCsr>() as libc::c_ulong as libc::c_int)
        as *mut ZipfileCsr;
    *ppCsr = pCsr as *mut sqlite3_vtab_cursor;
    if pCsr.is_null() {
        return 7 as libc::c_int;
    } else {
        memset(
            pCsr as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ZipfileCsr>() as libc::c_ulong,
        );
        (*pTab).iNextCsrid += 1;
        (*pCsr).iId = (*pTab).iNextCsrid;
        (*pCsr).pCsrNext = (*pTab).pCsrList;
        (*pTab).pCsrList = pCsr;
        return 0 as libc::c_int;
    };
}
/*
** Reset a cursor back to the state it was in when first returned
** by zipfileOpen().
*/
unsafe extern "C" fn zipfileResetCursor(mut pCsr: *mut ZipfileCsr) {
    let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pNext: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    (*pCsr).bEof = 0 as libc::c_int as u8_0;
    if !(*pCsr).pFile.is_null() {
        fclose((*pCsr).pFile);
        (*pCsr).pFile = 0 as *mut FILE;
        zipfileEntryFree((*pCsr).pCurrent);
        (*pCsr).pCurrent = 0 as *mut ZipfileEntry
    }
    p = (*pCsr).pFreeEntry;
    while !p.is_null() {
        pNext = (*p).pNext;
        zipfileEntryFree(p);
        p = pNext
    }
}
/*
** Destructor for an ZipfileCsr.
*/
unsafe extern "C" fn zipfileClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut pTab: *mut ZipfileTab = (*pCsr).base.pVtab as *mut ZipfileTab;
    let mut pp: *mut *mut ZipfileCsr = 0 as *mut *mut ZipfileCsr;
    zipfileResetCursor(pCsr);
    /* Remove this cursor from the ZipfileTab.pCsrList list. */
    pp = &mut (*pTab).pCsrList;
    while *pp != pCsr {
        pp = &mut (**pp).pCsrNext
    }
    *pp = (*pCsr).pCsrNext;
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Set the error message for the virtual table associated with cursor
** pCsr to the results of vprintf(zFmt, ...).
*/
unsafe extern "C" fn zipfileTableErr(
    mut pTab: *mut ZipfileTab,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*pTab).base.zErrMsg as *mut libc::c_void);
    (*pTab).base.zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
unsafe extern "C" fn zipfileCursorErr(
    mut pCsr: *mut ZipfileCsr,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    sqlite3_free((*(*pCsr).base.pVtab).zErrMsg as *mut libc::c_void);
    (*(*pCsr).base.pVtab).zErrMsg = sqlite3_vmprintf(zFmt, ap.as_va_list());
}
/*
** Read nRead bytes of data from offset iOff of file pFile into buffer
** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
** otherwise.
**
** If an error does occur, output variable (*pzErrmsg) may be set to point
** to an English language error message. It is the responsibility of the
** caller to eventually free this buffer using
** sqlite3_free().
*/
unsafe extern "C" fn zipfileReadData(
    mut pFile: *mut FILE,
    mut aRead: *mut u8_0,
    mut nRead: libc::c_int,
    mut iOff: i64_0,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message (from sqlite3_malloc) */ {
    let mut n: size_t = 0;
    fseek(pFile, iOff as libc::c_long, 0 as libc::c_int);
    n = fread(
        aRead as *mut libc::c_void,
        1 as libc::c_int as libc::c_ulong,
        nRead as libc::c_ulong,
        pFile,
    );
    if n as libc::c_int != nRead {
        *pzErrmsg = sqlite3_mprintf(b"error in fread()\x00" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn zipfileAppendData(
    mut pTab: *mut ZipfileTab,
    mut aWrite: *const u8_0,
    mut nWrite: libc::c_int,
) -> libc::c_int {
    if nWrite > 0 as libc::c_int {
        let mut n: size_t = nWrite as size_t;
        fseek(
            (*pTab).pWriteFd,
            (*pTab).szCurrent as libc::c_long,
            0 as libc::c_int,
        );
        n = fwrite(
            aWrite as *const libc::c_void,
            1 as libc::c_int as libc::c_ulong,
            nWrite as libc::c_ulong,
            (*pTab).pWriteFd,
        );
        if n as libc::c_int != nWrite {
            (*pTab).base.zErrMsg =
                sqlite3_mprintf(b"error in fwrite()\x00" as *const u8 as *const libc::c_char);
            return 1 as libc::c_int;
        } else {
            (*pTab).szCurrent += nWrite as libc::c_longlong
        }
    }
    return 0 as libc::c_int;
}
/*
** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
*/
unsafe extern "C" fn zipfileGetU16(mut aBuf: *const u8_0) -> u16_0 {
    return (((*aBuf.offset(1 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *aBuf.offset(0 as libc::c_int as isize) as libc::c_int) as u16_0;
}
/*
** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
*/
unsafe extern "C" fn zipfileGetU32(mut aBuf: *const u8_0) -> u32_0 {
    if aBuf.is_null() {
        return 0 as libc::c_int as u32_0;
    } else {
        return ((*aBuf.offset(3 as libc::c_int as isize) as u32_0) << 24 as libc::c_int)
            .wrapping_add((*aBuf.offset(2 as libc::c_int as isize) as u32_0) << 16 as libc::c_int)
            .wrapping_add((*aBuf.offset(1 as libc::c_int as isize) as u32_0) << 8 as libc::c_int)
            .wrapping_add((*aBuf.offset(0 as libc::c_int as isize) as u32_0) << 0 as libc::c_int);
    };
}
/*
** Write a 16-bit little endiate integer into buffer aBuf.
*/
unsafe extern "C" fn zipfilePutU16(mut aBuf: *mut u8_0, mut val: u16_0) {
    *aBuf.offset(0 as libc::c_int as isize) = (val as libc::c_int & 0xff as libc::c_int) as u8_0;
    *aBuf.offset(1 as libc::c_int as isize) =
        (val as libc::c_int >> 8 as libc::c_int & 0xff as libc::c_int) as u8_0;
}
/*
** Write a 32-bit little endiate integer into buffer aBuf.
*/
unsafe extern "C" fn zipfilePutU32(mut aBuf: *mut u8_0, mut val: u32_0) {
    *aBuf.offset(0 as libc::c_int as isize) = (val & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf.offset(1 as libc::c_int as isize) =
        (val >> 8 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf.offset(2 as libc::c_int as isize) =
        (val >> 16 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
    *aBuf.offset(3 as libc::c_int as isize) =
        (val >> 24 as libc::c_int & 0xff as libc::c_int as libc::c_uint) as u8_0;
}
/*
** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/
unsafe extern "C" fn zipfileReadCDS(mut aBuf: *mut u8_0, mut pCDS: *mut ZipfileCDS) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuf;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let mut sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    let mut rc: libc::c_int = 0 as libc::c_int;
    if sig != 0x2014b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iVersionMadeBy = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).nComment = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iDiskStart = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pCDS).iInternalAttr = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).iExternalAttr = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pCDS).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)))
    }
    return rc;
}
/*
** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
** if the record is not well-formed, or SQLITE_OK otherwise.
*/
unsafe extern "C" fn zipfileReadLFH(
    mut aBuffer: *mut u8_0,
    mut pLFH: *mut ZipfileLFH,
) -> libc::c_int {
    let mut aRead: *mut u8_0 = aBuffer;
    let mut rc: libc::c_int = 0 as libc::c_int;
    aRead = aRead.offset(4 as libc::c_int as isize);
    let mut sig: u32_0 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
    if sig != 0x4034b50 as libc::c_int as libc::c_uint {
        rc = 1 as libc::c_int
    } else {
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).iVersionExtract = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).flags = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).iCompression = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mTime = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).mDate = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).crc32 = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).szCompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(4 as libc::c_int as isize);
        (*pLFH).szUncompressed = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nFile = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
        aRead = aRead.offset(2 as libc::c_int as isize);
        (*pLFH).nExtra = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)))
    }
    return rc;
}
/*
** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
** Scan through this buffer to find an "extra-timestamp" field. If one
** exists, extract the 32-bit modification-timestamp from it and store
** the value in output parameter *pmTime.
**
** Zero is returned if no extra-timestamp record could be found (and so
** *pmTime is left unchanged), or non-zero otherwise.
**
** The general format of an extra field is:
**
**   Header ID    2 bytes
**   Data Size    2 bytes
**   Data         N bytes
*/
unsafe extern "C" fn zipfileScanExtra(
    mut aExtra: *mut u8_0,
    mut nExtra: libc::c_int,
    mut pmTime: *mut u32_0,
) -> libc::c_int {
    let mut ret: libc::c_int = 0 as libc::c_int;
    let mut p: *mut u8_0 = aExtra;
    let mut pEnd: *mut u8_0 = &mut *aExtra.offset(nExtra as isize) as *mut u8_0;
    while p < pEnd {
        p = p.offset(2 as libc::c_int as isize);
        let mut id: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        p = p.offset(2 as libc::c_int as isize);
        let mut nByte: u16_0 = zipfileGetU16(p.offset(-(2 as libc::c_int as isize)));
        match id as libc::c_int {
            21589 => {
                let mut b: u8_0 = *p.offset(0 as libc::c_int as isize);
                if b as libc::c_int & 0x1 as libc::c_int != 0 {
                    /* 0x01 -> modtime is present */
                    *pmTime = zipfileGetU32(&mut *p.offset(1 as libc::c_int as isize));
                    ret = 1 as libc::c_int
                }
            }
            _ => {}
        }
        p = p.offset(nByte as libc::c_int as isize)
    }
    return ret;
}
/*
** Convert the standard MS-DOS timestamp stored in the mTime and mDate
** fields of the CDS structure passed as the only argument to a 32-bit
** UNIX seconds-since-the-epoch timestamp. Return the result.
**
** "Standard" MS-DOS time format:
**
**   File modification time:
**     Bits 00-04: seconds divided by 2
**     Bits 05-10: minute
**     Bits 11-15: hour
**   File modification date:
**     Bits 00-04: day
**     Bits 05-08: month (1-12)
**     Bits 09-15: years from 1980
**
** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
*/
unsafe extern "C" fn zipfileMtime(mut pCDS: *mut ZipfileCDS) -> u32_0 {
    let mut Y: libc::c_int = 0;
    let mut M: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut X1: libc::c_int = 0;
    let mut X2: libc::c_int = 0;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut JDsec: i64_0 = 0;
    Y = 1980 as libc::c_int
        + ((*pCDS).mDate as libc::c_int >> 9 as libc::c_int & 0x7f as libc::c_int);
    M = (*pCDS).mDate as libc::c_int >> 5 as libc::c_int & 0xf as libc::c_int;
    D = (*pCDS).mDate as libc::c_int & 0x1f as libc::c_int;
    sec = ((*pCDS).mTime as libc::c_int & 0x1f as libc::c_int) * 2 as libc::c_int;
    min = (*pCDS).mTime as libc::c_int >> 5 as libc::c_int & 0x3f as libc::c_int;
    hr = (*pCDS).mTime as libc::c_int >> 11 as libc::c_int & 0x1f as libc::c_int;
    if M <= 2 as libc::c_int {
        Y -= 1;
        M += 12 as libc::c_int
    }
    X1 = 36525 as libc::c_int * (Y + 4716 as libc::c_int) / 100 as libc::c_int;
    X2 = 306001 as libc::c_int * (M + 1 as libc::c_int) / 10000 as libc::c_int;
    A = Y / 100 as libc::c_int;
    B = 2 as libc::c_int - A + A / 4 as libc::c_int;
    JDsec = (((X1 + X2 + D + B) as libc::c_double - 1524.5f64)
        * 86400 as libc::c_int as libc::c_double) as i64_0
        + (hr * 3600 as libc::c_int) as libc::c_longlong
        + (min * 60 as libc::c_int) as libc::c_longlong
        + sec as libc::c_longlong;
    return (JDsec - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as i64_0) as u32_0;
}
/*
** The opposite of zipfileMtime(). This function populates the mTime and
** mDate fields of the CDS structure passed as the first argument according
** to the UNIX timestamp value passed as the second.
*/
unsafe extern "C" fn zipfileMtimeToDos(mut pCds: *mut ZipfileCDS, mut mUnixTime: u32_0) {
    /* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */
    let mut JD: i64_0 = 2440588 as libc::c_int as i64_0
        + mUnixTime.wrapping_div(
            (24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int) as libc::c_uint,
        ) as libc::c_longlong;
    let mut A: libc::c_int = 0;
    let mut B: libc::c_int = 0;
    let mut C: libc::c_int = 0;
    let mut D: libc::c_int = 0;
    let mut E: libc::c_int = 0;
    let mut yr: libc::c_int = 0;
    let mut mon: libc::c_int = 0;
    let mut day: libc::c_int = 0;
    let mut hr: libc::c_int = 0;
    let mut min: libc::c_int = 0;
    let mut sec: libc::c_int = 0;
    A = ((JD as libc::c_double - 1867216.25f64) / 36524.25f64) as libc::c_int;
    A = (JD + 1 as libc::c_int as libc::c_longlong + A as libc::c_longlong
        - (A / 4 as libc::c_int) as libc::c_longlong) as libc::c_int;
    B = A + 1524 as libc::c_int;
    C = ((B as libc::c_double - 122.1f64) / 365.25f64) as libc::c_int;
    D = 36525 as libc::c_int * (C & 32767 as libc::c_int) / 100 as libc::c_int;
    E = ((B - D) as libc::c_double / 30.6001f64) as libc::c_int;
    day = B - D - (30.6001f64 * E as libc::c_double) as libc::c_int;
    mon = if E < 14 as libc::c_int {
        (E) - 1 as libc::c_int
    } else {
        (E) - 13 as libc::c_int
    };
    yr = if mon > 2 as libc::c_int {
        (C) - 4716 as libc::c_int
    } else {
        (C) - 4715 as libc::c_int
    };
    hr = mUnixTime
        .wrapping_rem((24 as libc::c_int * 60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        .wrapping_div((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        as libc::c_int;
    min = mUnixTime
        .wrapping_rem((60 as libc::c_int * 60 as libc::c_int) as libc::c_uint)
        .wrapping_div(60 as libc::c_int as libc::c_uint) as libc::c_int;
    sec = mUnixTime.wrapping_rem(60 as libc::c_int as libc::c_uint) as libc::c_int;
    if yr >= 1980 as libc::c_int {
        (*pCds).mDate = (day
            + (mon << 5 as libc::c_int)
            + ((yr - 1980 as libc::c_int) << 9 as libc::c_int)) as u16_0;
        (*pCds).mTime = (sec / 2 as libc::c_int
            + (min << 5 as libc::c_int)
            + (hr << 11 as libc::c_int)) as u16_0
    } else {
        (*pCds).mTime = 0 as libc::c_int as u16_0;
        (*pCds).mDate = (*pCds).mTime
    };
    /* || (mUnixTime % 2) */
}
/*
** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
** size) containing an entire zip archive image. Or, if aBlob is NULL,
** then pFile is a file-handle open on a zip file. In either case, this
** function creates a ZipfileEntry object based on the zip archive entry
** for which the CDS record is at offset iOff.
**
** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
** the new object. Otherwise, an SQLite error code is returned and the
** final value of (*ppEntry) undefined.
*/
unsafe extern "C" fn zipfileGetEntry(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut _nBlob: libc::c_int,
    mut pFile: *mut FILE,
    mut iOff: i64_0,
    mut ppEntry: *mut *mut ZipfileEntry,
) -> libc::c_int
/* OUT: Pointer to new object */ {
    let mut aRead: *mut u8_0 = 0 as *mut u8_0;
    let mut pzErr: *mut *mut libc::c_char = &mut (*pTab).base.zErrMsg;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if aBlob.is_null() {
        aRead = (*pTab).aBuffer;
        rc = zipfileReadData(pFile, aRead, 46 as libc::c_int, iOff, pzErr)
    } else {
        aRead = &*aBlob.offset(iOff as isize) as *const u8_0 as *mut u8_0
    }
    if rc == 0 as libc::c_int {
        let mut nAlloc: sqlite3_int64 = 0;
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let mut nFile: libc::c_int =
            zipfileGetU16(&mut *aRead.offset(28 as libc::c_int as isize)) as libc::c_int;
        let mut nExtra: libc::c_int =
            zipfileGetU16(&mut *aRead.offset((28 as libc::c_int + 2 as libc::c_int) as isize))
                as libc::c_int;
        nExtra += zipfileGetU16(&mut *aRead.offset((28 as libc::c_int + 4 as libc::c_int) as isize))
            as libc::c_int;
        nAlloc = (::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong)
            .wrapping_add(nExtra as libc::c_ulong) as sqlite3_int64;
        if !aBlob.is_null() {
            nAlloc +=
                zipfileGetU32(&mut *aRead.offset(20 as libc::c_int as isize)) as libc::c_longlong
        }
        pNew = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut ZipfileEntry;
        if pNew.is_null() {
            rc = 7 as libc::c_int
        } else {
            memset(
                pNew as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
            );
            rc = zipfileReadCDS(aRead, &mut (*pNew).cds);
            if rc != 0 as libc::c_int {
                *pzErr = sqlite3_mprintf(
                    b"failed to read CDS at offset %lld\x00" as *const u8 as *const libc::c_char,
                    iOff,
                )
            } else if aBlob.is_null() {
                rc = zipfileReadData(
                    pFile,
                    aRead,
                    nExtra + nFile,
                    iOff + 46 as libc::c_int as libc::c_longlong,
                    pzErr,
                )
            } else {
                aRead = &*aBlob.offset((iOff + 46 as libc::c_int as libc::c_longlong) as isize)
                    as *const u8_0 as *mut u8_0
            }
        }
        if rc == 0 as libc::c_int {
            let mut pt: *mut u32_0 = &mut (*pNew).mUnixTime;
            (*pNew).cds.zFile = sqlite3_mprintf(
                b"%.*s\x00" as *const u8 as *const libc::c_char,
                nFile,
                aRead,
            );
            (*pNew).aExtra =
                &mut *pNew.offset(1 as libc::c_int as isize) as *mut ZipfileEntry as *mut u8_0;
            memcpy(
                (*pNew).aExtra as *mut libc::c_void,
                &mut *aRead.offset(nFile as isize) as *mut u8_0 as *const libc::c_void,
                nExtra as libc::c_ulong,
            );
            if (*pNew).cds.zFile.is_null() {
                rc = 7 as libc::c_int
            } else if 0 as libc::c_int
                == zipfileScanExtra(
                    &mut *aRead.offset(nFile as isize),
                    (*pNew).cds.nExtra as libc::c_int,
                    pt,
                )
            {
                (*pNew).mUnixTime = zipfileMtime(&mut (*pNew).cds)
            }
        }
        if rc == 0 as libc::c_int {
            static mut szFix: libc::c_int = 30 as libc::c_int;
            let mut lfh: ZipfileLFH = ZipfileLFH {
                iVersionExtract: 0,
                flags: 0,
                iCompression: 0,
                mTime: 0,
                mDate: 0,
                crc32: 0,
                szCompressed: 0,
                szUncompressed: 0,
                nFile: 0,
                nExtra: 0,
            };
            if !pFile.is_null() {
                rc = zipfileReadData(pFile, aRead, szFix, (*pNew).cds.iOffset as i64_0, pzErr)
            } else {
                aRead = &*aBlob.offset((*pNew).cds.iOffset as isize) as *const u8_0 as *mut u8_0
            }
            if rc == 0 as libc::c_int {
                rc = zipfileReadLFH(aRead, &mut lfh)
            }
            if rc == 0 as libc::c_int {
                (*pNew).iDataOff = (*pNew)
                    .cds
                    .iOffset
                    .wrapping_add(30 as libc::c_int as libc::c_uint)
                    as i64_0;
                (*pNew).iDataOff +=
                    (lfh.nFile as libc::c_int + lfh.nExtra as libc::c_int) as libc::c_longlong;
                if !aBlob.is_null() && (*pNew).cds.szCompressed != 0 {
                    (*pNew).aData = &mut *(*pNew).aExtra.offset(nExtra as isize) as *mut u8_0;
                    memcpy(
                        (*pNew).aData as *mut libc::c_void,
                        &*aBlob.offset((*pNew).iDataOff as isize) as *const u8_0
                            as *const libc::c_void,
                        (*pNew).cds.szCompressed as libc::c_ulong,
                    );
                }
            } else {
                *pzErr = sqlite3_mprintf(
                    b"failed to read LFH at offset %d\x00" as *const u8 as *const libc::c_char,
                    (*pNew).cds.iOffset as libc::c_int,
                )
            }
        }
        if rc != 0 as libc::c_int {
            zipfileEntryFree(pNew);
        } else {
            *ppEntry = pNew
        }
    }
    return rc;
}
/*
** Advance an ZipfileCsr to its next row of output.
*/
unsafe extern "C" fn zipfileNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !(*pCsr).pFile.is_null() {
        let mut iEof: i64_0 = (*pCsr).eocd.iOffset.wrapping_add((*pCsr).eocd.nSize) as i64_0;
        zipfileEntryFree((*pCsr).pCurrent);
        (*pCsr).pCurrent = 0 as *mut ZipfileEntry;
        if (*pCsr).iNextOff >= iEof {
            (*pCsr).bEof = 1 as libc::c_int as u8_0
        } else {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            let mut pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab;
            rc = zipfileGetEntry(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                (*pCsr).iNextOff,
                &mut p,
            );
            if rc == 0 as libc::c_int {
                (*pCsr).iNextOff += 46 as libc::c_int as libc::c_longlong;
                (*pCsr).iNextOff += ((*p).cds.nExtra as libc::c_int
                    + (*p).cds.nFile as libc::c_int
                    + (*p).cds.nComment as libc::c_int)
                    as libc::c_longlong
            }
            (*pCsr).pCurrent = p
        }
    } else {
        if (*pCsr).bNoop == 0 {
            (*pCsr).pCurrent = (*(*pCsr).pCurrent).pNext
        }
        if (*pCsr).pCurrent.is_null() {
            (*pCsr).bEof = 1 as libc::c_int as u8_0
        }
    }
    (*pCsr).bNoop = 0 as libc::c_int as u8_0;
    return rc;
}
unsafe extern "C" fn zipfileFree(mut p: *mut libc::c_void) {
    sqlite3_free(p);
}
/*
** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
** size is nOut bytes. This function uncompresses the data and sets the
** return value in context pCtx to the result (a blob).
**
** If an error occurs, an error code is left in pCtx instead.
*/
unsafe extern "C" fn zipfileInflate(
    mut pCtx: *mut sqlite3_context,
    mut aIn: *const u8_0,
    mut nIn: libc::c_int,
    mut nOut: libc::c_int,
)
/* Expected output size */
{
    let mut aRes: *mut u8_0 = sqlite3_malloc(nOut) as *mut u8_0;
    if aRes.is_null() {
        sqlite3_result_error_nomem(pCtx);
    } else {
        let mut err: libc::c_int = 0;
        let mut str: z_stream = z_stream {
            next_in: 0 as *mut Bytef,
            avail_in: 0,
            total_in: 0,
            next_out: 0 as *mut Bytef,
            avail_out: 0,
            total_out: 0,
            msg: 0 as *mut libc::c_char,
            state: 0 as *mut internal_state,
            zalloc: None,
            zfree: None,
            opaque: 0 as *mut libc::c_void,
            data_type: 0,
            adler: 0,
            reserved: 0,
        };
        memset(
            &mut str as *mut z_stream as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<z_stream>() as libc::c_ulong,
        );
        str.next_in = aIn as *mut Byte;
        str.avail_in = nIn as uInt;
        str.next_out = aRes as *mut Byte;
        str.avail_out = nOut as uInt;
        err = inflateInit2_(
            &mut str,
            -(15 as libc::c_int),
            b"1.2.11\x00" as *const u8 as *const libc::c_char,
            ::std::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
        );
        if err != 0 as libc::c_int {
            zipfileCtxErrorMsg(
                pCtx,
                b"inflateInit2() failed (%d)\x00" as *const u8 as *const libc::c_char,
                err,
            );
        } else {
            err = inflate(&mut str, 0 as libc::c_int);
            if err != 1 as libc::c_int {
                zipfileCtxErrorMsg(
                    pCtx,
                    b"inflate() failed (%d)\x00" as *const u8 as *const libc::c_char,
                    err,
                );
            } else {
                sqlite3_result_blob(
                    pCtx,
                    aRes as *const libc::c_void,
                    nOut,
                    Some(zipfileFree as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
                );
                aRes = 0 as *mut u8_0
            }
        }
        sqlite3_free(aRes as *mut libc::c_void);
        inflateEnd(&mut str);
    };
}
/*
** Buffer aIn (size nIn bytes) contains uncompressed data. This function
** compresses it and sets (*ppOut) to point to a buffer containing the
** compressed data. The caller is responsible for eventually calling
** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut)
** is set to the size of buffer (*ppOut) in bytes.
**
** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
** code is returned and an error message left in virtual-table handle
** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
** case.
*/
unsafe extern "C" fn zipfileDeflate(
    mut aIn: *const u8_0,
    mut nIn: libc::c_int,
    mut ppOut: *mut *mut u8_0,
    mut pnOut: *mut libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message */ {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: sqlite3_int64 = 0;
    let mut str: z_stream = z_stream {
        next_in: 0 as *mut Bytef,
        avail_in: 0,
        total_in: 0,
        next_out: 0 as *mut Bytef,
        avail_out: 0,
        total_out: 0,
        msg: 0 as *mut libc::c_char,
        state: 0 as *mut internal_state,
        zalloc: None,
        zfree: None,
        opaque: 0 as *mut libc::c_void,
        data_type: 0,
        adler: 0,
        reserved: 0,
    };
    let mut aOut: *mut u8_0 = 0 as *mut u8_0;
    memset(
        &mut str as *mut z_stream as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<z_stream>() as libc::c_ulong,
    );
    str.next_in = aIn as *mut Bytef;
    str.avail_in = nIn as uInt;
    deflateInit2_(
        &mut str,
        9 as libc::c_int,
        8 as libc::c_int,
        -(15 as libc::c_int),
        8 as libc::c_int,
        0 as libc::c_int,
        b"1.2.11\x00" as *const u8 as *const libc::c_char,
        ::std::mem::size_of::<z_stream>() as libc::c_ulong as libc::c_int,
    );
    nAlloc = deflateBound(&mut str, nIn as uLong) as sqlite3_int64;
    aOut = sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut u8_0;
    if aOut.is_null() {
        rc = 7 as libc::c_int
    } else {
        let mut res: libc::c_int = 0;
        str.next_out = aOut;
        str.avail_out = nAlloc as uInt;
        res = deflate(&mut str, 4 as libc::c_int);
        if res == 1 as libc::c_int {
            *ppOut = aOut;
            *pnOut = str.total_out as libc::c_int
        } else {
            sqlite3_free(aOut as *mut libc::c_void);
            *pzErr = sqlite3_mprintf(
                b"zipfile: deflate() error\x00" as *const u8 as *const libc::c_char,
            );
            rc = 1 as libc::c_int
        }
        deflateEnd(&mut str);
    }
    return rc;
}
/*
** Return values of columns for the row at which the series_cursor
** is currently pointing.
*/
unsafe extern "C" fn zipfileColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int
/* Which column to return */ {
    let mut current_block: u64;
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    let mut pCDS: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
    let mut rc: libc::c_int = 0 as libc::c_int;
    match i {
        0 => {
            /* name */
            sqlite3_result_text(
                ctx,
                (*pCDS).zFile,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
            current_block = 5330834795799507926;
        }
        1 => {
            /* mode */
            /* TODO: Whether or not the following is correct surely depends on
             ** the platform on which the archive was created.  */
            sqlite3_result_int(
                ctx,
                ((*pCDS).iExternalAttr >> 16 as libc::c_int) as libc::c_int,
            );
            current_block = 5330834795799507926;
        }
        2 => {
            /* mtime */
            sqlite3_result_int64(ctx, (*(*pCsr).pCurrent).mUnixTime as sqlite3_int64);
            current_block = 5330834795799507926;
        }
        3 => {
            /* sz */
            if sqlite3_vtab_nochange(ctx) == 0 as libc::c_int {
                sqlite3_result_int64(ctx, (*pCDS).szUncompressed as sqlite3_int64);
                current_block = 5330834795799507926;
            } else {
                current_block = 5330834795799507926;
            }
        }
        4 => {
            /* rawdata */
            if sqlite3_vtab_nochange(ctx) != 0 {
                current_block = 5330834795799507926;
            } else {
                current_block = 1841672684692190573;
            }
        }
        5 => {
            current_block = 1841672684692190573;
        }
        6 => {
            /* method */
            sqlite3_result_int(ctx, (*pCDS).iCompression as libc::c_int);
            current_block = 5330834795799507926;
        }
        _ => {
            /* z */
            sqlite3_result_int64(ctx, (*pCsr).iId);
            current_block = 5330834795799507926;
        }
    }
    match current_block {
        1841672684692190573 =>
        /* data */
        {
            if i == 4 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 0 as libc::c_int
                || (*pCDS).iCompression as libc::c_int == 8 as libc::c_int
            {
                let mut sz: libc::c_int = (*pCDS).szCompressed as libc::c_int;
                let mut szFinal: libc::c_int = (*pCDS).szUncompressed as libc::c_int;
                if szFinal > 0 as libc::c_int {
                    let mut aBuf: *mut u8_0 = 0 as *mut u8_0;
                    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
                    if !(*(*pCsr).pCurrent).aData.is_null() {
                        aBuf = (*(*pCsr).pCurrent).aData
                    } else {
                        aFree = sqlite3_malloc64(sz as sqlite3_uint64) as *mut u8_0;
                        aBuf = aFree;
                        if aBuf.is_null() {
                            rc = 7 as libc::c_int
                        } else {
                            let mut pFile: *mut FILE = (*pCsr).pFile;
                            if pFile.is_null() {
                                pFile = (*((*pCsr).base.pVtab as *mut ZipfileTab)).pWriteFd
                            }
                            rc = zipfileReadData(
                                pFile,
                                aBuf,
                                sz,
                                (*(*pCsr).pCurrent).iDataOff,
                                &mut (*(*pCsr).base.pVtab).zErrMsg,
                            )
                        }
                    }
                    if rc == 0 as libc::c_int {
                        if i == 5 as libc::c_int && (*pCDS).iCompression as libc::c_int != 0 {
                            zipfileInflate(ctx, aBuf, sz, szFinal);
                        } else {
                            sqlite3_result_blob(
                                ctx,
                                aBuf as *const libc::c_void,
                                sz,
                                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                                    -(1 as libc::c_int) as libc::intptr_t,
                                ),
                            );
                        }
                    }
                    sqlite3_free(aFree as *mut libc::c_void);
                } else {
                    /* Figure out if this is a directory or a zero-sized file. Consider
                     ** it to be a directory either if the mode suggests so, or if
                     ** the final character in the name is '/'.  */
                    let mut mode: u32_0 = (*pCDS).iExternalAttr >> 16 as libc::c_int;
                    if mode & 0o40000 as libc::c_int as libc::c_uint == 0
                        && *(*pCDS)
                            .zFile
                            .offset(((*pCDS).nFile as libc::c_int - 1 as libc::c_int) as isize)
                            as libc::c_int
                            != '/' as i32
                    {
                        sqlite3_result_blob(
                            ctx,
                            b"\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                            0 as libc::c_int,
                            None,
                        );
                    }
                }
            }
        }
        _ => {}
    }
    return rc;
}
/*
** Return TRUE if the cursor is at EOF.
*/
unsafe extern "C" fn zipfileEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr;
    return (*pCsr).bEof as libc::c_int;
}
/*
** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
** is guaranteed to be a file-handle open on a zip file.
**
** This function attempts to locate the EOCD record within the zip archive
** and populate *pEOCD with the results of decoding it. SQLITE_OK is
** returned if successful. Otherwise, an SQLite error code is returned and
** an English language error message may be left in virtual-table pTab.
*/
unsafe extern "C" fn zipfileReadEOCD(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut nBlob: libc::c_int,
    mut pFile: *mut FILE,
    mut pEOCD: *mut ZipfileEOCD,
) -> libc::c_int
/* Object to populate */ {
    let mut aRead: *mut u8_0 = (*pTab).aBuffer; /* Temporary buffer */
    let mut nRead: libc::c_int = 0; /* Bytes to read from file */
    let mut rc: libc::c_int = 0 as libc::c_int; /* Offset to read from */
    memset(
        pEOCD as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
    ); /* Total size of file in bytes */
    if aBlob.is_null() {
        let mut iOff: i64_0 = 0;
        let mut szFile: i64_0 = 0;
        fseek(pFile, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        szFile = ftell(pFile) as i64_0;
        if szFile == 0 as libc::c_int as libc::c_longlong {
            return 0 as libc::c_int;
        } else {
            nRead = if szFile < (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong {
                szFile
            } else {
                (64 as libc::c_int * 1024 as libc::c_int) as libc::c_longlong
            } as libc::c_int;
            iOff = szFile - nRead as libc::c_longlong;
            rc = zipfileReadData(pFile, aRead, nRead, iOff, &mut (*pTab).base.zErrMsg)
        }
    } else {
        nRead = if nBlob < 64 as libc::c_int * 1024 as libc::c_int {
            nBlob
        } else {
            (64 as libc::c_int) * 1024 as libc::c_int
        };
        aRead = &*aBlob.offset((nBlob - nRead) as isize) as *const u8_0 as *mut u8_0
    }
    if rc == 0 as libc::c_int {
        let mut i: libc::c_int = 0;
        /* Scan backwards looking for the signature bytes */
        i = nRead - 20 as libc::c_int;
        while i >= 0 as libc::c_int {
            if *aRead.offset(i as isize) as libc::c_int == 0x50 as libc::c_int
                && *aRead.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                    == 0x4b as libc::c_int
                && *aRead.offset((i + 2 as libc::c_int) as isize) as libc::c_int
                    == 0x5 as libc::c_int
                && *aRead.offset((i + 3 as libc::c_int) as isize) as libc::c_int
                    == 0x6 as libc::c_int
            {
                break;
            }
            i -= 1
        }
        if i < 0 as libc::c_int {
            (*pTab).base.zErrMsg = sqlite3_mprintf(
                b"cannot find end of central directory record\x00" as *const u8
                    as *const libc::c_char,
            );
            return 1 as libc::c_int;
        } else {
            aRead = aRead.offset((i + 4 as libc::c_int) as isize);
            aRead = aRead.offset(2 as libc::c_int as isize);
            (*pEOCD).iDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
            aRead = aRead.offset(2 as libc::c_int as isize);
            (*pEOCD).iFirstDisk = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
            aRead = aRead.offset(2 as libc::c_int as isize);
            (*pEOCD).nEntry = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
            aRead = aRead.offset(2 as libc::c_int as isize);
            (*pEOCD).nEntryTotal = zipfileGetU16(aRead.offset(-(2 as libc::c_int as isize)));
            aRead = aRead.offset(4 as libc::c_int as isize);
            (*pEOCD).nSize = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)));
            aRead = aRead.offset(4 as libc::c_int as isize);
            (*pEOCD).iOffset = zipfileGetU32(aRead.offset(-(4 as libc::c_int as isize)))
        }
    }
    return rc;
}
/*
** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry
** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
** to the end of the list. Otherwise, it is added to the list immediately
** before pBefore (which is guaranteed to be a part of said list).
*/
unsafe extern "C" fn zipfileAddEntry(
    mut pTab: *mut ZipfileTab,
    mut pBefore: *mut ZipfileEntry,
    mut pNew: *mut ZipfileEntry,
) {
    if pBefore.is_null() {
        if (*pTab).pFirstEntry.is_null() {
            (*pTab).pLastEntry = pNew;
            (*pTab).pFirstEntry = (*pTab).pLastEntry
        } else {
            (*(*pTab).pLastEntry).pNext = pNew;
            (*pTab).pLastEntry = pNew
        }
    } else {
        let mut pp: *mut *mut ZipfileEntry = 0 as *mut *mut ZipfileEntry;
        pp = &mut (*pTab).pFirstEntry;
        while *pp != pBefore {
            pp = &mut (**pp).pNext
        }
        (*pNew).pNext = pBefore;
        *pp = pNew
    };
}
unsafe extern "C" fn zipfileLoadDirectory(
    mut pTab: *mut ZipfileTab,
    mut aBlob: *const u8_0,
    mut nBlob: libc::c_int,
) -> libc::c_int {
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut iOff: i64_0 = 0;
    rc = zipfileReadEOCD(pTab, aBlob, nBlob, (*pTab).pWriteFd, &mut eocd);
    iOff = eocd.iOffset as i64_0;
    i = 0 as libc::c_int;
    while rc == 0 as libc::c_int && i < eocd.nEntry as libc::c_int {
        let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        rc = zipfileGetEntry(pTab, aBlob, nBlob, (*pTab).pWriteFd, iOff, &mut pNew);
        if rc == 0 as libc::c_int {
            zipfileAddEntry(pTab, 0 as *mut ZipfileEntry, pNew);
            iOff += 46 as libc::c_int as libc::c_longlong;
            iOff += ((*pNew).cds.nExtra as libc::c_int
                + (*pNew).cds.nFile as libc::c_int
                + (*pNew).cds.nComment as libc::c_int) as libc::c_longlong
        }
        i += 1
    }
    return rc;
}
/*
** xFilter callback.
*/
unsafe extern "C" fn zipfileFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut _idxStr: *const libc::c_char,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = (*cur).pVtab as *mut ZipfileTab; /* Zip file to scan */
    let mut pCsr: *mut ZipfileCsr = cur as *mut ZipfileCsr; /* Return Code */
    let mut zFile: *const libc::c_char = 0 as *const libc::c_char; /* True for an in-memory zipfile */
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut bInMemory: libc::c_int = 0 as libc::c_int;
    zipfileResetCursor(pCsr);
    if !(*pTab).zFile.is_null() {
        zFile = (*pTab).zFile
    } else if idxNum == 0 as libc::c_int {
        zipfileCursorErr(
            pCsr,
            b"zipfile() function requires an argument\x00" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int {
        let mut aBlob: *const u8_0 =
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const u8_0;
        let mut nBlob: libc::c_int = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
        rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
        (*pCsr).pFreeEntry = (*pTab).pFirstEntry;
        (*pTab).pLastEntry = 0 as *mut ZipfileEntry;
        (*pTab).pFirstEntry = (*pTab).pLastEntry;
        if rc != 0 as libc::c_int {
            return rc;
        } else {
            bInMemory = 1 as libc::c_int
        }
    } else {
        zFile = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char
    }
    if (*pTab).pWriteFd.is_null() && 0 as libc::c_int == bInMemory {
        (*pCsr).pFile = fopen(zFile, b"rb\x00" as *const u8 as *const libc::c_char);
        if (*pCsr).pFile.is_null() {
            zipfileCursorErr(
                pCsr,
                b"cannot open file: %s\x00" as *const u8 as *const libc::c_char,
                zFile,
            );
            rc = 1 as libc::c_int
        } else {
            rc = zipfileReadEOCD(
                pTab,
                0 as *const u8_0,
                0 as libc::c_int,
                (*pCsr).pFile,
                &mut (*pCsr).eocd,
            );
            if rc == 0 as libc::c_int {
                if (*pCsr).eocd.nEntry as libc::c_int == 0 as libc::c_int {
                    (*pCsr).bEof = 1 as libc::c_int as u8_0
                } else {
                    (*pCsr).iNextOff = (*pCsr).eocd.iOffset as i64_0;
                    rc = zipfileNext(cur)
                }
            }
        }
    } else {
        (*pCsr).bNoop = 1 as libc::c_int as u8_0;
        (*pCsr).pCurrent = if !(*pCsr).pFreeEntry.is_null() {
            (*pCsr).pFreeEntry
        } else {
            (*pTab).pFirstEntry
        };
        rc = zipfileNext(cur)
    }
    return rc;
}
/*
** xBestIndex callback.
*/
unsafe extern "C" fn zipfileBestIndex(
    mut _tab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    let mut idx: libc::c_int = -(1 as libc::c_int);
    let mut unusable: libc::c_int = 0 as libc::c_int;
    i = 0 as libc::c_int;
    while i < (*pIdxInfo).nConstraint {
        let mut pCons: *const sqlite3_index_constraint =
            &mut *(*pIdxInfo).aConstraint.offset(i as isize) as *mut sqlite3_index_constraint;
        if !((*pCons).iColumn != 7 as libc::c_int) {
            if (*pCons).usable as libc::c_int == 0 as libc::c_int {
                unusable = 1 as libc::c_int
            } else if (*pCons).op as libc::c_int == 2 as libc::c_int {
                idx = i
            }
        }
        i += 1
    }
    (*pIdxInfo).estimatedCost = 1000.0f64;
    if idx >= 0 as libc::c_int {
        (*(*pIdxInfo).aConstraintUsage.offset(idx as isize)).argvIndex = 1 as libc::c_int;
        (*(*pIdxInfo).aConstraintUsage.offset(idx as isize)).omit =
            1 as libc::c_int as libc::c_uchar;
        (*pIdxInfo).idxNum = 1 as libc::c_int
    } else if unusable != 0 {
        return 19 as libc::c_int;
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn zipfileNewEntry(mut zPath: *const libc::c_char) -> *mut ZipfileEntry {
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    pNew = sqlite3_malloc(::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong as libc::c_int)
        as *mut ZipfileEntry;
    if !pNew.is_null() {
        memset(
            pNew as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
        );
        (*pNew).cds.zFile = sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, zPath);
        if (*pNew).cds.zFile.is_null() {
            sqlite3_free(pNew as *mut libc::c_void);
            pNew = 0 as *mut ZipfileEntry
        }
    }
    return pNew;
}
unsafe extern "C" fn zipfileSerializeLFH(
    mut pEntry: *mut ZipfileEntry,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut pCds: *mut ZipfileCDS = &mut (*pEntry).cds;
    let mut a: *mut u8_0 = aBuf;
    (*pCds).nExtra = 9 as libc::c_int as u16_0;
    /* Write the LFH itself */
    zipfilePutU32(a, 0x4034b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCds).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCds).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    /* Add the file name */
    memcpy(
        a as *mut libc::c_void,
        (*pCds).zFile as *const libc::c_void,
        (*pCds).nFile as libc::c_int as libc::c_ulong,
    );
    a = a.offset((*pCds).nFile as libc::c_int as isize);
    /* The "extra" data */
    zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, 5 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    let fresh29 = a;
    a = a.offset(1);
    *fresh29 = 0x1 as libc::c_int as u8_0;
    zipfilePutU32(a, (*pEntry).mUnixTime);
    a = a.offset(4 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEntry(
    mut pTab: *mut ZipfileTab,
    mut pEntry: *mut ZipfileEntry,
    mut pData: *const u8_0,
    mut nData: libc::c_int,
) -> libc::c_int {
    let mut aBuf: *mut u8_0 = (*pTab).aBuffer;
    let mut nBuf: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    nBuf = zipfileSerializeLFH(pEntry, aBuf);
    rc = zipfileAppendData(pTab, aBuf, nBuf);
    if rc == 0 as libc::c_int {
        (*pEntry).iDataOff = (*pTab).szCurrent;
        rc = zipfileAppendData(pTab, pData, nData)
    }
    return rc;
}
unsafe extern "C" fn zipfileGetMode(
    mut pVal: *mut sqlite3_value,
    mut bIsDir: libc::c_int,
    mut pMode: *mut u32_0,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message */ {
    let mut current_block: u64;
    let mut z: *const libc::c_char = sqlite3_value_text(pVal) as *const libc::c_char;
    let mut mode: u32_0 = 0 as libc::c_int as u32_0;
    if z.is_null() {
        mode = if bIsDir != 0 {
            (0o40000 as libc::c_int) + 0o755 as libc::c_int
        } else {
            (0o100000 as libc::c_int) + 0o644 as libc::c_int
        } as u32_0
    } else if *z.offset(0 as libc::c_int as isize) as libc::c_int >= '0' as i32
        && *z.offset(0 as libc::c_int as isize) as libc::c_int <= '9' as i32
    {
        mode = sqlite3_value_int(pVal) as libc::c_uint
    } else {
        let zTemplate: [libc::c_char; 11] =
            *::std::mem::transmute::<&[u8; 11], &[libc::c_char; 11]>(b"-rwxrwxrwx\x00");
        let mut i: libc::c_int = 0;
        if strlen(z) != 10 as libc::c_int as libc::c_ulong {
            current_block = 7200262340188941816;
        } else {
            match *z.offset(0 as libc::c_int as isize) as libc::c_int {
                45 => {
                    current_block = 1844840963447537551;
                    match current_block {
                        12028203675507613852 => mode |= 0o120000 as libc::c_int as libc::c_uint,
                        14422158124627350281 => mode |= 0o40000 as libc::c_int as libc::c_uint,
                        _ => mode |= 0o100000 as libc::c_int as libc::c_uint,
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 13797916685926291137;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode |= ((1 as libc::c_int) << 9 as libc::c_int - i) as libc::c_uint
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 7200262340188941816;
                            break;
                        }
                        i += 1
                    }
                }
                100 => {
                    current_block = 14422158124627350281;
                    match current_block {
                        12028203675507613852 => mode |= 0o120000 as libc::c_int as libc::c_uint,
                        14422158124627350281 => mode |= 0o40000 as libc::c_int as libc::c_uint,
                        _ => mode |= 0o100000 as libc::c_int as libc::c_uint,
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 13797916685926291137;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode |= ((1 as libc::c_int) << 9 as libc::c_int - i) as libc::c_uint
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 7200262340188941816;
                            break;
                        }
                        i += 1
                    }
                }
                108 => {
                    current_block = 12028203675507613852;
                    match current_block {
                        12028203675507613852 => mode |= 0o120000 as libc::c_int as libc::c_uint,
                        14422158124627350281 => mode |= 0o40000 as libc::c_int as libc::c_uint,
                        _ => mode |= 0o100000 as libc::c_int as libc::c_uint,
                    }
                    i = 1 as libc::c_int;
                    loop {
                        if !(i < 10 as libc::c_int) {
                            current_block = 13797916685926291137;
                            break;
                        }
                        if *z.offset(i as isize) as libc::c_int
                            == zTemplate[i as usize] as libc::c_int
                        {
                            mode |= ((1 as libc::c_int) << 9 as libc::c_int - i) as libc::c_uint
                        } else if *z.offset(i as isize) as libc::c_int != '-' as i32 {
                            current_block = 7200262340188941816;
                            break;
                        }
                        i += 1
                    }
                }
                _ => {
                    current_block = 7200262340188941816;
                }
            }
        }
        match current_block {
            13797916685926291137 => {}
            _ => {
                *pzErr = sqlite3_mprintf(
                    b"zipfile: parse error in mode: %s\x00" as *const u8 as *const libc::c_char,
                    z,
                );
                return 1 as libc::c_int;
            }
        }
    }
    if (mode & 0o40000 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint)
        as libc::c_int
        == bIsDir
    {
        /* The "mode" attribute is a directory, but data has been specified.
         ** Or vice-versa - no data but "mode" is a file or symlink.  */
        *pzErr = sqlite3_mprintf(
            b"zipfile: mode does not match data\x00" as *const u8 as *const libc::c_char,
        );
        return 19 as libc::c_int;
    } else {
        *pMode = mode;
        return 0 as libc::c_int;
    };
}
/*
** Both (const char*) arguments point to nul-terminated strings. Argument
** nB is the value of strlen(zB). This function returns 0 if the strings are
** identical, ignoring any trailing '/' character in either path.  */
unsafe extern "C" fn zipfileComparePath(
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut nB: libc::c_int,
) -> libc::c_int {
    let mut nA: libc::c_int = strlen(zA) as libc::c_int;
    if nA > 0 as libc::c_int
        && *zA.offset((nA - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nA -= 1
    }
    if nB > 0 as libc::c_int
        && *zB.offset((nB - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
    {
        nB -= 1
    }
    if nA == nB
        && memcmp(
            zA as *const libc::c_void,
            zB as *const libc::c_void,
            nA as libc::c_ulong,
        ) == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    } else {
        return 1 as libc::c_int;
    };
}
unsafe extern "C" fn zipfileBegin(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pTab).zFile.is_null()
        || *(*pTab).zFile.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
    {
        (*pTab).base.zErrMsg =
            sqlite3_mprintf(b"zipfile: missing filename\x00" as *const u8 as *const libc::c_char);
        return 1 as libc::c_int;
    } else {
        /* Open a write fd on the file. Also load the entire central directory
         ** structure into memory. During the transaction any new file data is
         ** appended to the archive file, but the central directory is accumulated
         ** in main-memory until the transaction is committed.  */
        (*pTab).pWriteFd = fopen(
            (*pTab).zFile,
            b"ab+\x00" as *const u8 as *const libc::c_char,
        );
        if (*pTab).pWriteFd.is_null() {
            (*pTab).base.zErrMsg = sqlite3_mprintf(
                b"zipfile: failed to open file %s for writing\x00" as *const u8
                    as *const libc::c_char,
                (*pTab).zFile,
            );
            rc = 1 as libc::c_int
        } else {
            fseek(
                (*pTab).pWriteFd,
                0 as libc::c_int as libc::c_long,
                2 as libc::c_int,
            );
            (*pTab).szOrig = ftell((*pTab).pWriteFd) as i64_0;
            (*pTab).szCurrent = (*pTab).szOrig;
            rc = zipfileLoadDirectory(pTab, 0 as *const u8_0, 0 as libc::c_int)
        }
        if rc != 0 as libc::c_int {
            zipfileCleanupTransaction(pTab);
        }
        return rc;
    };
}
/*
** Return the current time as a 32-bit timestamp in UNIX epoch format (like
** time(2)).
*/
unsafe extern "C" fn zipfileTime() -> u32_0 {
    let mut pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(0 as *const libc::c_char);
    let mut ret: u32_0 = 0;
    if pVfs.is_null() {
        return 0 as libc::c_int as u32_0;
    } else {
        if (*pVfs).iVersion >= 2 as libc::c_int && (*pVfs).xCurrentTimeInt64.is_some() {
            let mut ms: i64_0 = 0;
            (*pVfs)
                .xCurrentTimeInt64
                .expect("non-null function pointer")(pVfs, &mut ms);
            ret = (ms / 1000 as libc::c_int as libc::c_longlong
                - 24405875 as libc::c_int as i64_0 * 8640 as libc::c_int as libc::c_longlong)
                as u32_0
        } else {
            let mut day: libc::c_double = 0.;
            (*pVfs).xCurrentTime.expect("non-null function pointer")(pVfs, &mut day);
            ret = ((day - 2440587.5f64) * 86400 as libc::c_int as libc::c_double) as u32_0
        }
        return ret;
    };
}
/*
** Return a 32-bit timestamp in UNIX epoch format.
**
** If the value passed as the only argument is either NULL or an SQL NULL,
** return the current time. Otherwise, return the value stored in (*pVal)
** cast to a 32-bit unsigned integer.
*/
unsafe extern "C" fn zipfileGetTime(mut pVal: *mut sqlite3_value) -> u32_0 {
    if pVal.is_null() || sqlite3_value_type(pVal) == 5 as libc::c_int {
        return zipfileTime();
    } else {
        return sqlite3_value_int64(pVal) as u32_0;
    };
}
/*
** Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
** linked list.  Remove it from the list and free the object.
*/
unsafe extern "C" fn zipfileRemoveEntryFromList(
    mut pTab: *mut ZipfileTab,
    mut pOld: *mut ZipfileEntry,
) {
    if !pOld.is_null() {
        let mut pp: *mut *mut ZipfileEntry = 0 as *mut *mut ZipfileEntry;
        pp = &mut (*pTab).pFirstEntry;
        while *pp != pOld {
            pp = &mut (**pp).pNext
        }
        *pp = (**pp).pNext;
        zipfileEntryFree(pOld);
    };
}
/*
** xUpdate method.
*/
unsafe extern "C" fn zipfileUpdate(
    mut pVtab: *mut sqlite3_vtab,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
    mut _pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut current_block: u64; /* Return Code */
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab; /* New in-memory CDS entry */
    let mut rc: libc::c_int = 0 as libc::c_int; /* Mode for new entry */
    let mut pNew: *mut ZipfileEntry = 0 as *mut ZipfileEntry; /* Modification time for new entry */
    let mut mode: u32_0 = 0 as libc::c_int as u32_0; /* Uncompressed size */
    let mut mTime: u32_0 = 0 as libc::c_int as u32_0; /* Path for new entry */
    let mut sz: i64_0 = 0 as libc::c_int as i64_0; /* strlen(zPath) */
    let mut zPath: *const libc::c_char = 0 as *const libc::c_char; /* Pointer to buffer containing content */
    let mut nPath: libc::c_int = 0 as libc::c_int; /* Size of pData buffer in bytes */
    let mut pData: *const u8_0 = 0 as *const u8_0; /* Compression method for new entry */
    let mut nData: libc::c_int = 0 as libc::c_int; /* Free this */
    let mut iMethod: libc::c_int = 0 as libc::c_int; /* Also free this */
    let mut pFree: *mut u8_0 = 0 as *mut u8_0; /* True for an update that modifies "name" */
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pOld: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut pOld2: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
    let mut bUpdate: libc::c_int = 0 as libc::c_int;
    let mut bIsDir: libc::c_int = 0 as libc::c_int;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    if (*pTab).pWriteFd.is_null() {
        rc = zipfileBegin(pVtab);
        if rc != 0 as libc::c_int {
            return rc;
        }
    }
    /* If this is a DELETE or UPDATE, find the archive entry to delete. */
    if sqlite3_value_type(*apVal.offset(0 as libc::c_int as isize)) != 5 as libc::c_int {
        let mut zDelete: *const libc::c_char =
            sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)) as *const libc::c_char;
        let mut nDelete: libc::c_int = strlen(zDelete) as libc::c_int;
        if nVal > 1 as libc::c_int {
            let mut zUpdate: *const libc::c_char =
                sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize)) as *const libc::c_char;
            if !zUpdate.is_null()
                && zipfileComparePath(zUpdate, zDelete, nDelete) != 0 as libc::c_int
            {
                bUpdate = 1 as libc::c_int
            }
        }
        pOld = (*pTab).pFirstEntry;
        while !(zipfileComparePath((*pOld).cds.zFile, zDelete, nDelete) == 0 as libc::c_int) {
            pOld = (*pOld).pNext
        }
    }
    if nVal > 1 as libc::c_int {
        /* Check that "sz" and "rawdata" are both NULL: */
        if sqlite3_value_type(*apVal.offset(5 as libc::c_int as isize)) != 5 as libc::c_int {
            zipfileTableErr(
                pTab,
                b"sz must be NULL\x00" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int
        }
        if sqlite3_value_type(*apVal.offset(6 as libc::c_int as isize)) != 5 as libc::c_int {
            zipfileTableErr(
                pTab,
                b"rawdata must be NULL\x00" as *const u8 as *const libc::c_char,
            );
            rc = 19 as libc::c_int
        }
        if rc == 0 as libc::c_int {
            if sqlite3_value_type(*apVal.offset(7 as libc::c_int as isize)) == 5 as libc::c_int {
                /* data=NULL. A directory */
                bIsDir = 1 as libc::c_int
            } else {
                /* Value specified for "data", and possibly "method". This must be
                 ** a regular file or a symlink. */
                let mut aIn: *const u8_0 =
                    sqlite3_value_blob(*apVal.offset(7 as libc::c_int as isize)) as *const u8_0;
                let mut nIn: libc::c_int =
                    sqlite3_value_bytes(*apVal.offset(7 as libc::c_int as isize));
                let mut bAuto: libc::c_int =
                    (sqlite3_value_type(*apVal.offset(8 as libc::c_int as isize))
                        == 5 as libc::c_int) as libc::c_int;
                iMethod = sqlite3_value_int(*apVal.offset(8 as libc::c_int as isize));
                sz = nIn as i64_0;
                pData = aIn;
                nData = nIn;
                if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                    zipfileTableErr(
                        pTab,
                        b"unknown compression method: %d\x00" as *const u8 as *const libc::c_char,
                        iMethod,
                    );
                    rc = 19 as libc::c_int
                } else {
                    if bAuto != 0 || iMethod != 0 {
                        let mut nCmp: libc::c_int = 0;
                        rc = zipfileDeflate(
                            aIn,
                            nIn,
                            &mut pFree,
                            &mut nCmp,
                            &mut (*pTab).base.zErrMsg,
                        );
                        if rc == 0 as libc::c_int {
                            if iMethod != 0 || nCmp < nIn {
                                iMethod = 8 as libc::c_int;
                                pData = pFree;
                                nData = nCmp
                            }
                        }
                    }
                    iCrc32 = crc32(0 as libc::c_int as uLong, aIn, nIn as uInt) as u32_0
                }
            }
        }
        if rc == 0 as libc::c_int {
            rc = zipfileGetMode(
                *apVal.offset(3 as libc::c_int as isize),
                bIsDir,
                &mut mode,
                &mut (*pTab).base.zErrMsg,
            )
        }
        if rc == 0 as libc::c_int {
            zPath =
                sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize)) as *const libc::c_char;
            if zPath.is_null() {
                zPath = b"\x00" as *const u8 as *const libc::c_char
            }
            nPath = strlen(zPath) as libc::c_int;
            mTime = zipfileGetTime(*apVal.offset(4 as libc::c_int as isize))
        }
        if rc == 0 as libc::c_int && bIsDir != 0 {
            /* For a directory, check that the last character in the path is a
             ** '/'. This appears to be required for compatibility with info-zip
             ** (the unzip command on unix). It does not create directories
             ** otherwise.  */
            if nPath <= 0 as libc::c_int
                || *zPath.offset((nPath - 1 as libc::c_int) as isize) as libc::c_int != '/' as i32
            {
                zFree = sqlite3_mprintf(b"%s/\x00" as *const u8 as *const libc::c_char, zPath);
                zPath = zFree as *const libc::c_char;
                if zFree.is_null() {
                    rc = 7 as libc::c_int;
                    nPath = 0 as libc::c_int
                } else {
                    nPath = strlen(zPath) as libc::c_int
                }
            }
        }
        /* Check that we're not inserting a duplicate entry -OR- updating an
         ** entry with a path, thereby making it into a duplicate. */
        if (pOld.is_null() || bUpdate != 0) && rc == 0 as libc::c_int {
            let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
            p = (*pTab).pFirstEntry;
            loop {
                if p.is_null() {
                    current_block = 6002151390280567665;
                    break;
                }
                if zipfileComparePath((*p).cds.zFile, zPath, nPath) == 0 as libc::c_int {
                    match sqlite3_vtab_on_conflict((*pTab).db) {
                        2 => {
                            current_block = 2720352254335022963;
                            break;
                        }
                        5 => {
                            pOld2 = p;
                            current_block = 6002151390280567665;
                            break;
                        }
                        _ => {
                            zipfileTableErr(
                                pTab,
                                b"duplicate name: \"%s\"\x00" as *const u8 as *const libc::c_char,
                                zPath,
                            );
                            rc = 19 as libc::c_int;
                            current_block = 6002151390280567665;
                            break;
                        }
                    }
                } else {
                    p = (*p).pNext
                }
            }
        } else {
            current_block = 6002151390280567665;
        }
        match current_block {
            2720352254335022963 => {}
            _ => {
                if rc == 0 as libc::c_int {
                    /* Create the new CDS record. */
                    pNew = zipfileNewEntry(zPath); /* Size of trailing comment in bytes*/
                    if pNew.is_null() {
                        rc = 7 as libc::c_int
                    } else {
                        (*pNew).cds.iVersionMadeBy =
                            (((3 as libc::c_int) << 8 as libc::c_int) + 30 as libc::c_int) as u16_0;
                        (*pNew).cds.iVersionExtract = 20 as libc::c_int as u16_0;
                        (*pNew).cds.flags = 0x800 as libc::c_int as u16_0;
                        (*pNew).cds.iCompression = iMethod as u16_0;
                        zipfileMtimeToDos(&mut (*pNew).cds, mTime);
                        (*pNew).cds.crc32 = iCrc32;
                        (*pNew).cds.szCompressed = nData as u32_0;
                        (*pNew).cds.szUncompressed = sz as u32_0;
                        (*pNew).cds.iExternalAttr = mode << 16 as libc::c_int;
                        (*pNew).cds.iOffset = (*pTab).szCurrent as u32_0;
                        (*pNew).cds.nFile = nPath as u16_0;
                        (*pNew).mUnixTime = mTime;
                        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
                        zipfileAddEntry(pTab, pOld, pNew);
                    }
                    current_block = 16463303006880176998;
                } else {
                    current_block = 16463303006880176998;
                }
            }
        }
    } else {
        current_block = 16463303006880176998;
    }
    match current_block {
        16463303006880176998 => {
            if rc == 0 as libc::c_int && (!pOld.is_null() || !pOld2.is_null()) {
                let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
                pCsr = (*pTab).pCsrList;
                while !pCsr.is_null() {
                    if !(*pCsr).pCurrent.is_null()
                        && ((*pCsr).pCurrent == pOld || (*pCsr).pCurrent == pOld2)
                    {
                        (*pCsr).pCurrent = (*(*pCsr).pCurrent).pNext;
                        (*pCsr).bNoop = 1 as libc::c_int as u8_0
                    }
                    pCsr = (*pCsr).pCsrNext
                }
                zipfileRemoveEntryFromList(pTab, pOld);
                zipfileRemoveEntryFromList(pTab, pOld2);
            }
        }
        _ => {}
    }
    sqlite3_free(pFree as *mut libc::c_void);
    sqlite3_free(zFree as *mut libc::c_void);
    return rc;
}
unsafe extern "C" fn zipfileSerializeEOCD(
    mut p: *mut ZipfileEOCD,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    zipfilePutU32(a, 0x6054b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).iFirstDisk);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntry);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*p).nEntryTotal);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*p).nSize);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*p).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, 0 as libc::c_int as u16_0);
    a = a.offset(2 as libc::c_int as isize);
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileAppendEOCD(
    mut pTab: *mut ZipfileTab,
    mut p: *mut ZipfileEOCD,
) -> libc::c_int {
    let mut nBuf: libc::c_int = zipfileSerializeEOCD(p, (*pTab).aBuffer);
    return zipfileAppendData(pTab, (*pTab).aBuffer, nBuf);
}
/*
** Serialize the CDS structure into buffer aBuf[]. Return the number
** of bytes written.
*/
unsafe extern "C" fn zipfileSerializeCDS(
    mut pEntry: *mut ZipfileEntry,
    mut aBuf: *mut u8_0,
) -> libc::c_int {
    let mut a: *mut u8_0 = aBuf;
    let mut pCDS: *mut ZipfileCDS = &mut (*pEntry).cds;
    if (*pEntry).aExtra.is_null() {
        (*pCDS).nExtra = 9 as libc::c_int as u16_0
    }
    zipfilePutU32(a, 0x2014b50 as libc::c_int as u32_0);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionMadeBy);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iVersionExtract);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).flags);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iCompression);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mTime);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).mDate);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).crc32);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szCompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).szUncompressed);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nFile);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nExtra);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).nComment);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iDiskStart);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU16(a, (*pCDS).iInternalAttr);
    a = a.offset(2 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iExternalAttr);
    a = a.offset(4 as libc::c_int as isize);
    zipfilePutU32(a, (*pCDS).iOffset);
    a = a.offset(4 as libc::c_int as isize);
    memcpy(
        a as *mut libc::c_void,
        (*pCDS).zFile as *const libc::c_void,
        (*pCDS).nFile as libc::c_ulong,
    );
    a = a.offset((*pCDS).nFile as libc::c_int as isize);
    if !(*pEntry).aExtra.is_null() {
        let mut n: libc::c_int = (*pCDS).nExtra as libc::c_int + (*pCDS).nComment as libc::c_int;
        memcpy(
            a as *mut libc::c_void,
            (*pEntry).aExtra as *const libc::c_void,
            n as libc::c_ulong,
        );
        a = a.offset(n as isize)
    } else {
        zipfilePutU16(a, 0x5455 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        zipfilePutU16(a, 5 as libc::c_int as u16_0);
        a = a.offset(2 as libc::c_int as isize);
        let fresh30 = a;
        a = a.offset(1);
        *fresh30 = 0x1 as libc::c_int as u8_0;
        zipfilePutU32(a, (*pEntry).mUnixTime);
        a = a.offset(4 as libc::c_int as isize)
    }
    return a.offset_from(aBuf) as libc::c_long as libc::c_int;
}
unsafe extern "C" fn zipfileCommit(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut ZipfileTab = pVtab as *mut ZipfileTab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if !(*pTab).pWriteFd.is_null() {
        let mut iOffset: i64_0 = (*pTab).szCurrent;
        let mut p: *mut ZipfileEntry = 0 as *mut ZipfileEntry;
        let mut eocd: ZipfileEOCD = ZipfileEOCD {
            iDisk: 0,
            iFirstDisk: 0,
            nEntry: 0,
            nEntryTotal: 0,
            nSize: 0,
            iOffset: 0,
        };
        let mut nEntry: libc::c_int = 0 as libc::c_int;
        /* Write out all entries */
        p = (*pTab).pFirstEntry;
        while rc == 0 as libc::c_int && !p.is_null() {
            let mut n: libc::c_int = zipfileSerializeCDS(p, (*pTab).aBuffer);
            rc = zipfileAppendData(pTab, (*pTab).aBuffer, n);
            nEntry += 1;
            p = (*p).pNext
        }
        /* Write out the EOCD record */
        eocd.iDisk = 0 as libc::c_int as u16_0;
        eocd.iFirstDisk = 0 as libc::c_int as u16_0;
        eocd.nEntry = nEntry as u16_0;
        eocd.nEntryTotal = nEntry as u16_0;
        eocd.nSize = ((*pTab).szCurrent - iOffset) as u32_0;
        eocd.iOffset = iOffset as u32_0;
        rc = zipfileAppendEOCD(pTab, &mut eocd);
        zipfileCleanupTransaction(pTab);
    }
    return rc;
}
unsafe extern "C" fn zipfileRollback(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    return zipfileCommit(pVtab);
}
unsafe extern "C" fn zipfileFindCursor(
    mut pTab: *mut ZipfileTab,
    mut iId: i64_0,
) -> *mut ZipfileCsr {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    pCsr = (*pTab).pCsrList;
    while !pCsr.is_null() {
        if iId == (*pCsr).iId {
            break;
        }
        pCsr = (*pCsr).pCsrNext
    }
    return pCsr;
}
unsafe extern "C" fn zipfileFunctionCds(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pCsr: *mut ZipfileCsr = 0 as *mut ZipfileCsr;
    let mut pTab: *mut ZipfileTab = sqlite3_user_data(context) as *mut ZipfileTab;
    pCsr = zipfileFindCursor(
        pTab,
        sqlite3_value_int64(*argv.offset(0 as libc::c_int as isize)),
    );
    if !pCsr.is_null() {
        let mut p: *mut ZipfileCDS = &mut (*(*pCsr).pCurrent).cds;
        let mut zRes: *mut libc::c_char =
            sqlite3_mprintf(b"{\"version-made-by\" : %u, \"version-to-extract\" : %u, \"flags\" : %u, \"compression\" : %u, \"time\" : %u, \"date\" : %u, \"crc32\" : %u, \"compressed-size\" : %u, \"uncompressed-size\" : %u, \"file-name-length\" : %u, \"extra-field-length\" : %u, \"file-comment-length\" : %u, \"disk-number-start\" : %u, \"internal-attr\" : %u, \"external-attr\" : %u, \"offset\" : %u }\x00"
                                as *const u8 as *const libc::c_char,
                            (*p).iVersionMadeBy as u32_0,
                            (*p).iVersionExtract as u32_0,
                            (*p).flags as u32_0, (*p).iCompression as u32_0,
                            (*p).mTime as u32_0, (*p).mDate as u32_0,
                            (*p).crc32, (*p).szCompressed,
                            (*p).szUncompressed, (*p).nFile as u32_0,
                            (*p).nExtra as u32_0, (*p).nComment as u32_0,
                            (*p).iDiskStart as u32_0,
                            (*p).iInternalAttr as u32_0, (*p).iExternalAttr,
                            (*p).iOffset);
        if zRes.is_null() {
            sqlite3_result_error_nomem(context);
        } else {
            sqlite3_result_text(
                context,
                zRes,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
            sqlite3_free(zRes as *mut libc::c_void);
        }
    };
}
/*
** xFindFunction method.
*/
unsafe extern "C" fn zipfileFindFunction(
    mut pVtab: *mut sqlite3_vtab,
    mut _nArg: libc::c_int,
    mut zName: *const libc::c_char,
    mut pxFunc: *mut Option<
        unsafe extern "C" fn(
            _: *mut sqlite3_context,
            _: libc::c_int,
            _: *mut *mut sqlite3_value,
        ) -> (),
    >,
    mut ppArg: *mut *mut libc::c_void,
) -> libc::c_int
/* OUT: User data for *pxFunc */ {
    if sqlite3_stricmp(
        b"zipfile_cds\x00" as *const u8 as *const libc::c_char,
        zName,
    ) == 0 as libc::c_int
    {
        *pxFunc = Some(
            zipfileFunctionCds
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        );
        *ppArg = pVtab as *mut libc::c_void;
        return 1 as libc::c_int;
    } else {
        return 0 as libc::c_int;
    };
}
unsafe extern "C" fn zipfileBufferGrow(
    mut pBuf: *mut ZipfileBuffer,
    mut nByte: libc::c_int,
) -> libc::c_int {
    if (*pBuf).n + nByte > (*pBuf).nAlloc {
        let mut aNew: *mut u8_0 = 0 as *mut u8_0;
        let mut nNew: sqlite3_int64 = if (*pBuf).n != 0 {
            ((*pBuf).n) * 2 as libc::c_int
        } else {
            512 as libc::c_int
        } as sqlite3_int64;
        let mut nReq: libc::c_int = (*pBuf).n + nByte;
        while nNew < nReq as libc::c_longlong {
            nNew = nNew * 2 as libc::c_int as libc::c_longlong
        }
        aNew =
            sqlite3_realloc64((*pBuf).a as *mut libc::c_void, nNew as sqlite3_uint64) as *mut u8_0;
        if aNew.is_null() {
            return 7 as libc::c_int;
        } else {
            (*pBuf).a = aNew;
            (*pBuf).nAlloc = nNew as libc::c_int
        }
    }
    return 0 as libc::c_int;
}
/*
** xStep() callback for the zipfile() aggregate. This can be called in
** any of the following ways:
**
**   SELECT zipfile(name,data) ...
**   SELECT zipfile(name,mode,mtime,data) ...
**   SELECT zipfile(name,mode,mtime,data,method) ...
*/
pub unsafe extern "C" fn zipfileStep(
    mut pCtx: *mut sqlite3_context,
    mut nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut current_block: u64; /* Aggregate function context */
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx; /* New entry to add to zip archive */
    let mut e: ZipfileEntry = ZipfileEntry {
        cds: ZipfileCDS {
            iVersionMadeBy: 0,
            iVersionExtract: 0,
            flags: 0,
            iCompression: 0,
            mTime: 0,
            mDate: 0,
            crc32: 0,
            szCompressed: 0,
            szUncompressed: 0,
            nFile: 0,
            nExtra: 0,
            nComment: 0,
            iDiskStart: 0,
            iInternalAttr: 0,
            iExternalAttr: 0,
            iOffset: 0,
            zFile: 0 as *mut libc::c_char,
        },
        mUnixTime: 0,
        aExtra: 0 as *mut u8_0,
        iDataOff: 0,
        aData: 0 as *mut u8_0,
        pNext: 0 as *mut ZipfileEntry,
    }; /* Compression method to use (0 or 8) */
    let mut pName: *mut sqlite3_value = 0 as *mut sqlite3_value; /* Possibly compressed data for new entry */
    let mut pMode: *mut sqlite3_value = 0 as *mut sqlite3_value; /* Size of aData[] in bytes */
    let mut pMtime: *mut sqlite3_value = 0 as *mut sqlite3_value; /* Size of data before compression */
    let mut pData: *mut sqlite3_value = 0 as *mut sqlite3_value; /* Free this before returning */
    let mut pMethod: *mut sqlite3_value = 0 as *mut sqlite3_value; /* crc32 of uncompressed data */
    let mut bIsDir: libc::c_int = 0 as libc::c_int; /* Path (name) of new entry */
    let mut mode: u32_0 = 0; /* Size of zName in bytes */
    let mut rc: libc::c_int = 0 as libc::c_int; /* Free this before returning */
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut iMethod: libc::c_int = -(1 as libc::c_int);
    let mut aData: *const u8_0 = 0 as *const u8_0;
    let mut nData: libc::c_int = 0 as libc::c_int;
    let mut szUncompressed: libc::c_int = 0 as libc::c_int;
    let mut aFree: *mut u8_0 = 0 as *mut u8_0;
    let mut iCrc32: u32_0 = 0 as libc::c_int as u32_0;
    let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nName: libc::c_int = 0 as libc::c_int;
    let mut zFree: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nByte: libc::c_int = 0;
    memset(
        &mut e as *mut ZipfileEntry as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ZipfileEntry>() as libc::c_ulong,
    );
    p = sqlite3_aggregate_context(
        pCtx,
        ::std::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    } else {
        /* Martial the arguments into stack variables */
        if nVal != 2 as libc::c_int && nVal != 4 as libc::c_int && nVal != 5 as libc::c_int {
            zErr = sqlite3_mprintf(
                b"wrong number of arguments to function zipfile()\x00" as *const u8
                    as *const libc::c_char,
            );
            rc = 1 as libc::c_int
        } else {
            pName = *apVal.offset(0 as libc::c_int as isize);
            if nVal == 2 as libc::c_int {
                pData = *apVal.offset(1 as libc::c_int as isize)
            } else {
                pMode = *apVal.offset(1 as libc::c_int as isize);
                pMtime = *apVal.offset(2 as libc::c_int as isize);
                pData = *apVal.offset(3 as libc::c_int as isize);
                if nVal == 5 as libc::c_int {
                    pMethod = *apVal.offset(4 as libc::c_int as isize)
                }
            }
            /* Check that the 'name' parameter looks ok. */
            zName = sqlite3_value_text(pName) as *mut libc::c_char;
            nName = sqlite3_value_bytes(pName);
            if zName.is_null() {
                zErr = sqlite3_mprintf(
                    b"first argument to zipfile() must be non-NULL\x00" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                /* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
                 ** deflate compression) or NULL (choose automatically).  */
                if !pMethod.is_null() && 5 as libc::c_int != sqlite3_value_type(pMethod) {
                    iMethod = sqlite3_value_int64(pMethod) as libc::c_int;
                    if iMethod != 0 as libc::c_int && iMethod != 8 as libc::c_int {
                        zErr = sqlite3_mprintf(
                            b"illegal method value: %d\x00" as *const u8 as *const libc::c_char,
                            iMethod,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 969838246212928024;
                    } else {
                        current_block = 9520865839495247062;
                    }
                } else {
                    current_block = 9520865839495247062;
                }
                match current_block {
                    969838246212928024 => {}
                    _ =>
                    /* Now inspect the data. If this is NULL, then the new entry must be a
                     ** directory.  Otherwise, figure out whether or not the data should
                     ** be deflated or simply stored in the zip archive. */
                    {
                        if sqlite3_value_type(pData) == 5 as libc::c_int {
                            bIsDir = 1 as libc::c_int;
                            iMethod = 0 as libc::c_int;
                            current_block = 13619784596304402172;
                        } else {
                            aData = sqlite3_value_blob(pData) as *const u8_0;
                            nData = sqlite3_value_bytes(pData);
                            szUncompressed = nData;
                            iCrc32 =
                                crc32(0 as libc::c_int as uLong, aData, nData as uInt) as u32_0;
                            if iMethod < 0 as libc::c_int || iMethod == 8 as libc::c_int {
                                let mut nOut: libc::c_int = 0 as libc::c_int;
                                rc = zipfileDeflate(aData, nData, &mut aFree, &mut nOut, &mut zErr);
                                if rc != 0 as libc::c_int {
                                    current_block = 969838246212928024;
                                } else {
                                    if iMethod == 8 as libc::c_int || nOut < nData {
                                        aData = aFree;
                                        nData = nOut;
                                        iMethod = 8 as libc::c_int
                                    } else {
                                        iMethod = 0 as libc::c_int
                                    }
                                    current_block = 13619784596304402172;
                                }
                            } else {
                                current_block = 13619784596304402172;
                            }
                        }
                        match current_block {
                            969838246212928024 => {}
                            _ =>
                            /* Decode the "mode" argument. */
                            {
                                rc = zipfileGetMode(pMode, bIsDir, &mut mode, &mut zErr);
                                if !(rc != 0) {
                                    /* Decode the "mtime" argument. */
                                    e.mUnixTime = zipfileGetTime(pMtime);
                                    /* If this is a directory entry, ensure that there is exactly one '/'
                                     ** at the end of the path. Or, if this is not a directory and the path
                                     ** ends in '/' it is an error. */
                                    if bIsDir == 0 as libc::c_int {
                                        if nName > 0 as libc::c_int
                                            && *zName.offset((nName - 1 as libc::c_int) as isize)
                                                as libc::c_int
                                                == '/' as i32
                                        {
                                            zErr = sqlite3_mprintf(
                                                b"non-directory name must not end with /\x00"
                                                    as *const u8
                                                    as *const libc::c_char,
                                            );
                                            rc = 1 as libc::c_int;
                                            current_block = 969838246212928024;
                                        } else {
                                            current_block = 13707613154239713890;
                                        }
                                    } else if nName == 0 as libc::c_int
                                        || *zName.offset((nName - 1 as libc::c_int) as isize)
                                            as libc::c_int
                                            != '/' as i32
                                    {
                                        zFree = sqlite3_mprintf(
                                            b"%s/\x00" as *const u8 as *const libc::c_char,
                                            zName,
                                        );
                                        zName = zFree;
                                        if zName.is_null() {
                                            rc = 7 as libc::c_int;
                                            current_block = 969838246212928024;
                                        } else {
                                            nName = strlen(zName) as libc::c_int;
                                            current_block = 13707613154239713890;
                                        }
                                    } else {
                                        while nName > 1 as libc::c_int
                                            && *zName.offset((nName - 2 as libc::c_int) as isize)
                                                as libc::c_int
                                                == '/' as i32
                                        {
                                            nName -= 1
                                        }
                                        current_block = 13707613154239713890;
                                    }
                                    match current_block {
                                        969838246212928024 => {}
                                        _ =>
                                        /* Assemble the ZipfileEntry object for the new zip archive entry */
                                        {
                                            e.cds.iVersionMadeBy = (((3 as libc::c_int)
                                                << 8 as libc::c_int)
                                                + 30 as libc::c_int)
                                                as u16_0;
                                            e.cds.iVersionExtract = 20 as libc::c_int as u16_0;
                                            e.cds.flags = 0x800 as libc::c_int as u16_0;
                                            e.cds.iCompression = iMethod as u16_0;
                                            zipfileMtimeToDos(&mut e.cds, e.mUnixTime);
                                            e.cds.crc32 = iCrc32;
                                            e.cds.szCompressed = nData as u32_0;
                                            e.cds.szUncompressed = szUncompressed as u32_0;
                                            e.cds.iExternalAttr = mode << 16 as libc::c_int;
                                            e.cds.iOffset = (*p).body.n as u32_0;
                                            e.cds.nFile = nName as u16_0;
                                            e.cds.zFile = zName;
                                            /* Append the LFH to the body of the new archive */
                                            nByte = 30 as libc::c_int
                                                + e.cds.nFile as libc::c_int
                                                + 9 as libc::c_int;
                                            rc = zipfileBufferGrow(&mut (*p).body, nByte);
                                            if !(rc != 0) {
                                                (*p).body.n += zipfileSerializeLFH(
                                                    &mut e,
                                                    &mut *(*p).body.a.offset((*p).body.n as isize),
                                                );
                                                /* Append the data to the body of the new archive */
                                                if nData > 0 as libc::c_int {
                                                    rc = zipfileBufferGrow(&mut (*p).body, nData);
                                                    if rc != 0 {
                                                        current_block = 969838246212928024;
                                                    } else {
                                                        memcpy(
                                                            &mut *(*p)
                                                                .body
                                                                .a
                                                                .offset((*p).body.n as isize)
                                                                as *mut u8_0
                                                                as *mut libc::c_void,
                                                            aData as *const libc::c_void,
                                                            nData as libc::c_ulong,
                                                        );
                                                        (*p).body.n += nData;
                                                        current_block = 7318352876044315808;
                                                    }
                                                } else {
                                                    current_block = 7318352876044315808;
                                                }
                                                match current_block {
                                                    969838246212928024 => {}
                                                    _ =>
                                                    /* Append the CDS record to the directory of the new archive */
                                                    {
                                                        nByte = 46 as libc::c_int
                                                            + e.cds.nFile as libc::c_int
                                                            + 9 as libc::c_int;
                                                        rc =
                                                            zipfileBufferGrow(&mut (*p).cds, nByte);
                                                        if !(rc != 0) {
                                                            (*p).cds.n += zipfileSerializeCDS(
                                                                &mut e,
                                                                &mut *(*p)
                                                                    .cds
                                                                    .a
                                                                    .offset((*p).cds.n as isize),
                                                            );
                                                            /* Increment the count of entries in the archive */
                                                            (*p).nEntry += 1
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        sqlite3_free(aFree as *mut libc::c_void);
        sqlite3_free(zFree as *mut libc::c_void);
        if rc != 0 {
            if !zErr.is_null() {
                sqlite3_result_error(pCtx, zErr, -(1 as libc::c_int));
            } else {
                sqlite3_result_error_code(pCtx, rc);
            }
        }
        sqlite3_free(zErr as *mut libc::c_void);
        return;
    };
}
/*
** xFinalize() callback for zipfile aggregate function.
*/
pub unsafe extern "C" fn zipfileFinal(mut pCtx: *mut sqlite3_context) {
    let mut p: *mut ZipfileCtx = 0 as *mut ZipfileCtx;
    let mut eocd: ZipfileEOCD = ZipfileEOCD {
        iDisk: 0,
        iFirstDisk: 0,
        nEntry: 0,
        nEntryTotal: 0,
        nSize: 0,
        iOffset: 0,
    };
    let mut nZip: sqlite3_int64 = 0;
    let mut aZip: *mut u8_0 = 0 as *mut u8_0;
    p = sqlite3_aggregate_context(
        pCtx,
        ::std::mem::size_of::<ZipfileCtx>() as libc::c_ulong as libc::c_int,
    ) as *mut ZipfileCtx;
    if p.is_null() {
        return;
    } else {
        if (*p).nEntry > 0 as libc::c_int {
            memset(
                &mut eocd as *mut ZipfileEOCD as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<ZipfileEOCD>() as libc::c_ulong,
            );
            eocd.nEntry = (*p).nEntry as u16_0;
            eocd.nEntryTotal = (*p).nEntry as u16_0;
            eocd.nSize = (*p).cds.n as u32_0;
            eocd.iOffset = (*p).body.n as u32_0;
            nZip = ((*p).body.n + (*p).cds.n + 22 as libc::c_int) as sqlite3_int64;
            aZip = sqlite3_malloc64(nZip as sqlite3_uint64) as *mut u8_0;
            if aZip.is_null() {
                sqlite3_result_error_nomem(pCtx);
            } else {
                memcpy(
                    aZip as *mut libc::c_void,
                    (*p).body.a as *const libc::c_void,
                    (*p).body.n as libc::c_ulong,
                );
                memcpy(
                    &mut *aZip.offset((*p).body.n as isize) as *mut u8_0 as *mut libc::c_void,
                    (*p).cds.a as *const libc::c_void,
                    (*p).cds.n as libc::c_ulong,
                );
                zipfileSerializeEOCD(
                    &mut eocd,
                    &mut *aZip.offset(((*p).body.n + (*p).cds.n) as isize),
                );
                sqlite3_result_blob(
                    pCtx,
                    aZip as *const libc::c_void,
                    nZip as libc::c_int,
                    Some(zipfileFree as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
                );
            }
        }
        sqlite3_free((*p).body.a as *mut libc::c_void);
        sqlite3_free((*p).cds.a as *mut libc::c_void);
        return;
    };
}
/*
** Register the "zipfile" virtual table.
*/
unsafe extern "C" fn zipfileRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut zipfileModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 1 as libc::c_int,
                xCreate: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    zipfileConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    zipfileBestIndex
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    zipfileDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    zipfileDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    zipfileOpen
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    zipfileClose
                        as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    zipfileFilter
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: libc::c_int,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    zipfileNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    zipfileEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    zipfileColumn
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: None,
                xUpdate: Some(
                    zipfileUpdate
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                            _: *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: Some(
                    zipfileBegin as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xSync: None,
                xCommit: Some(
                    zipfileCommit as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xRollback: Some(
                    zipfileRollback as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xFindFunction: Some(
                    zipfileFindFunction
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: libc::c_int,
                            _: *const libc::c_char,
                            _: *mut Option<
                                unsafe extern "C" fn(
                                    _: *mut sqlite3_context,
                                    _: libc::c_int,
                                    _: *mut *mut sqlite3_value,
                                ) -> (),
                            >,
                            _: *mut *mut libc::c_void,
                        ) -> libc::c_int,
                ),
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"zipfile\x00" as *const u8 as *const libc::c_char,
        &mut zipfileModule,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_overload_function(
            db,
            b"zipfile_cds\x00" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"zipfile\x00" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
            1 as libc::c_int,
            0 as *mut libc::c_void,
            None,
            Some(
                zipfileStep
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            Some(zipfileFinal as unsafe extern "C" fn(_: *mut sqlite3_context) -> ()),
        )
    }
    return rc;
}
/* SQLITE_OMIT_VIRTUALTABLE */
pub unsafe extern "C" fn sqlite3_zipfile_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return zipfileRegister(db); /* Unused parameter */
}
/* ************************ End ../ext/misc/zipfile.c ********************/
/* ************************ Begin ../ext/misc/sqlar.c ******************/
/*
** 2017-12-17
**
** The author disclaims copyright to this source code.  In place of
** a legal notice, here is a blessing:
**
**    May you do good and not evil.
**    May you find forgiveness for yourself and forgive others.
**    May you share freely, never taking more than you give.
**
******************************************************************************
**
** Utility functions sqlar_compress() and sqlar_uncompress(). Useful
** for working with sqlar archives and used by the shell tool's built-in
** sqlar support.
*/
/* #include "sqlite3ext.h" */
/*
** Implementation of the "sqlar_compress(X)" SQL function.
**
** If the type of X is SQLITE_BLOB, and compressing that blob using
** zlib utility function compress() yields a smaller blob, return the
** compressed blob. Otherwise, return a copy of X.
**
** SQLar uses the "zlib format" for compressed content.  The zlib format
** contains a two-byte identification header and a four-byte checksum at
** the end.  This is different from ZIP which uses the raw deflate format.
**
** Future enhancements to SQLar might add support for new compression formats.
** If so, those new formats will be identified by alternative headers in the
** compressed data.
*/
unsafe extern "C" fn sqlarCompressFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int {
        let mut pData: *const Bytef =
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const Bytef;
        let mut nData: uLong =
            sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as uLong;
        let mut nOut: uLongf = compressBound(nData);
        let mut pOut: *mut Bytef = 0 as *mut Bytef;
        pOut = sqlite3_malloc(nOut as libc::c_int) as *mut Bytef;
        if pOut.is_null() {
            sqlite3_result_error_nomem(context);
            return;
        } else {
            if 0 as libc::c_int != compress(pOut, &mut nOut, pData, nData) {
                sqlite3_result_error(
                    context,
                    b"error in compress()\x00" as *const u8 as *const libc::c_char,
                    -(1 as libc::c_int),
                );
            } else if nOut < nData {
                sqlite3_result_blob(
                    context,
                    pOut as *const libc::c_void,
                    nOut as libc::c_int,
                    ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                        -(1 as libc::c_int) as libc::intptr_t,
                    ),
                );
            } else {
                sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
            }
            sqlite3_free(pOut as *mut libc::c_void);
        }
    } else {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    };
}
/*
** Implementation of the "sqlar_uncompress(X,SZ)" SQL function
**
** Parameter SZ is interpreted as an integer. If it is less than or
** equal to zero, then this function returns a copy of X. Or, if
** SZ is equal to the size of X when interpreted as a blob, also
** return a copy of X. Otherwise, decompress blob X using zlib
** utility function uncompress() and return the results (another
** blob).
*/
unsafe extern "C" fn sqlarUncompressFunc(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut nData: uLong = 0; /* Unused parameter */
    let mut sz: uLongf = 0;
    sz = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize)) as uLongf;
    if sz <= 0 as libc::c_int as libc::c_ulong || {
        nData = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as uLong;
        (sz) == nData
    } {
        sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
    } else {
        let mut pData: *const Bytef =
            sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const Bytef;
        let mut pOut: *mut Bytef = sqlite3_malloc(sz as libc::c_int) as *mut Bytef;
        if 0 as libc::c_int != uncompress(pOut, &mut sz, pData, nData) {
            sqlite3_result_error(
                context,
                b"error in uncompress()\x00" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            sqlite3_result_blob(
                context,
                pOut as *const libc::c_void,
                sz as libc::c_int,
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        sqlite3_free(pOut as *mut libc::c_void);
    };
}
pub unsafe extern "C" fn sqlite3_sqlar_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_create_function(
        db,
        b"sqlar_compress\x00" as *const u8 as *const libc::c_char,
        1 as libc::c_int,
        1 as libc::c_int | 0x200000 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            sqlarCompressFunc
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_function(
            db,
            b"sqlar_uncompress\x00" as *const u8 as *const libc::c_char,
            2 as libc::c_int,
            1 as libc::c_int | 0x200000 as libc::c_int,
            0 as *mut libc::c_void,
            Some(
                sqlarUncompressFunc
                    as unsafe extern "C" fn(
                        _: *mut sqlite3_context,
                        _: libc::c_int,
                        _: *mut *mut sqlite3_value,
                    ) -> (),
            ),
            None,
            None,
        )
    }
    return rc;
}
/* For EXPERT_REPORT_CANDIDATES */
/*
** Allocate and return nByte bytes of zeroed memory using sqlite3_malloc().
** If the allocation fails, set *pRc to SQLITE_NOMEM and return NULL.
*/
unsafe extern "C" fn idxMalloc(
    mut pRc: *mut libc::c_int,
    mut nByte: libc::c_int,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    pRet = sqlite3_malloc(nByte);
    if !pRet.is_null() {
        memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
    } else {
        *pRc = 7 as libc::c_int
    }
    return pRet;
}
/*
** Initialize an IdxHash hash table.
*/
unsafe extern "C" fn idxHashInit(mut pHash: *mut IdxHash) {
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
/*
** Reset an IdxHash hash table.
*/
unsafe extern "C" fn idxHashClear(mut pHash: *mut IdxHash) {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 1023 as libc::c_int {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pNext: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        pEntry = (*pHash).aHash[i as usize];
        while !pEntry.is_null() {
            pNext = (*pEntry).pHashNext;
            sqlite3_free((*pEntry).zVal2 as *mut libc::c_void);
            sqlite3_free(pEntry as *mut libc::c_void);
            pEntry = pNext
        }
        i += 1
    }
    memset(
        pHash as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<IdxHash>() as libc::c_ulong,
    );
}
/*
** Return the index of the hash bucket that the string specified by the
** arguments to this function belongs.
*/
unsafe extern "C" fn idxHashString(mut z: *const libc::c_char, mut n: libc::c_int) -> libc::c_int {
    let mut ret: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < n {
        ret = ret.wrapping_add(
            (ret << 3 as libc::c_int)
                .wrapping_add(*z.offset(i as isize) as libc::c_uchar as libc::c_uint),
        );
        i += 1
    }
    return ret.wrapping_rem(1023 as libc::c_int as libc::c_uint) as libc::c_int;
}
/*
** If zKey is already present in the hash table, return non-zero and do
** nothing. Otherwise, add an entry with key zKey and payload string zVal to
** the hash table passed as the second argument.
*/
unsafe extern "C" fn idxHashAdd(
    mut pRc: *mut libc::c_int,
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut zVal: *const libc::c_char,
) -> libc::c_int {
    let mut nKey: libc::c_int = strlen(zKey) as libc::c_int;
    let mut iHash: libc::c_int = idxHashString(zKey, nKey);
    let mut nVal: libc::c_int = if !zVal.is_null() {
        strlen(zVal) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return 1 as libc::c_int;
        } else {
            pEntry = (*pEntry).pHashNext
        }
    }
    pEntry = idxMalloc(
        pRc,
        (::std::mem::size_of::<IdxHashEntry>() as libc::c_ulong)
            .wrapping_add(nKey as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong)
            .wrapping_add(nVal as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxHashEntry;
    if !pEntry.is_null() {
        (*pEntry).zKey = &mut *pEntry.offset(1 as libc::c_int as isize) as *mut IdxHashEntry
            as *mut libc::c_char;
        memcpy(
            (*pEntry).zKey as *mut libc::c_void,
            zKey as *const libc::c_void,
            nKey as libc::c_ulong,
        );
        if !zVal.is_null() {
            (*pEntry).zVal = &mut *(*pEntry).zKey.offset((nKey + 1 as libc::c_int) as isize)
                as *mut libc::c_char;
            memcpy(
                (*pEntry).zVal as *mut libc::c_void,
                zVal as *const libc::c_void,
                nVal as libc::c_ulong,
            );
        }
        (*pEntry).pHashNext = (*pHash).aHash[iHash as usize];
        (*pHash).aHash[iHash as usize] = pEntry;
        (*pEntry).pNext = (*pHash).pFirst;
        (*pHash).pFirst = pEntry
    }
    return 0 as libc::c_int;
}
/*
** If zKey/nKey is present in the hash table, return a pointer to the
** hash-entry object.
*/
unsafe extern "C" fn idxHashFind(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *mut IdxHashEntry {
    let mut iHash: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    if nKey < 0 as libc::c_int {
        nKey = strlen(zKey) as libc::c_int
    }
    iHash = idxHashString(zKey, nKey);
    pEntry = (*pHash).aHash[iHash as usize];
    while !pEntry.is_null() {
        if strlen((*pEntry).zKey) as libc::c_int == nKey
            && 0 as libc::c_int
                == memcmp(
                    (*pEntry).zKey as *const libc::c_void,
                    zKey as *const libc::c_void,
                    nKey as libc::c_ulong,
                )
        {
            return pEntry;
        } else {
            pEntry = (*pEntry).pHashNext
        }
    }
    return 0 as *mut IdxHashEntry;
}
/*
** If the hash table contains an entry with a key equal to the string
** passed as the final two arguments to this function, return a pointer
** to the payload string. Otherwise, if zKey/nKey is not present in the
** hash table, return NULL.
*/
unsafe extern "C" fn idxHashSearch(
    mut pHash: *mut IdxHash,
    mut zKey: *const libc::c_char,
    mut nKey: libc::c_int,
) -> *const libc::c_char {
    let mut pEntry: *mut IdxHashEntry = idxHashFind(pHash, zKey, nKey);
    if !pEntry.is_null() {
        return (*pEntry).zVal;
    } else {
        return 0 as *const libc::c_char;
    };
}
/*
** Allocate and return a new IdxConstraint object. Set the IdxConstraint.zColl
** variable to point to a copy of nul-terminated string zColl.
*/
unsafe extern "C" fn idxNewConstraint(
    mut pRc: *mut libc::c_int,
    mut zColl: *const libc::c_char,
) -> *mut IdxConstraint {
    let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nColl: libc::c_int = strlen(zColl) as libc::c_int;
    pNew = idxMalloc(
        pRc,
        (::std::mem::size_of::<IdxConstraint>() as libc::c_ulong)
            .wrapping_mul(nColl as libc::c_ulong)
            .wrapping_add(1 as libc::c_int as libc::c_ulong) as libc::c_int,
    ) as *mut IdxConstraint;
    if !pNew.is_null() {
        (*pNew).zColl =
            &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxConstraint as *mut libc::c_char;
        memcpy(
            (*pNew).zColl as *mut libc::c_void,
            zColl as *const libc::c_void,
            (nColl + 1 as libc::c_int) as libc::c_ulong,
        );
    }
    return pNew;
}
/*
** An error associated with database handle db has just occurred. Pass
** the error message to callback function xOut.
*/
unsafe extern "C" fn idxDatabaseError(mut db: *mut sqlite3, mut pzErrmsg: *mut *mut libc::c_char)
/* Write error here */
{
    *pzErrmsg = sqlite3_mprintf(
        b"%s\x00" as *const u8 as *const libc::c_char,
        sqlite3_errmsg(db),
    );
}
/*
** Prepare an SQL statement.
*/
unsafe extern "C" fn idxPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zSql: *const libc::c_char,
) -> libc::c_int
/* SQL statement to compile */ {
    let mut rc: libc::c_int = sqlite3_prepare_v2(
        db,
        zSql,
        -(1 as libc::c_int),
        ppStmt,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int {
        *ppStmt = 0 as *mut sqlite3_stmt;
        idxDatabaseError(db, pzErrmsg);
    }
    return rc;
}
/*
** Prepare an SQL statement using the results of a printf() formatting.
*/
unsafe extern "C" fn idxPrintfPrepareStmt(
    mut db: *mut sqlite3,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut pzErrmsg: *mut *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int
/* printf() format of SQL statement */
 /* Trailing printf() arguments */ {
    let mut ap: ::std::ffi::VaListImpl;
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    zSql = sqlite3_vmprintf(zFmt, ap.as_va_list());
    if zSql.is_null() {
        rc = 7 as libc::c_int
    } else {
        rc = idxPrepareStmt(db, ppStmt, pzErrmsg, zSql);
        sqlite3_free(zSql as *mut libc::c_void);
    }
    return rc;
}
unsafe extern "C" fn expertDequote(mut zIn: *const libc::c_char) -> *mut libc::c_char {
    let mut n: libc::c_int = strlen(zIn) as libc::c_int;
    let mut zRet: *mut libc::c_char = sqlite3_malloc(n) as *mut libc::c_char;
    if !zRet.is_null() {
        let mut iOut: libc::c_int = 0 as libc::c_int;
        let mut iIn: libc::c_int = 0 as libc::c_int;
        iIn = 1 as libc::c_int;
        while iIn < n - 1 as libc::c_int {
            if *zIn.offset(iIn as isize) as libc::c_int == '\'' as i32 {
                iIn += 1
            }
            let fresh31 = iOut;
            iOut = iOut + 1;
            *zRet.offset(fresh31 as isize) = *zIn.offset(iIn as isize);
            iIn += 1
        }
        *zRet.offset(iOut as isize) = '\u{0}' as i32 as libc::c_char
    }
    return zRet;
}
/*
** This function is the implementation of both the xConnect and xCreate
** methods of the r-tree virtual table.
**
**   argv[0]   -> module name
**   argv[1]   -> database name
**   argv[2]   -> table name
**   argv[...] -> column names...
*/
unsafe extern "C" fn expertConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut argc: libc::c_int,
    mut argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pExpert: *mut sqlite3expert = pAux as *mut sqlite3expert;
    let mut p: *mut ExpertVtab = 0 as *mut ExpertVtab;
    let mut rc: libc::c_int = 0;
    if argc != 4 as libc::c_int {
        *pzErr = sqlite3_mprintf(b"internal error!\x00" as *const u8 as *const libc::c_char);
        rc = 1 as libc::c_int
    } else {
        let mut zCreateTable: *mut libc::c_char =
            expertDequote(*argv.offset(3 as libc::c_int as isize));
        if !zCreateTable.is_null() {
            rc = sqlite3_declare_vtab(db, zCreateTable);
            if rc == 0 as libc::c_int {
                p = idxMalloc(
                    &mut rc,
                    ::std::mem::size_of::<ExpertVtab>() as libc::c_ulong as libc::c_int,
                ) as *mut ExpertVtab
            }
            if rc == 0 as libc::c_int {
                (*p).pExpert = pExpert;
                (*p).pTab = (*pExpert).pTable
            }
            sqlite3_free(zCreateTable as *mut libc::c_void);
        } else {
            rc = 7 as libc::c_int
        }
    }
    *ppVtab = p as *mut sqlite3_vtab;
    return rc;
}
unsafe extern "C" fn expertDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    sqlite3_free(p as *mut libc::c_void);
    return 0 as libc::c_int;
}
unsafe extern "C" fn expertBestIndex(
    mut pVtab: *mut sqlite3_vtab,
    mut pIdxInfo: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut p: *mut ExpertVtab = pVtab as *mut ExpertVtab;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pScan: *mut IdxScan = 0 as *mut IdxScan;
    let opmask: libc::c_int = 2 as libc::c_int
        | 4 as libc::c_int
        | 16 as libc::c_int
        | 32 as libc::c_int
        | 8 as libc::c_int;
    pScan = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<IdxScan>() as libc::c_ulong as libc::c_int,
    ) as *mut IdxScan;
    if !pScan.is_null() {
        let mut i: libc::c_int = 0;
        /* Link the new scan object into the list */
        (*pScan).pTab = (*p).pTab;
        (*pScan).pNextScan = (*(*p).pExpert).pScan;
        (*(*p).pExpert).pScan = pScan;
        /* Add the constraints to the IdxScan object */
        i = 0 as libc::c_int;
        while i < (*pIdxInfo).nConstraint {
            let mut pCons: *mut sqlite3_index_constraint =
                &mut *(*pIdxInfo).aConstraint.offset(i as isize) as *mut sqlite3_index_constraint;
            if (*pCons).usable as libc::c_int != 0
                && (*pCons).iColumn >= 0 as libc::c_int
                && (*(*(*p).pTab).aCol.offset((*pCons).iColumn as isize)).iPk == 0 as libc::c_int
                && (*pCons).op as libc::c_int & opmask != 0
            {
                let mut pNew: *mut IdxConstraint = 0 as *mut IdxConstraint;
                let mut zColl: *const libc::c_char = sqlite3_vtab_collation(pIdxInfo, i);
                pNew = idxNewConstraint(&mut rc, zColl);
                if !pNew.is_null() {
                    (*pNew).iCol = (*pCons).iColumn;
                    if (*pCons).op as libc::c_int == 2 as libc::c_int {
                        (*pNew).pNext = (*pScan).pEq;
                        (*pScan).pEq = pNew
                    } else {
                        (*pNew).bRange = 1 as libc::c_int;
                        (*pNew).pNext = (*pScan).pRange;
                        (*pScan).pRange = pNew
                    }
                }
                n += 1;
                (*(*pIdxInfo).aConstraintUsage.offset(i as isize)).argvIndex = n
            }
            i += 1
        }
        /* Add the ORDER BY to the IdxScan object */
        i = (*pIdxInfo).nOrderBy - 1 as libc::c_int;
        while i >= 0 as libc::c_int {
            let mut iCol: libc::c_int = (*(*pIdxInfo).aOrderBy.offset(i as isize)).iColumn;
            if iCol >= 0 as libc::c_int {
                let mut pNew_0: *mut IdxConstraint =
                    idxNewConstraint(&mut rc, (*(*(*p).pTab).aCol.offset(iCol as isize)).zColl);
                if !pNew_0.is_null() {
                    (*pNew_0).iCol = iCol;
                    (*pNew_0).bDesc =
                        (*(*pIdxInfo).aOrderBy.offset(i as isize)).desc as libc::c_int;
                    (*pNew_0).pNext = (*pScan).pOrder;
                    (*pNew_0).pLink = (*pScan).pOrder;
                    (*pScan).pOrder = pNew_0;
                    n += 1
                }
            }
            i -= 1
        }
    }
    (*pIdxInfo).estimatedCost = 1000000.0f64 / (n + 1 as libc::c_int) as libc::c_double;
    return rc;
}
unsafe extern "C" fn expertUpdate(
    mut _pVtab: *mut sqlite3_vtab,
    mut _nData: libc::c_int,
    mut _azData: *mut *mut sqlite3_value,
    mut _pRowid: *mut sqlite_int64,
) -> libc::c_int {
    return 0 as libc::c_int;
}
/*
** Virtual table module xOpen method.
*/
unsafe extern "C" fn expertOpen(
    mut _pVTab: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pCsr: *mut ExpertCsr = 0 as *mut ExpertCsr;
    pCsr = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<ExpertCsr>() as libc::c_ulong as libc::c_int,
    ) as *mut ExpertCsr;
    *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
    return rc;
}
/*
** Virtual table module xClose method.
*/
unsafe extern "C" fn expertClose(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    sqlite3_finalize((*pCsr).pData);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Virtual table module xEof method.
**
** Return non-zero if the cursor does not currently point to a valid
** record (i.e if the scan has finished), or zero otherwise.
*/
unsafe extern "C" fn expertEof(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    return ((*pCsr).pData == 0 as *mut sqlite3_stmt) as libc::c_int;
}
/*
** Virtual table module xNext method.
*/
unsafe extern "C" fn expertNext(mut cur: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut rc: libc::c_int = 0 as libc::c_int;
    rc = sqlite3_step((*pCsr).pData);
    if rc != 100 as libc::c_int {
        rc = sqlite3_finalize((*pCsr).pData);
        (*pCsr).pData = 0 as *mut sqlite3_stmt
    } else {
        rc = 0 as libc::c_int
    }
    return rc;
}
/*
** Virtual table module xRowid method.
*/
unsafe extern "C" fn expertRowid(
    mut _cur: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    *pRowid = 0 as libc::c_int as sqlite_int64;
    return 0 as libc::c_int;
}
/*
** Virtual table module xColumn method.
*/
unsafe extern "C" fn expertColumn(
    mut cur: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVal: *mut sqlite3_value = 0 as *mut sqlite3_value;
    pVal = sqlite3_column_value((*pCsr).pData, i);
    if !pVal.is_null() {
        sqlite3_result_value(ctx, pVal);
    }
    return 0 as libc::c_int;
}
/*
** Virtual table module xFilter method.
*/
unsafe extern "C" fn expertFilter(
    mut cur: *mut sqlite3_vtab_cursor,
    mut _idxNum: libc::c_int,
    mut _idxStr: *const libc::c_char,
    mut _argc: libc::c_int,
    mut _argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCsr: *mut ExpertCsr = cur as *mut ExpertCsr;
    let mut pVtab: *mut ExpertVtab = (*cur).pVtab as *mut ExpertVtab;
    let mut pExpert: *mut sqlite3expert = (*pVtab).pExpert;
    let mut rc: libc::c_int = 0;
    rc = sqlite3_finalize((*pCsr).pData);
    (*pCsr).pData = 0 as *mut sqlite3_stmt;
    if rc == 0 as libc::c_int {
        rc = idxPrintfPrepareStmt(
            (*pExpert).db,
            &mut (*pCsr).pData as *mut *mut sqlite3_stmt,
            &mut (*pVtab).base.zErrMsg as *mut *mut libc::c_char,
            b"SELECT * FROM main.%Q WHERE sample()\x00" as *const u8 as *const libc::c_char,
            (*(*pVtab).pTab).zName,
        )
    }
    if rc == 0 as libc::c_int {
        rc = expertNext(cur)
    }
    return rc;
}
unsafe extern "C" fn idxRegisterVtab(mut p: *mut sqlite3expert) -> libc::c_int {
    static mut expertModule: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 2 as libc::c_int,
                xCreate: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xConnect: Some(
                    expertConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    expertBestIndex
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    expertDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: Some(
                    expertDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xOpen: Some(
                    expertOpen
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    expertClose as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    expertFilter
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: libc::c_int,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    expertNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    expertEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    expertColumn
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    expertRowid
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: Some(
                    expertUpdate
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                            _: *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    return sqlite3_create_module(
        (*p).dbv,
        b"expert\x00" as *const u8 as *const libc::c_char,
        &mut expertModule,
        p as *mut libc::c_void,
    );
}
/*
** End of virtual table implementation.
*************************************************************************/
/*
** Finalize SQL statement pStmt. If (*pRc) is SQLITE_OK when this function
** is called, set it to the return value of sqlite3_finalize() before
** returning. Otherwise, discard the sqlite3_finalize() return value.
*/
unsafe extern "C" fn idxFinalize(mut pRc: *mut libc::c_int, mut pStmt: *mut sqlite3_stmt) {
    let mut rc: libc::c_int = sqlite3_finalize(pStmt);
    if *pRc == 0 as libc::c_int {
        *pRc = rc
    };
}
/*
** Attempt to allocate an IdxTable structure corresponding to table zTab
** in the main database of connection db. If successful, set (*ppOut) to
** point to the new object and return SQLITE_OK. Otherwise, return an
** SQLite error code and set (*ppOut) to NULL. In this case *pzErrmsg may be
** set to point to an error string.
**
** It is the responsibility of the caller to eventually free either the
** IdxTable object or error message using sqlite3_free().
*/
unsafe extern "C" fn idxGetTableInfo(
    mut db: *mut sqlite3,
    mut zTab: *const libc::c_char,
    mut ppOut: *mut *mut IdxTable,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message (if not) */ {
    let mut p1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nTab: libc::c_int = strlen(zTab) as libc::c_int;
    let mut nByte: libc::c_int = (::std::mem::size_of::<IdxTable>() as libc::c_ulong)
        .wrapping_add(nTab as libc::c_ulong)
        .wrapping_add(1 as libc::c_int as libc::c_ulong)
        as libc::c_int;
    let mut pNew: *mut IdxTable = 0 as *mut IdxTable;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut pCsr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nPk: libc::c_int = 0 as libc::c_int;
    rc = idxPrintfPrepareStmt(
        db,
        &mut p1 as *mut *mut sqlite3_stmt,
        pzErrmsg,
        b"PRAGMA table_xinfo=%Q\x00" as *const u8 as *const libc::c_char,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol: *const libc::c_char =
            sqlite3_column_text(p1, 1 as libc::c_int) as *const libc::c_char;
        let mut zColSeq: *const libc::c_char = 0 as *const libc::c_char;
        nByte += 1 as libc::c_int + strlen(zCol) as libc::c_int;
        rc = sqlite3_table_column_metadata(
            db,
            b"main\x00" as *const u8 as *const libc::c_char,
            zTab,
            zCol,
            0 as *mut *const libc::c_char,
            &mut zColSeq,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
        if zColSeq.is_null() {
            zColSeq = b"binary\x00" as *const u8 as *const libc::c_char
        }
        nByte += 1 as libc::c_int + strlen(zColSeq) as libc::c_int;
        nCol += 1;
        nPk += (sqlite3_column_int(p1, 5 as libc::c_int) > 0 as libc::c_int) as libc::c_int
    }
    rc2 = sqlite3_reset(p1);
    if rc == 0 as libc::c_int {
        rc = rc2
    }
    nByte = (nByte as libc::c_ulong).wrapping_add(
        (::std::mem::size_of::<IdxColumn>() as libc::c_ulong).wrapping_mul(nCol as libc::c_ulong),
    ) as libc::c_int as libc::c_int;
    if rc == 0 as libc::c_int {
        pNew = idxMalloc(&mut rc, nByte) as *mut IdxTable
    }
    if rc == 0 as libc::c_int {
        (*pNew).aCol =
            &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxTable as *mut IdxColumn;
        (*pNew).nCol = nCol;
        pCsr = &mut *(*pNew).aCol.offset(nCol as isize) as *mut IdxColumn as *mut libc::c_char
    }
    nCol = 0 as libc::c_int;
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(p1) {
        let mut zCol_0: *const libc::c_char =
            sqlite3_column_text(p1, 1 as libc::c_int) as *const libc::c_char;
        let mut zColSeq_0: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCopy: libc::c_int = strlen(zCol_0) as libc::c_int + 1 as libc::c_int;
        let ref mut fresh32 = (*(*pNew).aCol.offset(nCol as isize)).zName;
        *fresh32 = pCsr;
        (*(*pNew).aCol.offset(nCol as isize)).iPk =
            (sqlite3_column_int(p1, 5 as libc::c_int) == 1 as libc::c_int
                && nPk == 1 as libc::c_int) as libc::c_int;
        memcpy(
            pCsr as *mut libc::c_void,
            zCol_0 as *const libc::c_void,
            nCopy as libc::c_ulong,
        );
        pCsr = pCsr.offset(nCopy as isize);
        rc = sqlite3_table_column_metadata(
            db,
            b"main\x00" as *const u8 as *const libc::c_char,
            zTab,
            zCol_0,
            0 as *mut *const libc::c_char,
            &mut zColSeq_0,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        );
        if rc == 0 as libc::c_int {
            if zColSeq_0.is_null() {
                zColSeq_0 = b"binary\x00" as *const u8 as *const libc::c_char
            }
            nCopy = strlen(zColSeq_0) as libc::c_int + 1 as libc::c_int;
            let ref mut fresh33 = (*(*pNew).aCol.offset(nCol as isize)).zColl;
            *fresh33 = pCsr;
            memcpy(
                pCsr as *mut libc::c_void,
                zColSeq_0 as *const libc::c_void,
                nCopy as libc::c_ulong,
            );
            pCsr = pCsr.offset(nCopy as isize)
        }
        nCol += 1
    }
    idxFinalize(&mut rc, p1);
    if rc != 0 as libc::c_int {
        sqlite3_free(pNew as *mut libc::c_void);
        pNew = 0 as *mut IdxTable
    } else if !pNew.is_null() {
        (*pNew).zName = pCsr;
        if !(*pNew).zName.is_null() {
            memcpy(
                (*pNew).zName as *mut libc::c_void,
                zTab as *const libc::c_void,
                (nTab + 1 as libc::c_int) as libc::c_ulong,
            );
        }
    }
    *ppOut = pNew;
    return rc;
}
/*
** This function is a no-op if *pRc is set to anything other than
** SQLITE_OK when it is called.
**
** If *pRc is initially set to SQLITE_OK, then the text specified by
** the printf() style arguments is appended to zIn and the result returned
** in a buffer allocated by sqlite3_malloc(). sqlite3_free() is called on
** zIn before returning.
*/
unsafe extern "C" fn idxAppendText(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut ap: ::std::ffi::VaListImpl;
    let mut zAppend: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nIn: libc::c_int = if !zIn.is_null() {
        strlen(zIn) as libc::c_int
    } else {
        0 as libc::c_int
    };
    let mut nAppend: libc::c_int = 0 as libc::c_int;
    ap = args.clone();
    if *pRc == 0 as libc::c_int {
        zAppend = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if !zAppend.is_null() {
            nAppend = strlen(zAppend) as libc::c_int;
            zRet = sqlite3_malloc(nIn + nAppend + 1 as libc::c_int) as *mut libc::c_char
        }
        if !zAppend.is_null() && !zRet.is_null() {
            if nIn != 0 {
                memcpy(
                    zRet as *mut libc::c_void,
                    zIn as *const libc::c_void,
                    nIn as libc::c_ulong,
                );
            }
            memcpy(
                &mut *zRet.offset(nIn as isize) as *mut libc::c_char as *mut libc::c_void,
                zAppend as *const libc::c_void,
                (nAppend + 1 as libc::c_int) as libc::c_ulong,
            );
        } else {
            sqlite3_free(zRet as *mut libc::c_void);
            zRet = 0 as *mut libc::c_char;
            *pRc = 7 as libc::c_int
        }
        sqlite3_free(zAppend as *mut libc::c_void);
        sqlite3_free(zIn as *mut libc::c_void);
    }
    return zRet;
}
/*
** Return true if zId must be quoted in order to use it as an SQL
** identifier, or false otherwise.
*/
unsafe extern "C" fn idxIdentifierRequiresQuotes(mut zId: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *zId.offset(i as isize) != 0 {
        if !(*zId.offset(i as isize) as libc::c_int == '_' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= '0' as i32
                && *zId.offset(i as isize) as libc::c_int <= '9' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'a' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'z' as i32)
            && !(*zId.offset(i as isize) as libc::c_int >= 'A' as i32
                && *zId.offset(i as isize) as libc::c_int <= 'Z' as i32)
        {
            return 1 as libc::c_int;
        } else {
            i += 1
        }
    }
    return 0 as libc::c_int;
}
/*
** This function appends an index column definition suitable for constraint
** pCons to the string passed as zIn and returns the result.
*/
unsafe extern "C" fn idxAppendColDefn(
    mut pRc: *mut libc::c_int,
    mut zIn: *mut libc::c_char,
    mut pTab: *mut IdxTable,
    mut pCons: *mut IdxConstraint,
) -> *mut libc::c_char {
    let mut zRet: *mut libc::c_char = zIn;
    let mut p: *mut IdxColumn = &mut *(*pTab).aCol.offset((*pCons).iCol as isize) as *mut IdxColumn;
    if !zRet.is_null() {
        zRet = idxAppendText(pRc, zRet, b", \x00" as *const u8 as *const libc::c_char)
    }
    if idxIdentifierRequiresQuotes((*p).zName) != 0 {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%Q\x00" as *const u8 as *const libc::c_char,
            (*p).zName,
        )
    } else {
        zRet = idxAppendText(
            pRc,
            zRet,
            b"%s\x00" as *const u8 as *const libc::c_char,
            (*p).zName,
        )
    }
    if sqlite3_stricmp((*p).zColl, (*pCons).zColl) != 0 {
        if idxIdentifierRequiresQuotes((*pCons).zColl) != 0 {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %Q\x00" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            )
        } else {
            zRet = idxAppendText(
                pRc,
                zRet,
                b" COLLATE %s\x00" as *const u8 as *const libc::c_char,
                (*pCons).zColl,
            )
        }
    }
    if (*pCons).bDesc != 0 {
        zRet = idxAppendText(pRc, zRet, b" DESC\x00" as *const u8 as *const libc::c_char)
    }
    return zRet;
}
/*
** Search database dbm for an index compatible with the one idxCreateFromCons()
** would create from arguments pScan, pEq and pTail. If no error occurs and
** such an index is found, return non-zero. Or, if no such index is found,
** return zero.
**
** If an error occurs, set *pRc to an SQLite error code and return zero.
*/
unsafe extern "C" fn idxFindCompatible(
    mut pRc: *mut libc::c_int,
    mut dbm: *mut sqlite3,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int
/* List of range constraints */ {
    let mut zTbl: *const libc::c_char = (*(*pScan).pTab).zName; /* Number of elements in pEq */
    let mut pIdxList: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIter: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut nEq: libc::c_int = 0 as libc::c_int;
    let mut rc: libc::c_int = 0;
    /* Count the elements in list pEq */
    pIter = pEq;
    while !pIter.is_null() {
        nEq += 1;
        pIter = (*pIter).pLink
    }
    rc = idxPrintfPrepareStmt(
        dbm,
        &mut pIdxList as *mut *mut sqlite3_stmt,
        0 as *mut *mut libc::c_char,
        b"PRAGMA index_list=%Q\x00" as *const u8 as *const libc::c_char,
        zTbl,
    );
    while rc == 0 as libc::c_int && sqlite3_step(pIdxList) == 100 as libc::c_int {
        let mut bMatch: libc::c_int = 1 as libc::c_int;
        let mut pT: *mut IdxConstraint = pTail;
        let mut pInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        let mut zIdx: *const libc::c_char =
            sqlite3_column_text(pIdxList, 1 as libc::c_int) as *const libc::c_char;
        /* Zero the IdxConstraint.bFlag values in the pEq list */
        pIter = pEq;
        while !pIter.is_null() {
            (*pIter).bFlag = 0 as libc::c_int;
            pIter = (*pIter).pLink
        }
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pInfo as *mut *mut sqlite3_stmt,
            0 as *mut *mut libc::c_char,
            b"PRAGMA index_xInfo=%Q\x00" as *const u8 as *const libc::c_char,
            zIdx,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pInfo) == 100 as libc::c_int {
            let mut iIdx: libc::c_int = sqlite3_column_int(pInfo, 0 as libc::c_int);
            let mut iCol: libc::c_int = sqlite3_column_int(pInfo, 1 as libc::c_int);
            let mut zColl: *const libc::c_char =
                sqlite3_column_text(pInfo, 4 as libc::c_int) as *const libc::c_char;
            if iIdx < nEq {
                pIter = pEq;
                while !pIter.is_null() {
                    if !((*pIter).bFlag != 0) {
                        if !((*pIter).iCol != iCol) {
                            if !(sqlite3_stricmp((*pIter).zColl, zColl) != 0) {
                                (*pIter).bFlag = 1 as libc::c_int;
                                break;
                            }
                        }
                    }
                    pIter = (*pIter).pLink
                }
                if !pIter.is_null() {
                    continue;
                }
                bMatch = 0 as libc::c_int;
                break;
            } else {
                if pT.is_null() {
                    continue;
                }
                if (*pT).iCol != iCol || sqlite3_stricmp((*pT).zColl, zColl) != 0 {
                    bMatch = 0 as libc::c_int;
                    break;
                } else {
                    pT = (*pT).pLink
                }
            }
        }
        idxFinalize(&mut rc, pInfo);
        if !(rc == 0 as libc::c_int && bMatch != 0) {
            continue;
        }
        sqlite3_finalize(pIdxList);
        return 1 as libc::c_int;
    }
    idxFinalize(&mut rc, pIdxList);
    *pRc = rc;
    return 0 as libc::c_int;
}
/* Callback for sqlite3_exec() with query with leading count(*) column.
 * The first argument is expected to be an int*, referent to be incremented
 * if that leading column is not exactly '0'.
 */
unsafe extern "C" fn countNonzeros(
    mut pCount: *mut libc::c_void,
    mut nc: libc::c_int,
    mut azResults: *mut *mut libc::c_char,
    mut _azColumns: *mut *mut libc::c_char,
) -> libc::c_int {
    if nc > 0 as libc::c_int
        && (*(*azResults.offset(0 as libc::c_int as isize)).offset(0 as libc::c_int as isize)
            as libc::c_int
            != '0' as i32
            || *(*azResults.offset(0 as libc::c_int as isize)).offset(1 as libc::c_int as isize)
                as libc::c_int
                != 0 as libc::c_int)
    {
        *(pCount as *mut libc::c_int) += 1 as libc::c_int
    } /* Suppress unused parameter warning */
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromCons(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pEq: *mut IdxConstraint,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int {
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (!pEq.is_null() || !pTail.is_null())
        && 0 as libc::c_int == idxFindCompatible(&mut rc, dbm, pScan, pEq, pTail)
    {
        let mut pTab: *mut IdxTable = (*pScan).pTab;
        let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut zIdx: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut pCons: *mut IdxConstraint = 0 as *mut IdxConstraint;
        let mut h: libc::c_uint = 0 as libc::c_int as libc::c_uint;
        let mut zFmt: *const libc::c_char = 0 as *const libc::c_char;
        pCons = pEq;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink
        }
        pCons = pTail;
        while !pCons.is_null() {
            zCols = idxAppendColDefn(&mut rc, zCols, pTab, pCons);
            pCons = (*pCons).pLink
        }
        if rc == 0 as libc::c_int {
            /* Hash the list of columns to come up with a name for the index */
            let mut zTable: *const libc::c_char = (*(*pScan).pTab).zName; /* Index name */
            let mut quoteTable: libc::c_int = idxIdentifierRequiresQuotes(zTable);
            let mut zName: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut collisions: libc::c_int = 0 as libc::c_int;
            loop {
                let mut i: libc::c_int = 0;
                let mut zFind: *mut libc::c_char = 0 as *mut libc::c_char;
                i = 0 as libc::c_int;
                while *zCols.offset(i as isize) != 0 {
                    h = h.wrapping_add(
                        (h << 3 as libc::c_int)
                            .wrapping_add(*zCols.offset(i as isize) as libc::c_uint),
                    );
                    i += 1
                }
                sqlite3_free(zName as *mut libc::c_void);
                zName = sqlite3_mprintf(
                    b"%s_idx_%08x\x00" as *const u8 as *const libc::c_char,
                    zTable,
                    h,
                );
                if zName.is_null() {
                    break;
                }
                /* Is is unique among table, view and index names? */
                zFmt =
                    b"SELECT count(*) FROM sqlite_schema WHERE name=%Q AND type in (\'index\',\'table\',\'view\')\x00"
                        as *const u8 as *const libc::c_char;
                zFind = sqlite3_mprintf(zFmt, zName);
                i = 0 as libc::c_int;
                rc = sqlite3_exec(
                    dbm,
                    zFind,
                    Some(
                        countNonzeros
                            as unsafe extern "C" fn(
                                _: *mut libc::c_void,
                                _: libc::c_int,
                                _: *mut *mut libc::c_char,
                                _: *mut *mut libc::c_char,
                            ) -> libc::c_int,
                    ),
                    &mut i as *mut libc::c_int as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_free(zFind as *mut libc::c_void);
                if i == 0 as libc::c_int {
                    collisions = 0 as libc::c_int;
                    break;
                } else {
                    collisions += 1;
                    if !(collisions < 50 as libc::c_int && !zName.is_null()) {
                        break;
                    }
                }
            }
            if collisions != 0 {
                /* This return means "Gave up trying to find a unique index name." */
                rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int
            } else if zName.is_null() {
                rc = 7 as libc::c_int
            } else {
                if quoteTable != 0 {
                    zFmt =
                        b"CREATE INDEX \"%w\" ON \"%w\"(%s)\x00" as *const u8 as *const libc::c_char
                } else {
                    zFmt = b"CREATE INDEX %s ON %s(%s)\x00" as *const u8 as *const libc::c_char
                }
                zIdx = sqlite3_mprintf(zFmt, zName, zTable, zCols);
                if zIdx.is_null() {
                    rc = 7 as libc::c_int
                } else {
                    rc = sqlite3_exec(dbm, zIdx, None, 0 as *mut libc::c_void, (*p).pzErrmsg);
                    if rc != 0 as libc::c_int {
                        rc = 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int
                    } else {
                        idxHashAdd(&mut rc, &mut (*p).hIdx, zName, zIdx);
                    }
                }
                sqlite3_free(zName as *mut libc::c_void);
                sqlite3_free(zIdx as *mut libc::c_void);
            }
        }
        sqlite3_free(zCols as *mut libc::c_void);
    }
    return rc;
}
/*
** Return true if list pList (linked by IdxConstraint.pLink) contains
** a constraint compatible with *p. Otherwise return false.
*/
unsafe extern "C" fn idxFindConstraint(
    mut pList: *mut IdxConstraint,
    mut p: *mut IdxConstraint,
) -> libc::c_int {
    let mut pCmp: *mut IdxConstraint = 0 as *mut IdxConstraint;
    pCmp = pList;
    while !pCmp.is_null() {
        if (*p).iCol == (*pCmp).iCol {
            return 1 as libc::c_int;
        } else {
            pCmp = (*pCmp).pLink
        }
    }
    return 0 as libc::c_int;
}
unsafe extern "C" fn idxCreateFromWhere(
    mut p: *mut sqlite3expert,
    mut pScan: *mut IdxScan,
    mut pTail: *mut IdxConstraint,
) -> libc::c_int
/* range/ORDER BY constraints for inclusion */ {
    let mut p1: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut pCon: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut rc: libc::c_int = 0;
    /* Gather up all the == constraints. */
    pCon = (*pScan).pEq;
    while !pCon.is_null() {
        if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
            (*pCon).pLink = p1;
            p1 = pCon
        }
        pCon = (*pCon).pNext
    }
    /* Create an index using the == constraints collected above. And the
     ** range constraint/ORDER BY terms passed in by the caller, if any. */
    rc = idxCreateFromCons(p, pScan, p1, pTail);
    /* If no range/ORDER BY passed by the caller, create a version of the
     ** index for each range constraint.  */
    if pTail.is_null() {
        pCon = (*pScan).pRange;
        while rc == 0 as libc::c_int && !pCon.is_null() {
            if idxFindConstraint(p1, pCon) == 0 && idxFindConstraint(pTail, pCon) == 0 {
                rc = idxCreateFromCons(p, pScan, p1, pCon)
            }
            pCon = (*pCon).pNext
        }
    }
    return rc;
}
/*
** Create candidate indexes in database [dbm] based on the data in
** linked-list pScan.
*/
unsafe extern "C" fn idxCreateCandidates(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pIter: *mut IdxScan = 0 as *mut IdxScan;
    pIter = (*p).pScan;
    while !pIter.is_null() && rc == 0 as libc::c_int {
        rc = idxCreateFromWhere(p, pIter, 0 as *mut IdxConstraint);
        if rc == 0 as libc::c_int && !(*pIter).pOrder.is_null() {
            rc = idxCreateFromWhere(p, pIter, (*pIter).pOrder)
        }
        pIter = (*pIter).pNextScan
    }
    return rc;
}
/*
** Free all elements of the linked list starting at pConstraint.
*/
unsafe extern "C" fn idxConstraintFree(mut pConstraint: *mut IdxConstraint) {
    let mut pNext: *mut IdxConstraint = 0 as *mut IdxConstraint;
    let mut p: *mut IdxConstraint = 0 as *mut IdxConstraint;
    p = pConstraint;
    while !p.is_null() {
        pNext = (*p).pNext;
        sqlite3_free(p as *mut libc::c_void);
        p = pNext
    }
}
/*
** Free all elements of the linked list starting from pScan up until pLast
** (pLast is not freed).
*/
unsafe extern "C" fn idxScanFree(mut pScan: *mut IdxScan, mut pLast: *mut IdxScan) {
    let mut p: *mut IdxScan = 0 as *mut IdxScan;
    let mut pNext: *mut IdxScan = 0 as *mut IdxScan;
    p = pScan;
    while p != pLast {
        pNext = (*p).pNextScan;
        idxConstraintFree((*p).pOrder);
        idxConstraintFree((*p).pEq);
        idxConstraintFree((*p).pRange);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext
    }
}
/*
** Free all elements of the linked list starting from pStatement up
** until pLast (pLast is not freed).
*/
unsafe extern "C" fn idxStatementFree(
    mut pStatement: *mut IdxStatement,
    mut pLast: *mut IdxStatement,
) {
    let mut p: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut pNext: *mut IdxStatement = 0 as *mut IdxStatement;
    p = pStatement;
    while p != pLast {
        pNext = (*p).pNext;
        sqlite3_free((*p).zEQP as *mut libc::c_void);
        sqlite3_free((*p).zIdx as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
        p = pNext
    }
}
/*
** Free the linked list of IdxTable objects starting at pTab.
*/
unsafe extern "C" fn idxTableFree(mut pTab: *mut IdxTable) {
    let mut pIter: *mut IdxTable = 0 as *mut IdxTable;
    let mut pNext: *mut IdxTable = 0 as *mut IdxTable;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext
    }
}
/*
** Free the linked list of IdxWrite objects starting at pTab.
*/
unsafe extern "C" fn idxWriteFree(mut pTab: *mut IdxWrite) {
    let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pNext: *mut IdxWrite = 0 as *mut IdxWrite;
    pIter = pTab;
    while !pIter.is_null() {
        pNext = (*pIter).pNext;
        sqlite3_free(pIter as *mut libc::c_void);
        pIter = pNext
    }
}
/*
** This function is called after candidate indexes have been created. It
** runs all the queries to see which indexes they prefer, and populates
** IdxStatement.zIdx and IdxStatement.zEQP with the results.
*/
pub unsafe extern "C" fn idxFindIndexes(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message (sqlite3_malloc) */ {
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    let mut dbm: *mut sqlite3 = (*p).dbm;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut hIdx: IdxHash = IdxHash {
        pFirst: 0 as *mut IdxHashEntry,
        aHash: [0 as *mut IdxHashEntry; 1023],
    };
    idxHashInit(&mut hIdx);
    pStmt = (*p).pStatement;
    's_18: while rc == 0 as libc::c_int && !pStmt.is_null() {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        idxHashClear(&mut hIdx);
        rc = idxPrintfPrepareStmt(
            dbm,
            &mut pExplain as *mut *mut sqlite3_stmt,
            pzErr,
            b"EXPLAIN QUERY PLAN %s\x00" as *const u8 as *const libc::c_char,
            (*pStmt).zSql,
        );
        while rc == 0 as libc::c_int && sqlite3_step(pExplain) == 100 as libc::c_int {
            /* int iId = sqlite3_column_int(pExplain, 0); */
            /* int iParent = sqlite3_column_int(pExplain, 1); */
            /* int iNotUsed = sqlite3_column_int(pExplain, 2); */
            let mut zDetail: *const libc::c_char =
                sqlite3_column_text(pExplain, 3 as libc::c_int) as *const libc::c_char;
            let mut nDetail: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            if zDetail.is_null() {
                continue;
            }
            nDetail = strlen(zDetail) as libc::c_int;
            i = 0 as libc::c_int;
            while i < nDetail {
                let mut zIdx: *const libc::c_char = 0 as *const libc::c_char;
                if (i + 13 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char as *const libc::c_void,
                        b" USING INDEX \x00" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        13 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 13 as libc::c_int) as isize) as *const libc::c_char
                } else if (i + 22 as libc::c_int) < nDetail
                    && memcmp(
                        &*zDetail.offset(i as isize) as *const libc::c_char as *const libc::c_void,
                        b" USING COVERING INDEX \x00" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        22 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                {
                    zIdx = &*zDetail.offset((i + 22 as libc::c_int) as isize) as *const libc::c_char
                }
                if !zIdx.is_null() {
                    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
                    let mut nIdx: libc::c_int = 0 as libc::c_int;
                    while *zIdx.offset(nIdx as isize) as libc::c_int != '\u{0}' as i32
                        && (*zIdx.offset(nIdx as isize) as libc::c_int != ' ' as i32
                            || *zIdx.offset((nIdx + 1 as libc::c_int) as isize) as libc::c_int
                                != '(' as i32)
                    {
                        nIdx += 1
                    }
                    zSql = idxHashSearch(&mut (*p).hIdx, zIdx, nIdx);
                    if zSql.is_null() {
                        break;
                    }
                    idxHashAdd(&mut rc, &mut hIdx, zSql, 0 as *const libc::c_char);
                    if rc != 0 {
                        break 's_18;
                    } else {
                        break;
                    }
                } else {
                    i += 1
                }
            }
            if !(*zDetail.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32) {
                continue;
            }
            (*pStmt).zEQP = idxAppendText(
                &mut rc as *mut libc::c_int,
                (*pStmt).zEQP,
                b"%s\n\x00" as *const u8 as *const libc::c_char,
                zDetail,
            )
        }
        pEntry = hIdx.pFirst;
        while !pEntry.is_null() {
            (*pStmt).zIdx = idxAppendText(
                &mut rc as *mut libc::c_int,
                (*pStmt).zIdx,
                b"%s;\n\x00" as *const u8 as *const libc::c_char,
                (*pEntry).zKey,
            );
            pEntry = (*pEntry).pNext
        }
        idxFinalize(&mut rc, pExplain);
        pStmt = (*pStmt).pNext
    }
    idxHashClear(&mut hIdx);
    return rc;
}
unsafe extern "C" fn idxAuthCallback(
    mut pCtx: *mut libc::c_void,
    mut eOp: libc::c_int,
    mut z3: *const libc::c_char,
    mut _z4: *const libc::c_char,
    mut zDb: *const libc::c_char,
    mut _zTrigger: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if eOp == 18 as libc::c_int || eOp == 23 as libc::c_int || eOp == 9 as libc::c_int {
        if sqlite3_stricmp(zDb, b"main\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        {
            let mut p: *mut sqlite3expert = pCtx as *mut sqlite3expert;
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            pTab = (*p).pTable;
            while !pTab.is_null() {
                if 0 as libc::c_int == sqlite3_stricmp(z3, (*pTab).zName) {
                    break;
                }
                pTab = (*pTab).pNext
            }
            if !pTab.is_null() {
                let mut pWrite: *mut IdxWrite = 0 as *mut IdxWrite;
                pWrite = (*p).pWrite;
                while !pWrite.is_null() {
                    if (*pWrite).pTab == pTab && (*pWrite).eOp == eOp {
                        break;
                    }
                    pWrite = (*pWrite).pNext
                }
                if pWrite.is_null() {
                    pWrite = idxMalloc(
                        &mut rc,
                        ::std::mem::size_of::<IdxWrite>() as libc::c_ulong as libc::c_int,
                    ) as *mut IdxWrite;
                    if rc == 0 as libc::c_int {
                        (*pWrite).pTab = pTab;
                        (*pWrite).eOp = eOp;
                        (*pWrite).pNext = (*p).pWrite;
                        (*p).pWrite = pWrite
                    }
                }
            }
        }
    }
    return rc;
}
unsafe extern "C" fn idxProcessOneTrigger(
    mut p: *mut sqlite3expert,
    mut pWrite: *mut IdxWrite,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut zInt: *const libc::c_char =
        b"t592690916721053953805701627921227776\x00" as *const u8 as *const libc::c_char;
    static mut zDrop: *const libc::c_char =
        b"DROP TABLE t592690916721053953805701627921227776\x00" as *const u8 as *const libc::c_char;
    let mut pTab: *mut IdxTable = (*pWrite).pTab;
    let mut zTab: *const libc::c_char = (*pTab).zName;
    let mut zSql: *const libc::c_char =
        b"SELECT \'CREATE TEMP\' || substr(sql, 7) FROM sqlite_schema WHERE tbl_name = %Q AND type IN (\'table\', \'trigger\') ORDER BY type;\x00"
            as *const u8 as *const libc::c_char;
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zWrite: *mut libc::c_char = 0 as *mut libc::c_char;
    /* Create the table and its triggers in the temp schema */
    rc = idxPrintfPrepareStmt(
        (*p).db,
        &mut pSelect as *mut *mut sqlite3_stmt,
        pzErr,
        zSql,
        zTab,
        zTab,
    );
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSelect) {
        let mut zCreate: *const libc::c_char =
            sqlite3_column_text(pSelect, 0 as libc::c_int) as *const libc::c_char;
        rc = sqlite3_exec((*p).dbv, zCreate, None, 0 as *mut libc::c_void, pzErr)
    }
    idxFinalize(&mut rc, pSelect);
    /* Rename the table in the temp schema to zInt */
    if rc == 0 as libc::c_int {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b"ALTER TABLE temp.%Q RENAME TO %Q\x00" as *const u8 as *const libc::c_char,
            zTab,
            zInt,
        );
        if z.is_null() {
            rc = 7 as libc::c_int
        } else {
            rc = sqlite3_exec((*p).dbv, z, None, 0 as *mut libc::c_void, pzErr);
            sqlite3_free(z as *mut libc::c_void);
        }
    }
    match (*pWrite).eOp {
        18 => {
            let mut i: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"INSERT INTO %Q VALUES(\x00" as *const u8 as *const libc::c_char,
                zInt,
            );
            i = 0 as libc::c_int;
            while i < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s?\x00" as *const u8 as *const libc::c_char,
                    if i == 0 as libc::c_int {
                        b"\x00" as *const u8 as *const libc::c_char
                    } else {
                        b", \x00" as *const u8 as *const libc::c_char
                    },
                );
                i += 1
            }
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b")\x00" as *const u8 as *const libc::c_char,
            )
        }
        23 => {
            let mut i_0: libc::c_int = 0;
            zWrite = idxAppendText(
                &mut rc as *mut libc::c_int,
                zWrite,
                b"UPDATE %Q SET \x00" as *const u8 as *const libc::c_char,
                zInt,
            );
            i_0 = 0 as libc::c_int;
            while i_0 < (*pTab).nCol {
                zWrite = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zWrite,
                    b"%s%Q=?\x00" as *const u8 as *const libc::c_char,
                    if i_0 == 0 as libc::c_int {
                        b"\x00" as *const u8 as *const libc::c_char
                    } else {
                        b", \x00" as *const u8 as *const libc::c_char
                    },
                    (*(*pTab).aCol.offset(i_0 as isize)).zName,
                );
                i_0 += 1
            }
        }
        _ => {
            if rc == 0 as libc::c_int {
                zWrite = sqlite3_mprintf(
                    b"DELETE FROM %Q\x00" as *const u8 as *const libc::c_char,
                    zInt,
                );
                if zWrite.is_null() {
                    rc = 7 as libc::c_int
                }
            }
        }
    }
    if rc == 0 as libc::c_int {
        let mut pX: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_prepare_v2(
            (*p).dbv,
            zWrite,
            -(1 as libc::c_int),
            &mut pX,
            0 as *mut *const libc::c_char,
        );
        idxFinalize(&mut rc, pX);
        if rc != 0 as libc::c_int {
            idxDatabaseError((*p).dbv, pzErr);
        }
    }
    sqlite3_free(zWrite as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        rc = sqlite3_exec((*p).dbv, zDrop, None, 0 as *mut libc::c_void, pzErr)
    }
    return rc;
}
unsafe extern "C" fn idxProcessTriggers(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pEnd: *mut IdxWrite = 0 as *mut IdxWrite;
    let mut pFirst: *mut IdxWrite = (*p).pWrite;
    while rc == 0 as libc::c_int && pFirst != pEnd {
        let mut pIter: *mut IdxWrite = 0 as *mut IdxWrite;
        pIter = pFirst;
        while rc == 0 as libc::c_int && pIter != pEnd {
            rc = idxProcessOneTrigger(p, pIter, pzErr);
            pIter = (*pIter).pNext
        }
        pEnd = pFirst;
        pFirst = (*p).pWrite
    }
    return rc;
}
unsafe extern "C" fn idxCreateVtabSchema(
    mut p: *mut sqlite3expert,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = idxRegisterVtab(p);
    let mut pSchema: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    /* For each table in the main db schema:
     **
     **   1) Add an entry to the p->pTable list, and
     **   2) Create the equivalent virtual table in dbv.
     */
    rc =
        idxPrepareStmt((*p).db, &mut pSchema, pzErrmsg,
                       b"SELECT type, name, sql, 1 FROM sqlite_schema WHERE type IN (\'table\',\'view\') AND name NOT LIKE \'sqlite_%%\'  UNION ALL SELECT type, name, sql, 2 FROM sqlite_schema WHERE type = \'trigger\'  AND tbl_name IN(SELECT name FROM sqlite_schema WHERE type = \'view\') ORDER BY 4, 1\x00"
                           as *const u8 as *const libc::c_char);
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSchema) {
        let mut zType: *const libc::c_char =
            sqlite3_column_text(pSchema, 0 as libc::c_int) as *const libc::c_char;
        let mut zName: *const libc::c_char =
            sqlite3_column_text(pSchema, 1 as libc::c_int) as *const libc::c_char;
        let mut zSql: *const libc::c_char =
            sqlite3_column_text(pSchema, 2 as libc::c_int) as *const libc::c_char;
        if *zType.offset(0 as libc::c_int as isize) as libc::c_int == 'v' as i32
            || *zType.offset(1 as libc::c_int as isize) as libc::c_int == 'r' as i32
        {
            rc = sqlite3_exec((*p).dbv, zSql, None, 0 as *mut libc::c_void, pzErrmsg)
        } else {
            let mut pTab: *mut IdxTable = 0 as *mut IdxTable;
            rc = idxGetTableInfo((*p).db, zName, &mut pTab, pzErrmsg);
            if !(rc == 0 as libc::c_int) {
                continue;
            }
            let mut i: libc::c_int = 0;
            let mut zInner: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zOuter: *mut libc::c_char = 0 as *mut libc::c_char;
            (*pTab).pNext = (*p).pTable;
            (*p).pTable = pTab;
            /* The statement the vtab will pass to sqlite3_declare_vtab() */
            zInner = idxAppendText(
                &mut rc as *mut libc::c_int,
                0 as *mut libc::c_char,
                b"CREATE TABLE x(\x00" as *const u8 as *const libc::c_char,
            );
            i = 0 as libc::c_int;
            while i < (*pTab).nCol {
                zInner = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zInner,
                    b"%s%Q COLLATE %s\x00" as *const u8 as *const libc::c_char,
                    if i == 0 as libc::c_int {
                        b"\x00" as *const u8 as *const libc::c_char
                    } else {
                        b", \x00" as *const u8 as *const libc::c_char
                    },
                    (*(*pTab).aCol.offset(i as isize)).zName,
                    (*(*pTab).aCol.offset(i as isize)).zColl,
                );
                i += 1
            }
            zInner = idxAppendText(
                &mut rc as *mut libc::c_int,
                zInner,
                b")\x00" as *const u8 as *const libc::c_char,
            );
            /* The CVT statement to create the vtab */
            zOuter = idxAppendText(
                &mut rc as *mut libc::c_int,
                0 as *mut libc::c_char,
                b"CREATE VIRTUAL TABLE %Q USING expert(%Q)\x00" as *const u8 as *const libc::c_char,
                zName,
                zInner,
            );
            if rc == 0 as libc::c_int {
                rc = sqlite3_exec((*p).dbv, zOuter, None, 0 as *mut libc::c_void, pzErrmsg)
            }
            sqlite3_free(zInner as *mut libc::c_void);
            sqlite3_free(zOuter as *mut libc::c_void);
        }
    }
    idxFinalize(&mut rc, pSchema);
    return rc;
}
/* Number of rows returned */
unsafe extern "C" fn idxSampleFunc(
    mut pCtx: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut _argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxSampleCtx = sqlite3_user_data(pCtx) as *mut IdxSampleCtx;
    let mut bRet: libc::c_int = 0;
    if (*p).nRow == 0.0f64 {
        bRet = 1 as libc::c_int
    } else {
        bRet = ((*p).nRet / (*p).nRow <= (*p).target) as libc::c_int;
        if bRet == 0 as libc::c_int {
            let mut rnd: libc::c_ushort = 0;
            sqlite3_randomness(
                2 as libc::c_int,
                &mut rnd as *mut libc::c_ushort as *mut libc::c_void,
            );
            bRet = (rnd as libc::c_int % 100 as libc::c_int <= (*p).iTarget) as libc::c_int
        }
    }
    sqlite3_result_int(pCtx, bRet);
    (*p).nRow += 1.0f64;
    (*p).nRet += bRet as libc::c_double;
}
/*
** Implementation of scalar function rem().
*/
unsafe extern "C" fn idxRemFunc(
    mut pCtx: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut p: *mut IdxRemCtx = sqlite3_user_data(pCtx) as *mut IdxRemCtx;
    let mut pSlot: *mut IdxRemSlot = 0 as *mut IdxRemSlot;
    let mut iSlot: libc::c_int = 0;
    iSlot = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    pSlot = &mut *(*p).aSlot.as_mut_ptr().offset(iSlot as isize) as *mut IdxRemSlot;
    match (*pSlot).eType {
        1 => {
            sqlite3_result_int64(pCtx, (*pSlot).iVal);
        }
        2 => {
            sqlite3_result_double(pCtx, (*pSlot).rVal);
        }
        4 => {
            sqlite3_result_blob(
                pCtx,
                (*pSlot).z as *const libc::c_void,
                (*pSlot).n,
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        3 => {
            sqlite3_result_text(
                pCtx,
                (*pSlot).z,
                (*pSlot).n,
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        5 | _ => {}
    }
    /* no-op */
    (*pSlot).eType = sqlite3_value_type(*argv.offset(1 as libc::c_int as isize));
    match (*pSlot).eType {
        1 => (*pSlot).iVal = sqlite3_value_int64(*argv.offset(1 as libc::c_int as isize)),
        2 => (*pSlot).rVal = sqlite3_value_double(*argv.offset(1 as libc::c_int as isize)),
        4 | 3 => {
            let mut nByte: libc::c_int =
                sqlite3_value_bytes(*argv.offset(1 as libc::c_int as isize));
            if nByte > (*pSlot).nByte {
                let mut zNew: *mut libc::c_char =
                    sqlite3_realloc((*pSlot).z as *mut libc::c_void, nByte * 2 as libc::c_int)
                        as *mut libc::c_char;
                if zNew.is_null() {
                    sqlite3_result_error_nomem(pCtx);
                    return;
                } else {
                    (*pSlot).nByte = nByte * 2 as libc::c_int;
                    (*pSlot).z = zNew
                }
            }
            (*pSlot).n = nByte;
            if (*pSlot).eType == 4 as libc::c_int {
                memcpy(
                    (*pSlot).z as *mut libc::c_void,
                    sqlite3_value_blob(*argv.offset(1 as libc::c_int as isize)),
                    nByte as libc::c_ulong,
                );
            } else {
                memcpy(
                    (*pSlot).z as *mut libc::c_void,
                    sqlite3_value_text(*argv.offset(1 as libc::c_int as isize))
                        as *const libc::c_void,
                    nByte as libc::c_ulong,
                );
            }
        }
        5 | _ => {}
    };
}
unsafe extern "C" fn idxLargestIndex(
    mut db: *mut sqlite3,
    mut pnMax: *mut libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zMax: *const libc::c_char =
        b"SELECT max(i.seqno) FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l,   pragma_index_info(l.name) AS i WHERE s.type = \'table\'\x00"
            as *const u8 as *const libc::c_char;
    let mut pMax: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    *pnMax = 0 as libc::c_int;
    rc = idxPrepareStmt(db, &mut pMax, pzErr, zMax);
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pMax) {
        *pnMax = sqlite3_column_int(pMax, 0 as libc::c_int) + 1 as libc::c_int
    }
    idxFinalize(&mut rc, pMax);
    return rc;
}
unsafe extern "C" fn idxPopulateOneStat1(
    mut p: *mut sqlite3expert,
    mut pIndexXInfo: *mut sqlite3_stmt,
    mut pWriteStat: *mut sqlite3_stmt,
    mut zTab: *const libc::c_char,
    mut zIdx: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut zCols: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zOrder: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut i: libc::c_int = 0;
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aStat: *mut libc::c_int = 0 as *mut libc::c_int;
    let mut rc: libc::c_int = 0 as libc::c_int;
    /* Formulate the query text */
    sqlite3_bind_text(
        pIndexXInfo,
        1 as libc::c_int,
        zIdx,
        -(1 as libc::c_int),
        None,
    );
    while 0 as libc::c_int == rc && 100 as libc::c_int == sqlite3_step(pIndexXInfo) {
        let mut zComma: *const libc::c_char = if zCols.is_null() {
            b"\x00" as *const u8 as *const libc::c_char
        } else {
            b", \x00" as *const u8 as *const libc::c_char
        };
        let mut zName: *const libc::c_char =
            sqlite3_column_text(pIndexXInfo, 0 as libc::c_int) as *const libc::c_char;
        let mut zColl: *const libc::c_char =
            sqlite3_column_text(pIndexXInfo, 1 as libc::c_int) as *const libc::c_char;
        zCols = idxAppendText(
            &mut rc as *mut libc::c_int,
            zCols,
            b"%sx.%Q IS rem(%d, x.%Q) COLLATE %s\x00" as *const u8 as *const libc::c_char,
            zComma,
            zName,
            nCol,
            zName,
            zColl,
        );
        nCol += 1;
        zOrder = idxAppendText(
            &mut rc as *mut libc::c_int,
            zOrder,
            b"%s%d\x00" as *const u8 as *const libc::c_char,
            zComma,
            nCol,
        )
    }
    sqlite3_reset(pIndexXInfo);
    if rc == 0 as libc::c_int {
        if (*p).iSample == 100 as libc::c_int {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM %Q x ORDER BY %s\x00" as *const u8 as *const libc::c_char,
                zCols,
                zTab,
                zOrder,
            )
        } else {
            zQuery = sqlite3_mprintf(
                b"SELECT %s FROM temp.t592690916721053953805701627921227776 x ORDER BY %s\x00"
                    as *const u8 as *const libc::c_char,
                zCols,
                zOrder,
            )
        }
    }
    sqlite3_free(zCols as *mut libc::c_void);
    sqlite3_free(zOrder as *mut libc::c_void);
    /* Formulate the query text */
    if rc == 0 as libc::c_int {
        let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
            (*p).db
        } else {
            (*p).dbv
        };
        rc = idxPrepareStmt(dbrem, &mut pQuery, pzErr, zQuery)
    }
    sqlite3_free(zQuery as *mut libc::c_void);
    if rc == 0 as libc::c_int {
        aStat = idxMalloc(
            &mut rc,
            (::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                .wrapping_mul((nCol + 1 as libc::c_int) as libc::c_ulong)
                as libc::c_int,
        ) as *mut libc::c_int
    }
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
        let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
        let mut zStat: *mut libc::c_char = 0 as *mut libc::c_char;
        i = 0 as libc::c_int;
        while i <= nCol {
            *aStat.offset(i as isize) = 1 as libc::c_int;
            i += 1
        }
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pQuery) {
            let ref mut fresh34 = *aStat.offset(0 as libc::c_int as isize);
            *fresh34 += 1;
            i = 0 as libc::c_int;
            while i < nCol {
                if sqlite3_column_int(pQuery, i) == 0 as libc::c_int {
                    break;
                }
                i += 1
            }
            while i < nCol {
                let ref mut fresh35 = *aStat.offset((i + 1 as libc::c_int) as isize);
                *fresh35 += 1;
                i += 1
            }
        }
        if rc == 0 as libc::c_int {
            let mut s0: libc::c_int = *aStat.offset(0 as libc::c_int as isize);
            zStat = sqlite3_mprintf(b"%d\x00" as *const u8 as *const libc::c_char, s0);
            if zStat.is_null() {
                rc = 7 as libc::c_int
            }
            i = 1 as libc::c_int;
            while rc == 0 as libc::c_int && i <= nCol {
                zStat = idxAppendText(
                    &mut rc as *mut libc::c_int,
                    zStat,
                    b" %d\x00" as *const u8 as *const libc::c_char,
                    (s0 + *aStat.offset(i as isize) / 2 as libc::c_int) / *aStat.offset(i as isize),
                );
                i += 1
            }
        }
        if rc == 0 as libc::c_int {
            sqlite3_bind_text(
                pWriteStat,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                2 as libc::c_int,
                zIdx,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_bind_text(
                pWriteStat,
                3 as libc::c_int,
                zStat,
                -(1 as libc::c_int),
                None,
            );
            sqlite3_step(pWriteStat);
            rc = sqlite3_reset(pWriteStat)
        }
        pEntry = idxHashFind(&mut (*p).hIdx, zIdx, strlen(zIdx) as libc::c_int);
        if !pEntry.is_null() {
            (*pEntry).zVal2 = zStat
        } else {
            sqlite3_free(zStat as *mut libc::c_void);
        }
    }
    sqlite3_free(aStat as *mut libc::c_void);
    idxFinalize(&mut rc, pQuery);
    return rc;
}
unsafe extern "C" fn idxBuildSampleTable(
    mut p: *mut sqlite3expert,
    mut zTab: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).dbv,
        b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00" as *const u8
            as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    if rc != 0 as libc::c_int {
        return rc;
    } else {
        zSql = sqlite3_mprintf(
            b"CREATE TABLE temp.t592690916721053953805701627921227776 AS SELECT * FROM %Q\x00"
                as *const u8 as *const libc::c_char,
            zTab,
        );
        if zSql.is_null() {
            return 7 as libc::c_int;
        } else {
            rc = sqlite3_exec(
                (*p).dbv,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_free(zSql as *mut libc::c_void);
            return rc;
        }
    };
}
/*
** This function is called as part of sqlite3_expert_analyze(). Candidate
** indexes have already been created in database sqlite3expert.dbm, this
** function populates sqlite_stat1 table in the same database.
**
** The stat1 data is generated by querying the
*/
unsafe extern "C" fn idxPopulateStat1(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut nMax: libc::c_int = 0 as libc::c_int;
    let mut pCtx: *mut IdxRemCtx = 0 as *mut IdxRemCtx;
    let mut samplectx: IdxSampleCtx = IdxSampleCtx {
        iTarget: 0,
        target: 0.,
        nRow: 0.,
        nRet: 0.,
    };
    let mut i: libc::c_int = 0;
    let mut iPrev: i64_0 = -(100000 as libc::c_int) as i64_0;
    let mut pAllIndex: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pIndexXInfo: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pWrite: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zAllIndex: *const libc::c_char =
        b"SELECT s.rowid, s.name, l.name FROM   sqlite_schema AS s,   pragma_index_list(s.name) AS l WHERE s.type = \'table\'\x00"
            as *const u8 as *const libc::c_char;
    let mut zIndexXInfo: *const libc::c_char =
        b"SELECT name, coll FROM pragma_index_xinfo(?) WHERE key\x00" as *const u8
            as *const libc::c_char;
    let mut zWrite: *const libc::c_char =
        b"INSERT INTO sqlite_stat1 VALUES(?, ?, ?)\x00" as *const u8 as *const libc::c_char;
    /* If iSample==0, no sqlite_stat1 data is required. */
    if (*p).iSample == 0 as libc::c_int {
        return 0 as libc::c_int;
    } else {
        rc = idxLargestIndex((*p).dbm, &mut nMax, pzErr);
        if nMax <= 0 as libc::c_int || rc != 0 as libc::c_int {
            return rc;
        } else {
            rc = sqlite3_exec(
                (*p).dbm,
                b"ANALYZE; PRAGMA writable_schema=1\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 0 as libc::c_int {
                let mut nByte: libc::c_int = (::std::mem::size_of::<IdxRemCtx>() as libc::c_ulong)
                    .wrapping_add(
                        (::std::mem::size_of::<IdxRemSlot>() as libc::c_ulong)
                            .wrapping_mul(nMax as libc::c_ulong),
                    ) as libc::c_int;
                pCtx = idxMalloc(&mut rc, nByte) as *mut IdxRemCtx
            }
            if rc == 0 as libc::c_int {
                let mut dbrem: *mut sqlite3 = if (*p).iSample == 100 as libc::c_int {
                    (*p).db
                } else {
                    (*p).dbv
                };
                rc = sqlite3_create_function(
                    dbrem,
                    b"rem\x00" as *const u8 as *const libc::c_char,
                    2 as libc::c_int,
                    1 as libc::c_int,
                    pCtx as *mut libc::c_void,
                    Some(
                        idxRemFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                    None,
                    None,
                )
            }
            if rc == 0 as libc::c_int {
                rc = sqlite3_create_function(
                    (*p).db,
                    b"sample\x00" as *const u8 as *const libc::c_char,
                    0 as libc::c_int,
                    1 as libc::c_int,
                    &mut samplectx as *mut IdxSampleCtx as *mut libc::c_void,
                    Some(
                        idxSampleFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                    None,
                    None,
                )
            }
            if rc == 0 as libc::c_int {
                (*pCtx).nSlot = nMax + 1 as libc::c_int;
                rc = idxPrepareStmt((*p).dbm, &mut pAllIndex, pzErr, zAllIndex)
            }
            if rc == 0 as libc::c_int {
                rc = idxPrepareStmt((*p).dbm, &mut pIndexXInfo, pzErr, zIndexXInfo)
            }
            if rc == 0 as libc::c_int {
                rc = idxPrepareStmt((*p).dbm, &mut pWrite, pzErr, zWrite)
            }
            while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pAllIndex) {
                let mut iRowid: i64_0 = sqlite3_column_int64(pAllIndex, 0 as libc::c_int);
                let mut zTab: *const libc::c_char =
                    sqlite3_column_text(pAllIndex, 1 as libc::c_int) as *const libc::c_char;
                let mut zIdx: *const libc::c_char =
                    sqlite3_column_text(pAllIndex, 2 as libc::c_int) as *const libc::c_char;
                if (*p).iSample < 100 as libc::c_int && iPrev != iRowid {
                    samplectx.target = (*p).iSample as libc::c_double / 100.0f64;
                    samplectx.iTarget = (*p).iSample;
                    samplectx.nRow = 0.0f64;
                    samplectx.nRet = 0.0f64;
                    rc = idxBuildSampleTable(p, zTab);
                    if rc != 0 as libc::c_int {
                        break;
                    }
                }
                rc = idxPopulateOneStat1(p, pIndexXInfo, pWrite, zTab, zIdx, pzErr);
                iPrev = iRowid
            }
            if rc == 0 as libc::c_int && (*p).iSample < 100 as libc::c_int {
                rc = sqlite3_exec(
                    (*p).dbv,
                    b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00"
                        as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                )
            }
            idxFinalize(&mut rc, pAllIndex);
            idxFinalize(&mut rc, pIndexXInfo);
            idxFinalize(&mut rc, pWrite);
            if !pCtx.is_null() {
                i = 0 as libc::c_int;
                while i < (*pCtx).nSlot {
                    sqlite3_free(
                        (*(*pCtx).aSlot.as_mut_ptr().offset(i as isize)).z as *mut libc::c_void,
                    );
                    i += 1
                }
                sqlite3_free(pCtx as *mut libc::c_void);
            }
            if rc == 0 as libc::c_int {
                rc = sqlite3_exec(
                    (*p).dbm,
                    b"ANALYZE sqlite_schema\x00" as *const u8 as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                )
            }
            sqlite3_exec(
                (*p).db,
                b"DROP TABLE IF EXISTS temp.t592690916721053953805701627921227776\x00" as *const u8
                    as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            return rc;
        }
    };
}
/*
** Create a new sqlite3expert object.
**
** If successful, a pointer to the new object is returned and (*pzErr) set
** to NULL. Or, if an error occurs, NULL is returned and (*pzErr) set to
** an English-language error message. In this case it is the responsibility
** of the caller to eventually free the error message buffer using
** sqlite3_free().
*/
/*
** Allocate a new sqlite3expert object.
*/
pub unsafe extern "C" fn sqlite3_expert_new(
    mut db: *mut sqlite3,
    mut pzErrmsg: *mut *mut libc::c_char,
) -> *mut sqlite3expert {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pNew: *mut sqlite3expert = 0 as *mut sqlite3expert;
    pNew = idxMalloc(
        &mut rc,
        ::std::mem::size_of::<sqlite3expert>() as libc::c_ulong as libc::c_int,
    ) as *mut sqlite3expert;
    /* Open two in-memory databases to work with. The "vtab database" (dbv)
     ** will contain a virtual table corresponding to each real table in
     ** the user database schema, and a copy of each view. It is used to
     ** collect information regarding the WHERE, ORDER BY and other clauses
     ** of the user's query.
     */
    if rc == 0 as libc::c_int {
        (*pNew).db = db;
        (*pNew).iSample = 100 as libc::c_int;
        rc = sqlite3_open(
            b":memory:\x00" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbv,
        )
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_open(
            b":memory:\x00" as *const u8 as *const libc::c_char,
            &mut (*pNew).dbm,
        );
        if rc == 0 as libc::c_int {
            sqlite3_db_config(
                (*pNew).dbm,
                1008 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_int,
            );
        }
    }
    /* Copy the entire schema of database [db] into [dbm]. */
    if rc == 0 as libc::c_int {
        let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc =
            idxPrintfPrepareStmt((*pNew).db,
                                 &mut pSql as *mut *mut sqlite3_stmt,
                                 pzErrmsg,
                                 b"SELECT sql FROM sqlite_schema WHERE name NOT LIKE \'sqlite_%%\' AND sql NOT LIKE \'CREATE VIRTUAL %%\'\x00"
                                     as *const u8 as *const libc::c_char);
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            let mut zSql: *const libc::c_char =
                sqlite3_column_text(pSql, 0 as libc::c_int) as *const libc::c_char;
            rc = sqlite3_exec((*pNew).dbm, zSql, None, 0 as *mut libc::c_void, pzErrmsg)
        }
        idxFinalize(&mut rc, pSql);
    }
    /* Create the vtab schema */
    if rc == 0 as libc::c_int {
        rc = idxCreateVtabSchema(pNew, pzErrmsg)
    }
    /* Register the auth callback with dbv */
    if rc == 0 as libc::c_int {
        sqlite3_set_authorizer(
            (*pNew).dbv,
            Some(
                idxAuthCallback
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
            ),
            pNew as *mut libc::c_void,
        );
    }
    /* If an error has occurred, free the new object and reutrn NULL. Otherwise,
     ** return the new sqlite3expert handle.  */
    if rc != 0 as libc::c_int {
        sqlite3_expert_destroy(pNew);
        pNew = 0 as *mut sqlite3expert
    }
    return pNew;
}
/*
** Configure an sqlite3expert object.
**
** EXPERT_CONFIG_SAMPLE:
**   By default, sqlite3_expert_analyze() generates sqlite_stat1 data for
**   each candidate index. This involves scanning and sorting the entire
**   contents of each user database table once for each candidate index
**   associated with the table. For large databases, this can be
**   prohibitively slow. This option allows the sqlite3expert object to
**   be configured so that sqlite_stat1 data is instead generated based on a
**   subset of each table, or so that no sqlite_stat1 data is used at all.
**
**   A single integer argument is passed to this option. If the value is less
**   than or equal to zero, then no sqlite_stat1 data is generated or used by
**   the analysis - indexes are recommended based on the database schema only.
**   Or, if the value is 100 or greater, complete sqlite_stat1 data is
**   generated for each candidate index (this is the default). Finally, if the
**   value falls between 0 and 100, then it represents the percentage of user
**   table rows that should be considered when generating sqlite_stat1 data.
**
**   Examples:
**
**     // Do not generate any sqlite_stat1 data
**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 0);
**
**     // Generate sqlite_stat1 data based on 10% of the rows in each table.
**     sqlite3_expert_config(pExpert, EXPERT_CONFIG_SAMPLE, 10);
*/
/*
** Configure an sqlite3expert object.
*/
pub unsafe extern "C" fn sqlite3_expert_config(
    mut p: *mut sqlite3expert,
    mut op: libc::c_int,
    mut args: ...
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut ap: ::std::ffi::VaListImpl;
    ap = args.clone();
    match op {
        1 => {
            let mut iVal: libc::c_int = ap.arg::<libc::c_int>();
            if iVal < 0 as libc::c_int {
                iVal = 0 as libc::c_int
            }
            if iVal > 100 as libc::c_int {
                iVal = 100 as libc::c_int
            }
            (*p).iSample = iVal
        }
        _ => rc = 12 as libc::c_int,
    }
    return rc;
}
/* int */
/*
** Specify zero or more SQL statements to be included in the analysis.
**
** Buffer zSql must contain zero or more complete SQL statements. This
** function parses all statements contained in the buffer and adds them
** to the internal list of statements to analyze. If successful, SQLITE_OK
** is returned and (*pzErr) set to NULL. Or, if an error occurs - for example
** due to a error in the SQL - an SQLite error code is returned and (*pzErr)
** may be set to point to an English language error message. In this case
** the caller is responsible for eventually freeing the error message buffer
** using sqlite3_free().
**
** If an error does occur while processing one of the statements in the
** buffer passed as the second argument, none of the statements in the
** buffer are added to the analysis.
**
** This function must be called before sqlite3_expert_analyze(). If a call
** to this function is made on an sqlite3expert object that has already
** been passed to sqlite3_expert_analyze() SQLITE_MISUSE is returned
** immediately and no statements are added to the analysis.
*/
/*
** Add an SQL statement to the analysis.
*/
pub unsafe extern "C" fn sqlite3_expert_sql(
    mut p: *mut sqlite3expert,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int
/* OUT: Error message (if any) */ {
    let mut pScanOrig: *mut IdxScan = (*p).pScan;
    let mut pStmtOrig: *mut IdxStatement = (*p).pStatement;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zStmt: *const libc::c_char = zSql;
    if (*p).bRun != 0 {
        return 21 as libc::c_int;
    } else {
        while rc == 0 as libc::c_int
            && !zStmt.is_null()
            && *zStmt.offset(0 as libc::c_int as isize) as libc::c_int != 0
        {
            let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            rc = sqlite3_prepare_v2((*p).dbv, zStmt, -(1 as libc::c_int), &mut pStmt, &mut zStmt);
            if rc == 0 as libc::c_int {
                if pStmt.is_null() {
                    continue;
                }
                let mut pNew: *mut IdxStatement = 0 as *mut IdxStatement;
                let mut z: *const libc::c_char = sqlite3_sql(pStmt);
                let mut n: libc::c_int = strlen(z) as libc::c_int;
                pNew = idxMalloc(
                    &mut rc,
                    (::std::mem::size_of::<IdxStatement>() as libc::c_ulong)
                        .wrapping_add(n as libc::c_ulong)
                        .wrapping_add(1 as libc::c_int as libc::c_ulong)
                        as libc::c_int,
                ) as *mut IdxStatement;
                if rc == 0 as libc::c_int {
                    (*pNew).zSql = &mut *pNew.offset(1 as libc::c_int as isize) as *mut IdxStatement
                        as *mut libc::c_char;
                    memcpy(
                        (*pNew).zSql as *mut libc::c_void,
                        z as *const libc::c_void,
                        (n + 1 as libc::c_int) as libc::c_ulong,
                    );
                    (*pNew).pNext = (*p).pStatement;
                    if !(*p).pStatement.is_null() {
                        (*pNew).iId = (*(*p).pStatement).iId + 1 as libc::c_int
                    }
                    (*p).pStatement = pNew
                }
                sqlite3_finalize(pStmt);
            } else {
                idxDatabaseError((*p).dbv, pzErr);
            }
        }
        if rc != 0 as libc::c_int {
            idxScanFree((*p).pScan, pScanOrig);
            idxStatementFree((*p).pStatement, pStmtOrig);
            (*p).pScan = pScanOrig;
            (*p).pStatement = pStmtOrig
        }
        return rc;
    };
}
/*
** This function is called after the sqlite3expert object has been configured
** with all SQL statements using sqlite3_expert_sql() to actually perform
** the analysis. Once this function has been called, it is not possible to
** add further SQL statements to the analysis.
**
** If successful, SQLITE_OK is returned and (*pzErr) is set to NULL. Or, if
** an error occurs, an SQLite error code is returned and (*pzErr) set to
** point to a buffer containing an English language error message. In this
** case it is the responsibility of the caller to eventually free the buffer
** using sqlite3_free().
**
** If an error does occur within this function, the sqlite3expert object
** is no longer useful for any purpose. At that point it is no longer
** possible to add further SQL statements to the object or to re-attempt
** the analysis. The sqlite3expert object must still be freed using a call
** sqlite3_expert_destroy().
*/
pub unsafe extern "C" fn sqlite3_expert_analyze(
    mut p: *mut sqlite3expert,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut pEntry: *mut IdxHashEntry = 0 as *mut IdxHashEntry;
    /* Do trigger processing to collect any extra IdxScan structures */
    rc = idxProcessTriggers(p, pzErr);
    /* Create candidate indexes within the in-memory database file */
    if rc == 0 as libc::c_int {
        rc = idxCreateCandidates(p)
    } else if rc == 5 as libc::c_int | (3 as libc::c_int) << 8 as libc::c_int {
        if !pzErr.is_null() {
            *pzErr = sqlite3_mprintf(
                b"Cannot find a unique index name to propose.\x00" as *const u8
                    as *const libc::c_char,
            )
        }
        return rc;
    }
    /* Generate the stat1 data */
    if rc == 0 as libc::c_int {
        rc = idxPopulateStat1(p, pzErr)
    }
    /* Formulate the EXPERT_REPORT_CANDIDATES text */
    pEntry = (*p).hIdx.pFirst;
    while !pEntry.is_null() {
        (*p).zCandidates = idxAppendText(
            &mut rc as *mut libc::c_int,
            (*p).zCandidates,
            b"%s;%s%s\n\x00" as *const u8 as *const libc::c_char,
            (*pEntry).zVal,
            if !(*pEntry).zVal2.is_null() {
                b" -- stat1: \x00" as *const u8 as *const libc::c_char
            } else {
                b"\x00" as *const u8 as *const libc::c_char
            },
            (*pEntry).zVal2,
        );
        pEntry = (*pEntry).pNext
    }
    /* Figure out which of the candidate indexes are preferred by the query
     ** planner and report the results to the user.  */
    if rc == 0 as libc::c_int {
        rc = idxFindIndexes(p, pzErr)
    }
    if rc == 0 as libc::c_int {
        (*p).bRun = 1 as libc::c_int
    }
    return rc;
}
/*
** Return the total number of statements loaded using sqlite3_expert_sql().
** The total number of SQL statements may be different from the total number
** to calls to sqlite3_expert_sql().
*/
/*
** Return the total number of statements that have been added to this
** sqlite3expert using sqlite3_expert_sql().
*/
pub unsafe extern "C" fn sqlite3_expert_count(mut p: *mut sqlite3expert) -> libc::c_int {
    let mut nRet: libc::c_int = 0 as libc::c_int;
    if !(*p).pStatement.is_null() {
        nRet = (*(*p).pStatement).iId + 1 as libc::c_int
    }
    return nRet;
}
/*
** Return a component of the report.
**
** This function is called after sqlite3_expert_analyze() to extract the
** results of the analysis. Each call to this function returns either a
** NULL pointer or a pointer to a buffer containing a nul-terminated string.
** The value passed as the third argument must be one of the EXPERT_REPORT_*
** #define constants defined below.
**
** For some EXPERT_REPORT_* parameters, the buffer returned contains
** information relating to a specific SQL statement. In these cases that
** SQL statement is identified by the value passed as the second argument.
** SQL statements are numbered from 0 in the order in which they are parsed.
** If an out-of-range value (less than zero or equal to or greater than the
** value returned by sqlite3_expert_count()) is passed as the second argument
** along with such an EXPERT_REPORT_* parameter, NULL is always returned.
**
** EXPERT_REPORT_SQL:
**   Return the text of SQL statement iStmt.
**
** EXPERT_REPORT_INDEXES:
**   Return a buffer containing the CREATE INDEX statements for all recommended
**   indexes for statement iStmt. If there are no new recommeded indexes, NULL
**   is returned.
**
** EXPERT_REPORT_PLAN:
**   Return a buffer containing the EXPLAIN QUERY PLAN output for SQL query
**   iStmt after the proposed indexes have been added to the database schema.
**
** EXPERT_REPORT_CANDIDATES:
**   Return a pointer to a buffer containing the CREATE INDEX statements
**   for all indexes that were tested (for all SQL statements). The iStmt
**   parameter is ignored for EXPERT_REPORT_CANDIDATES calls.
*/
/*
** Return a component of the report.
*/
pub unsafe extern "C" fn sqlite3_expert_report(
    mut p: *mut sqlite3expert,
    mut iStmt: libc::c_int,
    mut eReport: libc::c_int,
) -> *const libc::c_char {
    let mut zRet: *const libc::c_char = 0 as *const libc::c_char;
    let mut pStmt: *mut IdxStatement = 0 as *mut IdxStatement;
    if (*p).bRun == 0 as libc::c_int {
        return 0 as *const libc::c_char;
    } else {
        pStmt = (*p).pStatement;
        while !pStmt.is_null() && (*pStmt).iId != iStmt {
            pStmt = (*pStmt).pNext
        }
        match eReport {
            1 => {
                if !pStmt.is_null() {
                    zRet = (*pStmt).zSql
                }
            }
            2 => {
                if !pStmt.is_null() {
                    zRet = (*pStmt).zIdx
                }
            }
            3 => {
                if !pStmt.is_null() {
                    zRet = (*pStmt).zEQP
                }
            }
            4 => zRet = (*p).zCandidates,
            _ => {}
        }
        return zRet;
    };
}
/*
** Free an (sqlite3expert*) handle and all associated resources. There
** should be one call to this function for each successful call to
** sqlite3-expert_new().
*/
/*
** Free an sqlite3expert object.
*/
pub unsafe extern "C" fn sqlite3_expert_destroy(mut p: *mut sqlite3expert) {
    if !p.is_null() {
        sqlite3_close((*p).dbm);
        sqlite3_close((*p).dbv);
        idxScanFree((*p).pScan, 0 as *mut IdxScan);
        idxStatementFree((*p).pStatement, 0 as *mut IdxStatement);
        idxTableFree((*p).pTable);
        idxWriteFree((*p).pWrite);
        idxHashClear(&mut (*p).hIdx);
        sqlite3_free((*p).zCandidates as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
    };
}
/*
** Connect to an sqlite_dbdata (pAux==0) or sqlite_dbptr (pAux!=0) virtual
** table.
*/
unsafe extern "C" fn dbdataConnect(
    mut db: *mut sqlite3,
    mut pAux: *mut libc::c_void,
    mut _argc: libc::c_int,
    mut _argv: *const *const libc::c_char,
    mut ppVtab: *mut *mut sqlite3_vtab,
    mut _pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = 0 as *mut DbdataTable;
    let mut rc: libc::c_int = sqlite3_declare_vtab(
        db,
        if !pAux.is_null() {
            b"CREATE TABLE x(  pgno INTEGER,  child INTEGER,  schema TEXT HIDDEN)\x00" as *const u8
                as *const libc::c_char
        } else {
            b"CREATE TABLE x(  pgno INTEGER,  cell INTEGER,  field INTEGER,  value ANY,  schema TEXT HIDDEN)\x00"
                                     as *const u8 as *const libc::c_char
        },
    );
    if rc == 0 as libc::c_int {
        pTab = sqlite3_malloc64(
            ::std::mem::size_of::<DbdataTable>() as libc::c_ulong as sqlite3_uint64
        ) as *mut DbdataTable;
        if pTab.is_null() {
            rc = 7 as libc::c_int
        } else {
            memset(
                pTab as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<DbdataTable>() as libc::c_ulong,
            );
            (*pTab).db = db;
            (*pTab).bPtr = (pAux != 0 as *mut libc::c_void) as libc::c_int
        }
    }
    *ppVtab = pTab as *mut sqlite3_vtab;
    return rc;
}
/*
** Disconnect from or destroy a sqlite_dbdata or sqlite_dbptr virtual table.
*/
unsafe extern "C" fn dbdataDisconnect(mut pVtab: *mut sqlite3_vtab) -> libc::c_int {
    let mut pTab: *mut DbdataTable = pVtab as *mut DbdataTable;
    if !pTab.is_null() {
        sqlite3_finalize((*pTab).pStmt);
        sqlite3_free(pVtab as *mut libc::c_void);
    }
    return 0 as libc::c_int;
}
/*
** This function interprets two types of constraints:
**
**       schema=?
**       pgno=?
**
** If neither are present, idxNum is set to 0. If schema=? is present,
** the 0x01 bit in idxNum is set. If pgno=? is present, the 0x02 bit
** in idxNum is set.
**
** If both parameters are present, schema is in position 0 and pgno in
** position 1.
*/
unsafe extern "C" fn dbdataBestIndex(
    mut tab: *mut sqlite3_vtab,
    mut pIdx: *mut sqlite3_index_info,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = tab as *mut DbdataTable;
    let mut i: libc::c_int = 0;
    let mut iSchema: libc::c_int = -(1 as libc::c_int);
    let mut iPgno: libc::c_int = -(1 as libc::c_int);
    let mut colSchema: libc::c_int = if (*pTab).bPtr != 0 {
        2 as libc::c_int
    } else {
        4 as libc::c_int
    };
    i = 0 as libc::c_int;
    while i < (*pIdx).nConstraint {
        let mut p: *mut sqlite3_index_constraint =
            &mut *(*pIdx).aConstraint.offset(i as isize) as *mut sqlite3_index_constraint;
        if (*p).op as libc::c_int == 2 as libc::c_int {
            if (*p).iColumn == colSchema {
                if (*p).usable as libc::c_int == 0 as libc::c_int {
                    return 19 as libc::c_int;
                } else {
                    iSchema = i
                }
            }
            if (*p).iColumn == 0 as libc::c_int && (*p).usable as libc::c_int != 0 {
                iPgno = i
            }
        }
        i += 1
    }
    if iSchema >= 0 as libc::c_int {
        (*(*pIdx).aConstraintUsage.offset(iSchema as isize)).argvIndex = 1 as libc::c_int;
        (*(*pIdx).aConstraintUsage.offset(iSchema as isize)).omit =
            1 as libc::c_int as libc::c_uchar
    }
    if iPgno >= 0 as libc::c_int {
        (*(*pIdx).aConstraintUsage.offset(iPgno as isize)).argvIndex =
            1 as libc::c_int + (iSchema >= 0 as libc::c_int) as libc::c_int;
        (*(*pIdx).aConstraintUsage.offset(iPgno as isize)).omit = 1 as libc::c_int as libc::c_uchar;
        (*pIdx).estimatedCost = 100 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 50 as libc::c_int as sqlite3_int64;
        if (*pTab).bPtr == 0 as libc::c_int
            && (*pIdx).nOrderBy != 0
            && (*(*pIdx).aOrderBy.offset(0 as libc::c_int as isize)).desc as libc::c_int
                == 0 as libc::c_int
        {
            let mut iCol: libc::c_int =
                (*(*pIdx).aOrderBy.offset(0 as libc::c_int as isize)).iColumn;
            if (*pIdx).nOrderBy == 1 as libc::c_int {
                (*pIdx).orderByConsumed =
                    (iCol == 0 as libc::c_int || iCol == 1 as libc::c_int) as libc::c_int
            } else if (*pIdx).nOrderBy == 2 as libc::c_int
                && (*(*pIdx).aOrderBy.offset(1 as libc::c_int as isize)).desc as libc::c_int
                    == 0 as libc::c_int
                && iCol == 0 as libc::c_int
            {
                (*pIdx).orderByConsumed = ((*(*pIdx).aOrderBy.offset(1 as libc::c_int as isize))
                    .iColumn
                    == 1 as libc::c_int) as libc::c_int
            }
        }
    } else {
        (*pIdx).estimatedCost = 100000000 as libc::c_int as libc::c_double;
        (*pIdx).estimatedRows = 1000000000 as libc::c_int as sqlite3_int64
    }
    (*pIdx).idxNum = (if iSchema >= 0 as libc::c_int {
        0x1 as libc::c_int
    } else {
        0 as libc::c_int
    }) | (if iPgno >= 0 as libc::c_int {
        0x2 as libc::c_int
    } else {
        0 as libc::c_int
    });
    return 0 as libc::c_int;
}
/*
** Open a new sqlite_dbdata or sqlite_dbptr cursor.
*/
unsafe extern "C" fn dbdataOpen(
    mut pVTab: *mut sqlite3_vtab,
    mut ppCursor: *mut *mut sqlite3_vtab_cursor,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = 0 as *mut DbdataCursor;
    pCsr = sqlite3_malloc64(::std::mem::size_of::<DbdataCursor>() as libc::c_ulong as sqlite3_uint64)
        as *mut DbdataCursor;
    if pCsr.is_null() {
        return 7 as libc::c_int;
    } else {
        memset(
            pCsr as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<DbdataCursor>() as libc::c_ulong,
        );
        (*pCsr).base.pVtab = pVTab;
        *ppCursor = pCsr as *mut sqlite3_vtab_cursor;
        return 0 as libc::c_int;
    };
}
/*
** Restore a cursor object to the state it was in when first allocated
** by dbdataOpen().
*/
unsafe extern "C" fn dbdataResetCursor(mut pCsr: *mut DbdataCursor) {
    let mut pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    if (*pTab).pStmt.is_null() {
        (*pTab).pStmt = (*pCsr).pStmt
    } else {
        sqlite3_finalize((*pCsr).pStmt);
    }
    (*pCsr).pStmt = 0 as *mut sqlite3_stmt;
    (*pCsr).iPgno = 1 as libc::c_int;
    (*pCsr).iCell = 0 as libc::c_int;
    (*pCsr).iField = 0 as libc::c_int;
    (*pCsr).bOnePage = 0 as libc::c_int;
    sqlite3_free((*pCsr).aPage as *mut libc::c_void);
    sqlite3_free((*pCsr).pRec as *mut libc::c_void);
    (*pCsr).pRec = 0 as *mut u8_0;
    (*pCsr).aPage = 0 as *mut u8_0;
}
/*
** Close an sqlite_dbdata or sqlite_dbptr cursor.
*/
unsafe extern "C" fn dbdataClose(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    dbdataResetCursor(pCsr);
    sqlite3_free(pCsr as *mut libc::c_void);
    return 0 as libc::c_int;
}
/*
** Utility methods to decode 16 and 32-bit big-endian unsigned integers.
*/
unsafe extern "C" fn get_uint16(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return ((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int
        | *a.offset(1 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn get_uint32(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return (*a.offset(0 as libc::c_int as isize) as libc::c_uint) << 24 as libc::c_int
        | (*a.offset(1 as libc::c_int as isize) as libc::c_uint) << 16 as libc::c_int
        | (*a.offset(2 as libc::c_int as isize) as libc::c_uint) << 8 as libc::c_int
        | *a.offset(3 as libc::c_int as isize) as libc::c_uint;
}
/*
** Load page pgno from the database via the sqlite_dbpage virtual table.
** If successful, set (*ppPage) to point to a buffer containing the page
** data, (*pnPage) to the size of that buffer in bytes and return
** SQLITE_OK. In this case it is the responsibility of the caller to
** eventually free the buffer using sqlite3_free().
**
** Or, if an error occurs, set both (*ppPage) and (*pnPage) to 0 and
** return an SQLite error code.
*/
unsafe extern "C" fn dbdataLoadPage(
    mut pCsr: *mut DbdataCursor,
    mut pgno: libc::c_uint,
    mut ppPage: *mut *mut u8_0,
    mut pnPage: *mut libc::c_int,
) -> libc::c_int
/* OUT: Size of (*ppPage) in bytes */ {
    let mut rc2: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut pStmt: *mut sqlite3_stmt = (*pCsr).pStmt;
    *ppPage = 0 as *mut u8_0;
    *pnPage = 0 as libc::c_int;
    sqlite3_bind_int64(pStmt, 2 as libc::c_int, pgno as sqlite3_int64);
    if 100 as libc::c_int == sqlite3_step(pStmt) {
        let mut nCopy: libc::c_int = sqlite3_column_bytes(pStmt, 0 as libc::c_int);
        if nCopy > 0 as libc::c_int {
            let mut pPage: *mut u8_0 = 0 as *mut u8_0;
            pPage = sqlite3_malloc64((nCopy + 100 as libc::c_int) as sqlite3_uint64) as *mut u8_0;
            if pPage.is_null() {
                rc = 7 as libc::c_int
            } else {
                let mut pCopy: *const u8_0 =
                    sqlite3_column_blob(pStmt, 0 as libc::c_int) as *const u8_0;
                memcpy(
                    pPage as *mut libc::c_void,
                    pCopy as *const libc::c_void,
                    nCopy as libc::c_ulong,
                );
                memset(
                    &mut *pPage.offset(nCopy as isize) as *mut u8_0 as *mut libc::c_void,
                    0 as libc::c_int,
                    100 as libc::c_int as libc::c_ulong,
                );
            }
            *ppPage = pPage;
            *pnPage = nCopy
        }
    }
    rc2 = sqlite3_reset(pStmt);
    if rc == 0 as libc::c_int {
        rc = rc2
    }
    return rc;
}
/*
** Read a varint.  Put the value in *pVal and return the number of bytes.
*/
unsafe extern "C" fn dbdataGetVarint(
    mut z: *const u8_0,
    mut pVal: *mut sqlite3_int64,
) -> libc::c_int {
    let mut v: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while i < 8 as libc::c_int {
        v = (v << 7 as libc::c_int)
            + (*z.offset(i as isize) as libc::c_int & 0x7f as libc::c_int) as libc::c_longlong;
        if *z.offset(i as isize) as libc::c_int & 0x80 as libc::c_int == 0 as libc::c_int {
            *pVal = v;
            return i + 1 as libc::c_int;
        } else {
            i += 1
        }
    }
    v = (v << 8 as libc::c_int)
        + (*z.offset(i as isize) as libc::c_int & 0xff as libc::c_int) as libc::c_longlong;
    *pVal = v;
    return 9 as libc::c_int;
}
/*
** Return the number of bytes of space used by an SQLite value of type
** eType.
*/
unsafe extern "C" fn dbdataValueBytes(mut eType: libc::c_int) -> libc::c_int {
    match eType {
        0 | 8 | 9 | 10 | 11 => return 0 as libc::c_int,
        1 => return 1 as libc::c_int,
        2 => return 2 as libc::c_int,
        3 => return 3 as libc::c_int,
        4 => return 4 as libc::c_int,
        5 => return 6 as libc::c_int,
        6 | 7 => return 8 as libc::c_int,
        _ => {
            if eType > 0 as libc::c_int {
                return (eType - 12 as libc::c_int) / 2 as libc::c_int;
            } else {
                return 0 as libc::c_int;
            }
        }
    };
}
/*
** Load a value of type eType from buffer pData and use it to set the
** result of context object pCtx.
*/
unsafe extern "C" fn dbdataValue(
    mut pCtx: *mut sqlite3_context,
    mut eType: libc::c_int,
    mut pData: *mut u8_0,
    mut nData: libc::c_int,
) {
    let mut current_block: u64;
    if eType >= 0 as libc::c_int && dbdataValueBytes(eType) <= nData {
        match eType {
            0 | 10 | 11 => {
                sqlite3_result_null(pCtx);
            }
            8 => {
                sqlite3_result_int(pCtx, 0 as libc::c_int);
            }
            9 => {
                sqlite3_result_int(pCtx, 1 as libc::c_int);
            }
            1 | 2 | 3 | 4 | 5 | 6 | 7 => {
                let mut v: sqlite3_uint64 =
                    *pData.offset(0 as libc::c_int as isize) as libc::c_schar as sqlite3_uint64;
                pData = pData.offset(1);
                match eType {
                    7 | 6 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int)
                                    as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize) as libc::c_ulonglong
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block = 2137783056811754434;
                    }
                    5 => {
                        current_block = 2137783056811754434;
                    }
                    4 => {
                        current_block = 10637777250407482471;
                    }
                    3 => {
                        current_block = 12113932628930099595;
                    }
                    2 => {
                        current_block = 16909558416691175540;
                    }
                    _ => {
                        current_block = 6009453772311597924;
                    }
                }
                match current_block {
                    2137783056811754434 => {
                        v = (v << 16 as libc::c_int)
                            .wrapping_add(
                                ((*pData.offset(0 as libc::c_int as isize) as libc::c_int)
                                    << 8 as libc::c_int)
                                    as libc::c_ulonglong,
                            )
                            .wrapping_add(
                                *pData.offset(1 as libc::c_int as isize) as libc::c_ulonglong
                            );
                        pData = pData.offset(2 as libc::c_int as isize);
                        current_block = 10637777250407482471;
                    }
                    _ => {}
                }
                match current_block {
                    10637777250407482471 => {
                        v = (v << 8 as libc::c_int).wrapping_add(
                            *pData.offset(0 as libc::c_int as isize) as libc::c_ulonglong,
                        );
                        pData = pData.offset(1);
                        current_block = 12113932628930099595;
                    }
                    _ => {}
                }
                match current_block {
                    12113932628930099595 => {
                        v = (v << 8 as libc::c_int).wrapping_add(
                            *pData.offset(0 as libc::c_int as isize) as libc::c_ulonglong,
                        );
                        pData = pData.offset(1);
                        current_block = 16909558416691175540;
                    }
                    _ => {}
                }
                match current_block {
                    16909558416691175540 => {
                        v = (v << 8 as libc::c_int).wrapping_add(
                            *pData.offset(0 as libc::c_int as isize) as libc::c_ulonglong,
                        );
                        pData = pData.offset(1)
                    }
                    _ => {}
                }
                if eType == 7 as libc::c_int {
                    let mut r: libc::c_double = 0.;
                    memcpy(
                        &mut r as *mut libc::c_double as *mut libc::c_void,
                        &mut v as *mut sqlite3_uint64 as *const libc::c_void,
                        ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                    );
                    sqlite3_result_double(pCtx, r);
                } else {
                    sqlite3_result_int64(pCtx, v as sqlite3_int64);
                }
            }
            _ => {
                let mut n: libc::c_int = (eType - 12 as libc::c_int) / 2 as libc::c_int;
                if eType % 2 as libc::c_int != 0 {
                    sqlite3_result_text(
                        pCtx,
                        pData as *const libc::c_char,
                        n,
                        ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                            -(1 as libc::c_int) as libc::intptr_t,
                        ),
                    );
                } else {
                    sqlite3_result_blob(
                        pCtx,
                        pData as *const libc::c_void,
                        n,
                        ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                            -(1 as libc::c_int) as libc::intptr_t,
                        ),
                    );
                }
            }
        }
    };
}
/*
** Move an sqlite_dbdata or sqlite_dbptr cursor to the next entry.
*/
unsafe extern "C" fn dbdataNext(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    (*pCsr).iRowid += 1;
    loop {
        let mut rc: libc::c_int = 0;
        let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
            100 as libc::c_int
        } else {
            0 as libc::c_int
        };
        let mut bNextPage: libc::c_int = 0 as libc::c_int;
        if (*pCsr).aPage.is_null() {
            loop {
                if (*pCsr).bOnePage == 0 as libc::c_int && (*pCsr).iPgno > (*pCsr).szDb {
                    return 0 as libc::c_int;
                } else {
                    rc = dbdataLoadPage(
                        pCsr,
                        (*pCsr).iPgno as libc::c_uint,
                        &mut (*pCsr).aPage,
                        &mut (*pCsr).nPage,
                    );
                    if rc != 0 as libc::c_int {
                        return rc;
                    } else {
                        if !(*pCsr).aPage.is_null() {
                            break;
                        }
                        (*pCsr).iPgno += 1
                    }
                }
            }
            (*pCsr).iCell = if (*pTab).bPtr != 0 {
                -(2 as libc::c_int)
            } else {
                0 as libc::c_int
            };
            (*pCsr).nCell =
                get_uint16(&mut *(*pCsr).aPage.offset((iOff + 3 as libc::c_int) as isize))
                    as libc::c_int
        }
        if (*pTab).bPtr != 0 {
            if *(*pCsr).aPage.offset(iOff as isize) as libc::c_int != 0x2 as libc::c_int
                && *(*pCsr).aPage.offset(iOff as isize) as libc::c_int != 0x5 as libc::c_int
            {
                (*pCsr).iCell = (*pCsr).nCell
            }
            (*pCsr).iCell += 1;
            if (*pCsr).iCell >= (*pCsr).nCell {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                (*pCsr).aPage = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                } else {
                    (*pCsr).iPgno += 1
                }
            } else {
                return 0 as libc::c_int;
            }
        } else {
            /* If there is no record loaded, load it now. */
            if (*pCsr).pRec.is_null() {
                let mut bHasRowid: libc::c_int = 0 as libc::c_int;
                let mut nPointer: libc::c_int = 0 as libc::c_int;
                let mut nPayload: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut nHdr: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
                let mut iHdr: libc::c_int = 0;
                let mut U: libc::c_int = 0;
                let mut X: libc::c_int = 0;
                let mut nLocal: libc::c_int = 0;
                match *(*pCsr).aPage.offset(iOff as isize) as libc::c_int {
                    2 => nPointer = 4 as libc::c_int,
                    10 => {}
                    13 => bHasRowid = 1 as libc::c_int,
                    _ => {
                        /* This is not a b-tree page with records on it. Continue. */
                        (*pCsr).iCell = (*pCsr).nCell
                    }
                }
                if (*pCsr).iCell >= (*pCsr).nCell {
                    bNextPage = 1 as libc::c_int
                } else {
                    iOff += 8 as libc::c_int + nPointer + (*pCsr).iCell * 2 as libc::c_int;
                    if iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int
                    } else {
                        iOff = get_uint16(&mut *(*pCsr).aPage.offset(iOff as isize)) as libc::c_int
                    }
                    /* For an interior node cell, skip past the child-page number */
                    iOff += nPointer;
                    /* Load the "byte of payload including overflow" field */
                    if bNextPage != 0 || iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int
                    } else {
                        iOff += dbdataGetVarint(
                            &mut *(*pCsr).aPage.offset(iOff as isize),
                            &mut nPayload,
                        )
                    }
                    /* If this is a leaf intkey cell, load the rowid */
                    if bHasRowid != 0 && bNextPage == 0 && iOff < (*pCsr).nPage {
                        iOff += dbdataGetVarint(
                            &mut *(*pCsr).aPage.offset(iOff as isize),
                            &mut (*pCsr).iIntkey,
                        )
                    }
                    /* Figure out how much data to read from the local page */
                    U = (*pCsr).nPage;
                    if bHasRowid != 0 {
                        X = U - 35 as libc::c_int
                    } else {
                        X = (U - 12 as libc::c_int) * 64 as libc::c_int / 255 as libc::c_int
                            - 23 as libc::c_int
                    }
                    if nPayload <= X as libc::c_longlong {
                        nLocal = nPayload as libc::c_int
                    } else {
                        let mut M: libc::c_int = 0;
                        let mut K: libc::c_int = 0;
                        M = (U - 12 as libc::c_int) * 32 as libc::c_int / 255 as libc::c_int
                            - 23 as libc::c_int;
                        K = (M as libc::c_longlong
                            + (nPayload - M as libc::c_longlong)
                                % (U - 4 as libc::c_int) as libc::c_longlong)
                            as libc::c_int;
                        if K <= X {
                            nLocal = K
                        } else {
                            nLocal = M
                        }
                    }
                    if bNextPage != 0 || nLocal + iOff > (*pCsr).nPage {
                        bNextPage = 1 as libc::c_int
                    } else {
                        /* Allocate space for payload. And a bit more to catch small buffer
                         ** overruns caused by attempting to read a varint or similar from
                         ** near the end of a corrupt record.  */
                        (*pCsr).pRec = sqlite3_malloc64(
                            (nPayload + 100 as libc::c_int as libc::c_longlong) as sqlite3_uint64,
                        ) as *mut u8_0;
                        if (*pCsr).pRec.is_null() {
                            return 7 as libc::c_int;
                        } else {
                            memset(
                                (*pCsr).pRec as *mut libc::c_void,
                                0 as libc::c_int,
                                (nPayload + 100 as libc::c_int as libc::c_longlong)
                                    as libc::c_ulong,
                            );
                            (*pCsr).nRec = nPayload as libc::c_int;
                            /* Load the nLocal bytes of payload */
                            memcpy(
                                (*pCsr).pRec as *mut libc::c_void,
                                &mut *(*pCsr).aPage.offset(iOff as isize) as *mut u8_0
                                    as *const libc::c_void,
                                nLocal as libc::c_ulong,
                            );
                            iOff += nLocal;
                            /* Load content from overflow pages */
                            if nPayload > nLocal as libc::c_longlong {
                                let mut nRem: sqlite3_int64 = nPayload - nLocal as libc::c_longlong;
                                let mut pgnoOvfl: libc::c_uint =
                                    get_uint32(&mut *(*pCsr).aPage.offset(iOff as isize));
                                while nRem > 0 as libc::c_int as libc::c_longlong {
                                    let mut aOvfl: *mut u8_0 = 0 as *mut u8_0;
                                    let mut nOvfl: libc::c_int = 0 as libc::c_int;
                                    let mut nCopy: libc::c_int = 0;
                                    rc = dbdataLoadPage(pCsr, pgnoOvfl, &mut aOvfl, &mut nOvfl);
                                    if rc != 0 as libc::c_int {
                                        return rc;
                                    } else {
                                        if aOvfl.is_null() {
                                            break;
                                        }
                                        nCopy = U - 4 as libc::c_int;
                                        if nCopy as libc::c_longlong > nRem {
                                            nCopy = nRem as libc::c_int
                                        }
                                        memcpy(
                                            &mut *(*pCsr).pRec.offset((nPayload - nRem) as isize)
                                                as *mut u8_0
                                                as *mut libc::c_void,
                                            &mut *aOvfl.offset(4 as libc::c_int as isize)
                                                as *mut u8_0
                                                as *const libc::c_void,
                                            nCopy as libc::c_ulong,
                                        );
                                        nRem -= nCopy as libc::c_longlong;
                                        pgnoOvfl = get_uint32(aOvfl);
                                        sqlite3_free(aOvfl as *mut libc::c_void);
                                    }
                                }
                            }
                            iHdr = dbdataGetVarint((*pCsr).pRec, &mut nHdr);
                            (*pCsr).nHdr = nHdr as libc::c_int;
                            (*pCsr).pHdrPtr = &mut *(*pCsr).pRec.offset(iHdr as isize) as *mut u8_0;
                            (*pCsr).pPtr =
                                &mut *(*pCsr).pRec.offset((*pCsr).nHdr as isize) as *mut u8_0;
                            (*pCsr).iField = if bHasRowid != 0 {
                                -(1 as libc::c_int)
                            } else {
                                0 as libc::c_int
                            }
                        }
                    }
                }
            } else {
                (*pCsr).iField += 1;
                if (*pCsr).iField > 0 as libc::c_int {
                    let mut iType: sqlite3_int64 = 0;
                    if (*pCsr).pHdrPtr
                        > &mut *(*pCsr).pRec.offset((*pCsr).nRec as isize) as *mut u8_0
                    {
                        bNextPage = 1 as libc::c_int
                    } else {
                        (*pCsr).pHdrPtr =
                            (*pCsr)
                                .pHdrPtr
                                .offset(dbdataGetVarint((*pCsr).pHdrPtr, &mut iType) as isize);
                        (*pCsr).pPtr = (*pCsr)
                            .pPtr
                            .offset(dbdataValueBytes(iType as libc::c_int) as isize)
                    }
                }
            }
            if bNextPage != 0 {
                sqlite3_free((*pCsr).aPage as *mut libc::c_void);
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                (*pCsr).aPage = 0 as *mut u8_0;
                (*pCsr).pRec = 0 as *mut u8_0;
                if (*pCsr).bOnePage != 0 {
                    return 0 as libc::c_int;
                } else {
                    (*pCsr).iPgno += 1
                }
            } else if (*pCsr).iField < 0 as libc::c_int
                || (*pCsr).pHdrPtr < &mut *(*pCsr).pRec.offset((*pCsr).nHdr as isize) as *mut u8_0
            {
                return 0 as libc::c_int;
            } else {
                /* Advance to the next cell. The next iteration of the loop will load
                 ** the record and so on. */
                sqlite3_free((*pCsr).pRec as *mut libc::c_void);
                (*pCsr).pRec = 0 as *mut u8_0;
                (*pCsr).iCell += 1
            }
        }
    }
}
/*
** Return true if the cursor is at EOF.
*/
unsafe extern "C" fn dbdataEof(mut pCursor: *mut sqlite3_vtab_cursor) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    return ((*pCsr).aPage == 0 as *mut u8_0) as libc::c_int;
}
/*
** Determine the size in pages of database zSchema (where zSchema is
** "main", "temp" or the name of an attached database) and set
** pCsr->szDb accordingly. If successful, return SQLITE_OK. Otherwise,
** an SQLite error code.
*/
unsafe extern "C" fn dbdataDbsize(
    mut pCsr: *mut DbdataCursor,
    mut zSchema: *const libc::c_char,
) -> libc::c_int {
    let mut pTab: *mut DbdataTable = (*pCsr).base.pVtab as *mut DbdataTable;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut rc2: libc::c_int = 0;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    zSql = sqlite3_mprintf(
        b"PRAGMA %Q.page_count\x00" as *const u8 as *const libc::c_char,
        zSchema,
    );
    if zSql.is_null() {
        return 7 as libc::c_int;
    } else {
        rc = sqlite3_prepare_v2(
            (*pTab).db,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
        if rc == 0 as libc::c_int && sqlite3_step(pStmt) == 100 as libc::c_int {
            (*pCsr).szDb = sqlite3_column_int(pStmt, 0 as libc::c_int)
        }
        rc2 = sqlite3_finalize(pStmt);
        if rc == 0 as libc::c_int {
            rc = rc2
        }
        return rc;
    };
}
/*
** xFilter method for sqlite_dbdata and sqlite_dbptr.
*/
unsafe extern "C" fn dbdataFilter(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut idxNum: libc::c_int,
    mut _idxStr: *const libc::c_char,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zSchema: *const libc::c_char = b"main\x00" as *const u8 as *const libc::c_char;
    dbdataResetCursor(pCsr);
    if idxNum & 0x1 as libc::c_int != 0 {
        zSchema = sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char
    }
    if idxNum & 0x2 as libc::c_int != 0 {
        (*pCsr).iPgno = sqlite3_value_int(*argv.offset((idxNum & 0x1 as libc::c_int) as isize));
        (*pCsr).bOnePage = 1 as libc::c_int
    } else {
        (*pCsr).nPage = dbdataDbsize(pCsr, zSchema);
        rc = dbdataDbsize(pCsr, zSchema)
    }
    if rc == 0 as libc::c_int {
        if !(*pTab).pStmt.is_null() {
            (*pCsr).pStmt = (*pTab).pStmt;
            (*pTab).pStmt = 0 as *mut sqlite3_stmt
        } else {
            rc = sqlite3_prepare_v2(
                (*pTab).db,
                b"SELECT data FROM sqlite_dbpage(?) WHERE pgno=?\x00" as *const u8
                    as *const libc::c_char,
                -(1 as libc::c_int),
                &mut (*pCsr).pStmt,
                0 as *mut *const libc::c_char,
            )
        }
    }
    if rc == 0 as libc::c_int {
        rc = sqlite3_bind_text(
            (*pCsr).pStmt,
            1 as libc::c_int,
            zSchema,
            -(1 as libc::c_int),
            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                -(1 as libc::c_int) as libc::intptr_t,
            ),
        )
    } else {
        (*pTab).base.zErrMsg = sqlite3_mprintf(
            b"%s\x00" as *const u8 as *const libc::c_char,
            sqlite3_errmsg((*pTab).db),
        )
    }
    if rc == 0 as libc::c_int {
        rc = dbdataNext(pCursor)
    }
    return rc;
}
/*
** Return a column for the sqlite_dbdata or sqlite_dbptr table.
*/
unsafe extern "C" fn dbdataColumn(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut ctx: *mut sqlite3_context,
    mut i: libc::c_int,
) -> libc::c_int {
    let mut current_block: u64;
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    let mut pTab: *mut DbdataTable = (*pCursor).pVtab as *mut DbdataTable;
    if (*pTab).bPtr != 0 {
        match i {
            0 => {
                current_block = 7318624551436118281;
                match current_block {
                    7318624551436118281 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    _ => {
                        let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
                            100 as libc::c_int
                        } else {
                            0 as libc::c_int
                        };
                        if (*pCsr).iCell < 0 as libc::c_int {
                            iOff += 8 as libc::c_int
                        } else {
                            iOff += 12 as libc::c_int + (*pCsr).iCell * 2 as libc::c_int;
                            if iOff > (*pCsr).nPage {
                                return 0 as libc::c_int;
                            } else {
                                iOff = get_uint16(&mut *(*pCsr).aPage.offset(iOff as isize))
                                    as libc::c_int
                            }
                        }
                        if iOff <= (*pCsr).nPage {
                            sqlite3_result_int64(
                                ctx,
                                get_uint32(&mut *(*pCsr).aPage.offset(iOff as isize))
                                    as sqlite3_int64,
                            );
                        }
                    }
                }
            }
            1 => {
                current_block = 735147466149431745;
                match current_block {
                    7318624551436118281 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    _ => {
                        let mut iOff: libc::c_int = if (*pCsr).iPgno == 1 as libc::c_int {
                            100 as libc::c_int
                        } else {
                            0 as libc::c_int
                        };
                        if (*pCsr).iCell < 0 as libc::c_int {
                            iOff += 8 as libc::c_int
                        } else {
                            iOff += 12 as libc::c_int + (*pCsr).iCell * 2 as libc::c_int;
                            if iOff > (*pCsr).nPage {
                                return 0 as libc::c_int;
                            } else {
                                iOff = get_uint16(&mut *(*pCsr).aPage.offset(iOff as isize))
                                    as libc::c_int
                            }
                        }
                        if iOff <= (*pCsr).nPage {
                            sqlite3_result_int64(
                                ctx,
                                get_uint32(&mut *(*pCsr).aPage.offset(iOff as isize))
                                    as sqlite3_int64,
                            );
                        }
                    }
                }
            }
            _ => {}
        }
    } else {
        match i {
            0 => {
                current_block = 6715194043675011634;
                match current_block {
                    16723226498680350474 => {
                        sqlite3_result_int(ctx, (*pCsr).iField);
                    }
                    6715194043675011634 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    7366050386616122734 => {
                        sqlite3_result_int(ctx, (*pCsr).iCell);
                    }
                    _ => {
                        if (*pCsr).iField < 0 as libc::c_int {
                            sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                        } else {
                            let mut iType: sqlite3_int64 = 0;
                            dbdataGetVarint((*pCsr).pHdrPtr, &mut iType);
                            dbdataValue(
                                ctx,
                                iType as libc::c_int,
                                (*pCsr).pPtr,
                                (&mut *(*pCsr).pRec.offset((*pCsr).nRec as isize) as *mut u8_0)
                                    .offset_from((*pCsr).pPtr)
                                    as libc::c_long as libc::c_int,
                            );
                        }
                    }
                }
            }
            1 => {
                current_block = 7366050386616122734;
                match current_block {
                    16723226498680350474 => {
                        sqlite3_result_int(ctx, (*pCsr).iField);
                    }
                    6715194043675011634 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    7366050386616122734 => {
                        sqlite3_result_int(ctx, (*pCsr).iCell);
                    }
                    _ => {
                        if (*pCsr).iField < 0 as libc::c_int {
                            sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                        } else {
                            let mut iType: sqlite3_int64 = 0;
                            dbdataGetVarint((*pCsr).pHdrPtr, &mut iType);
                            dbdataValue(
                                ctx,
                                iType as libc::c_int,
                                (*pCsr).pPtr,
                                (&mut *(*pCsr).pRec.offset((*pCsr).nRec as isize) as *mut u8_0)
                                    .offset_from((*pCsr).pPtr)
                                    as libc::c_long as libc::c_int,
                            );
                        }
                    }
                }
            }
            2 => {
                current_block = 16723226498680350474;
                match current_block {
                    16723226498680350474 => {
                        sqlite3_result_int(ctx, (*pCsr).iField);
                    }
                    6715194043675011634 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    7366050386616122734 => {
                        sqlite3_result_int(ctx, (*pCsr).iCell);
                    }
                    _ => {
                        if (*pCsr).iField < 0 as libc::c_int {
                            sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                        } else {
                            let mut iType: sqlite3_int64 = 0;
                            dbdataGetVarint((*pCsr).pHdrPtr, &mut iType);
                            dbdataValue(
                                ctx,
                                iType as libc::c_int,
                                (*pCsr).pPtr,
                                (&mut *(*pCsr).pRec.offset((*pCsr).nRec as isize) as *mut u8_0)
                                    .offset_from((*pCsr).pPtr)
                                    as libc::c_long as libc::c_int,
                            );
                        }
                    }
                }
            }
            3 => {
                current_block = 4808432441040389987;
                match current_block {
                    16723226498680350474 => {
                        sqlite3_result_int(ctx, (*pCsr).iField);
                    }
                    6715194043675011634 => {
                        sqlite3_result_int64(ctx, (*pCsr).iPgno as sqlite3_int64);
                    }
                    7366050386616122734 => {
                        sqlite3_result_int(ctx, (*pCsr).iCell);
                    }
                    _ => {
                        if (*pCsr).iField < 0 as libc::c_int {
                            sqlite3_result_int64(ctx, (*pCsr).iIntkey);
                        } else {
                            let mut iType: sqlite3_int64 = 0;
                            dbdataGetVarint((*pCsr).pHdrPtr, &mut iType);
                            dbdataValue(
                                ctx,
                                iType as libc::c_int,
                                (*pCsr).pPtr,
                                (&mut *(*pCsr).pRec.offset((*pCsr).nRec as isize) as *mut u8_0)
                                    .offset_from((*pCsr).pPtr)
                                    as libc::c_long as libc::c_int,
                            );
                        }
                    }
                }
            }
            _ => {}
        }
    }
    return 0 as libc::c_int;
}
/*
** Return the rowid for an sqlite_dbdata or sqlite_dptr table.
*/
unsafe extern "C" fn dbdataRowid(
    mut pCursor: *mut sqlite3_vtab_cursor,
    mut pRowid: *mut sqlite_int64,
) -> libc::c_int {
    let mut pCsr: *mut DbdataCursor = pCursor as *mut DbdataCursor;
    *pRowid = (*pCsr).iRowid;
    return 0 as libc::c_int;
}
/*
** Invoke this routine to register the "sqlite_dbdata" virtual table module
*/
unsafe extern "C" fn sqlite3DbdataRegister(mut db: *mut sqlite3) -> libc::c_int {
    static mut dbdata_module: sqlite3_module = unsafe {
        {
            let mut init = sqlite3_module {
                iVersion: 0 as libc::c_int,
                xCreate: None,
                xConnect: Some(
                    dbdataConnect
                        as unsafe extern "C" fn(
                            _: *mut sqlite3,
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *const *const libc::c_char,
                            _: *mut *mut sqlite3_vtab,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                xBestIndex: Some(
                    dbdataBestIndex
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut sqlite3_index_info,
                        ) -> libc::c_int,
                ),
                xDisconnect: Some(
                    dbdataDisconnect as unsafe extern "C" fn(_: *mut sqlite3_vtab) -> libc::c_int,
                ),
                xDestroy: None,
                xOpen: Some(
                    dbdataOpen
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab,
                            _: *mut *mut sqlite3_vtab_cursor,
                        ) -> libc::c_int,
                ),
                xClose: Some(
                    dbdataClose as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xFilter: Some(
                    dbdataFilter
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: libc::c_int,
                            _: *const libc::c_char,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> libc::c_int,
                ),
                xNext: Some(
                    dbdataNext as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xEof: Some(
                    dbdataEof as unsafe extern "C" fn(_: *mut sqlite3_vtab_cursor) -> libc::c_int,
                ),
                xColumn: Some(
                    dbdataColumn
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                        ) -> libc::c_int,
                ),
                xRowid: Some(
                    dbdataRowid
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_vtab_cursor,
                            _: *mut sqlite_int64,
                        ) -> libc::c_int,
                ),
                xUpdate: None,
                xBegin: None,
                xSync: None,
                xCommit: None,
                xRollback: None,
                xFindFunction: None,
                xRename: None,
                xSavepoint: None,
                xRelease: None,
                xRollbackTo: None,
                xShadowName: None,
            };
            init
        }
    };
    let mut rc: libc::c_int = sqlite3_create_module(
        db,
        b"sqlite_dbdata\x00" as *const u8 as *const libc::c_char,
        &mut dbdata_module,
        0 as *mut libc::c_void,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_create_module(
            db,
            b"sqlite_dbptr\x00" as *const u8 as *const libc::c_char,
            &mut dbdata_module,
            1 as libc::c_int as *mut libc::c_void,
        )
    }
    return rc;
}
pub unsafe extern "C" fn sqlite3_dbdata_init(
    mut db: *mut sqlite3,
    mut _pzErrMsg: *mut *mut libc::c_char,
    mut _pApi: *const sqlite3_api_routines,
) -> libc::c_int {
    return sqlite3DbdataRegister(db);
}
/* Unicode box-drawing characters */
static mut modeDescr: [*const libc::c_char; 17] = [
    b"line\x00" as *const u8 as *const libc::c_char,
    b"column\x00" as *const u8 as *const libc::c_char,
    b"list\x00" as *const u8 as *const libc::c_char,
    b"semi\x00" as *const u8 as *const libc::c_char,
    b"html\x00" as *const u8 as *const libc::c_char,
    b"insert\x00" as *const u8 as *const libc::c_char,
    b"quote\x00" as *const u8 as *const libc::c_char,
    b"tcl\x00" as *const u8 as *const libc::c_char,
    b"csv\x00" as *const u8 as *const libc::c_char,
    b"explain\x00" as *const u8 as *const libc::c_char,
    b"ascii\x00" as *const u8 as *const libc::c_char,
    b"prettyprint\x00" as *const u8 as *const libc::c_char,
    b"eqp\x00" as *const u8 as *const libc::c_char,
    b"json\x00" as *const u8 as *const libc::c_char,
    b"markdown\x00" as *const u8 as *const libc::c_char,
    b"table\x00" as *const u8 as *const libc::c_char,
    b"box\x00" as *const u8 as *const libc::c_char,
];
/*
** A callback for the sqlite3_log() interface.
*/
unsafe extern "C" fn shellLog(
    mut pArg: *mut libc::c_void,
    mut iErrCode: libc::c_int,
    mut zMsg: *const libc::c_char,
) {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if (*p).pLog.is_null() {
        return;
    } else {
        fprintf(
            (*p).pLog,
            b"(%d) %s\n\x00" as *const u8 as *const libc::c_char,
            iErrCode,
            zMsg,
        );
        fflush((*p).pLog);
        return;
    };
}
/*
** SQL function:  shell_putsnl(X)
**
** Write the text X to the screen (or whatever output is being directed)
** adding a newline at the end, and then return X.
*/
unsafe extern "C" fn shellPutsFunc(
    mut pCtx: *mut sqlite3_context,
    mut _nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut p: *mut ShellState = sqlite3_user_data(pCtx) as *mut ShellState;
    fprintf(
        (*p).out,
        b"%s\n\x00" as *const u8 as *const libc::c_char,
        sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)),
    );
    sqlite3_result_value(pCtx, *apVal.offset(0 as libc::c_int as isize));
}
/*
** If in safe mode, print an error message described by the arguments
** and exit immediately.
*/
unsafe extern "C" fn failIfSafeMode(
    mut p: *mut ShellState,
    mut zErrMsg: *const libc::c_char,
    mut args: ...
) {
    if (*p).bSafeMode != 0 {
        let mut ap: ::std::ffi::VaListImpl;
        let mut zMsg: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        zMsg = sqlite3_vmprintf(zErrMsg, ap.as_va_list());
        fprintf(
            stderr,
            b"line %d: \x00" as *const u8 as *const libc::c_char,
            (*p).lineno,
        );
        fprintf(
            stderr,
            b"%s\n\x00" as *const u8 as *const libc::c_char,
            zMsg,
        );
        exit(1 as libc::c_int);
    } else {
        return;
    };
}
/*
** SQL function:   edit(VALUE)
**                 edit(VALUE,EDITOR)
**
** These steps:
**
**     (1) Write VALUE into a temporary file.
**     (2) Run program EDITOR on that temporary file.
**     (3) Read the temporary file back and return its content as the result.
**     (4) Delete the temporary file
**
** If the EDITOR argument is omitted, use the value in the VISUAL
** environment variable.  If still there is no EDITOR, through an error.
**
** Also throw an error if the EDITOR program returns a non-zero exit code.
*/
unsafe extern "C" fn editFunc(
    mut context: *mut sqlite3_context,
    mut argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zEditor: *const libc::c_char = 0 as *const libc::c_char;
    let mut zTempFile: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut db: *mut sqlite3 = 0 as *mut sqlite3;
    let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut bBin: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut hasCRNL: libc::c_int = 0 as libc::c_int;
    let mut f: *mut FILE = 0 as *mut FILE;
    let mut sz: sqlite3_int64 = 0;
    let mut x: sqlite3_int64 = 0;
    let mut p: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
    if argc == 2 as libc::c_int {
        zEditor = sqlite3_value_text(*argv.offset(1 as libc::c_int as isize)) as *const libc::c_char
    } else {
        zEditor = getenv(b"VISUAL\x00" as *const u8 as *const libc::c_char)
    }
    if zEditor.is_null() {
        sqlite3_result_error(
            context,
            b"no editor for edit()\x00" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    } else if sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 5 as libc::c_int {
        sqlite3_result_error(
            context,
            b"NULL input to edit()\x00" as *const u8 as *const libc::c_char,
            -(1 as libc::c_int),
        );
        return;
    } else {
        db = sqlite3_context_db_handle(context);
        zTempFile = 0 as *mut libc::c_char;
        sqlite3_file_control(
            db,
            0 as *const libc::c_char,
            16 as libc::c_int,
            &mut zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
        );
        if zTempFile.is_null() {
            let mut r: sqlite3_uint64 = 0 as libc::c_int as sqlite3_uint64;
            sqlite3_randomness(
                ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
                &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
            );
            zTempFile = sqlite3_mprintf(b"temp%llx\x00" as *const u8 as *const libc::c_char, r);
            if zTempFile.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            }
        }
        bBin = (sqlite3_value_type(*argv.offset(0 as libc::c_int as isize)) == 4 as libc::c_int)
            as libc::c_int;
        /* When writing the file to be edited, do \n to \r\n conversions on systems
         ** that want \r\n line endings */
        f = fopen(
            zTempFile,
            if bBin != 0 {
                b"wb\x00" as *const u8 as *const libc::c_char
            } else {
                b"w\x00" as *const u8 as *const libc::c_char
            },
        );
        if f.is_null() {
            sqlite3_result_error(
                context,
                b"edit() cannot open temp file\x00" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
            );
        } else {
            sz = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize)) as sqlite3_int64;
            if bBin != 0 {
                x = fwrite(
                    sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)),
                    1 as libc::c_int as libc::c_ulong,
                    sz as size_t,
                    f,
                ) as sqlite3_int64
            } else {
                let mut z: *const libc::c_char =
                    sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                        as *const libc::c_char;
                /* Remember whether or not the value originally contained \r\n */
                if !z.is_null()
                    && !strstr(z, b"\r\n\x00" as *const u8 as *const libc::c_char).is_null()
                {
                    hasCRNL = 1 as libc::c_int
                }
                x = fwrite(
                    sqlite3_value_text(*argv.offset(0 as libc::c_int as isize))
                        as *const libc::c_void,
                    1 as libc::c_int as libc::c_ulong,
                    sz as size_t,
                    f,
                ) as sqlite3_int64
            }
            fclose(f);
            f = 0 as *mut FILE;
            if x != sz {
                sqlite3_result_error(
                    context,
                    b"edit() could not write the whole file\x00" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                );
            } else {
                zCmd = sqlite3_mprintf(
                    b"%s \"%s\"\x00" as *const u8 as *const libc::c_char,
                    zEditor,
                    zTempFile,
                );
                if zCmd.is_null() {
                    sqlite3_result_error_nomem(context);
                } else {
                    rc = system(zCmd);
                    sqlite3_free(zCmd as *mut libc::c_void);
                    if rc != 0 {
                        sqlite3_result_error(
                            context,
                            b"EDITOR returned non-zero\x00" as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                        );
                    } else {
                        f = fopen(zTempFile, b"rb\x00" as *const u8 as *const libc::c_char);
                        if f.is_null() {
                            sqlite3_result_error(
                                context,
                                b"edit() cannot reopen temp file after edit\x00" as *const u8
                                    as *const libc::c_char,
                                -(1 as libc::c_int),
                            );
                        } else {
                            fseek(f, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
                            sz = ftell(f) as sqlite3_int64;
                            rewind(f);
                            p = sqlite3_malloc64(
                                (sz + 1 as libc::c_int as libc::c_longlong) as sqlite3_uint64,
                            ) as *mut libc::c_uchar;
                            if p.is_null() {
                                sqlite3_result_error_nomem(context);
                            } else {
                                x = fread(
                                    p as *mut libc::c_void,
                                    1 as libc::c_int as libc::c_ulong,
                                    sz as size_t,
                                    f,
                                ) as sqlite3_int64;
                                fclose(f);
                                f = 0 as *mut FILE;
                                if x != sz {
                                    sqlite3_result_error(
                                        context,
                                        b"could not read back the whole file\x00" as *const u8
                                            as *const libc::c_char,
                                        -(1 as libc::c_int),
                                    );
                                } else {
                                    if bBin != 0 {
                                        sqlite3_result_blob64(
                                            context,
                                            p as *const libc::c_void,
                                            sz as sqlite3_uint64,
                                            Some(
                                                sqlite3_free
                                                    as unsafe extern "C" fn(
                                                        _: *mut libc::c_void,
                                                    )
                                                        -> (),
                                            ),
                                        );
                                    } else {
                                        let mut i: sqlite3_int64 = 0;
                                        let mut j: sqlite3_int64 = 0;
                                        if !(hasCRNL != 0) {
                                            /* If the file did not originally contain \r\n then convert any new
                                             ** \r\n back into \n */
                                            j = 0 as libc::c_int as sqlite3_int64;
                                            i = j;
                                            while i < sz {
                                                if *p.offset(i as isize) as libc::c_int
                                                    == '\r' as i32
                                                    && *p.offset(
                                                        (i + 1 as libc::c_int as libc::c_longlong)
                                                            as isize,
                                                    )
                                                        as libc::c_int
                                                        == '\n' as i32
                                                {
                                                    i += 1
                                                }
                                                let fresh36 = j;
                                                j = j + 1;
                                                *p.offset(fresh36 as isize) = *p.offset(i as isize);
                                                i += 1
                                            }
                                            sz = j;
                                            *p.offset(sz as isize) =
                                                0 as libc::c_int as libc::c_uchar
                                        }
                                        sqlite3_result_text64(
                                            context,
                                            p as *const libc::c_char,
                                            sz as sqlite3_uint64,
                                            Some(
                                                sqlite3_free
                                                    as unsafe extern "C" fn(
                                                        _: *mut libc::c_void,
                                                    )
                                                        -> (),
                                            ),
                                            1 as libc::c_int as libc::c_uchar,
                                        );
                                        /* If the original contains \r\n then do no conversions back to \n */
                                    }
                                    p = 0 as *mut libc::c_uchar
                                }
                            }
                        }
                    }
                }
            }
        }
        if !f.is_null() {
            fclose(f);
        }
        unlink(zTempFile);
        sqlite3_free(zTempFile as *mut libc::c_void);
        sqlite3_free(p as *mut libc::c_void);
        return;
    };
}
/* SQLITE_NOHAVE_SYSTEM */
/*
** Save or restore the current output mode
*/
unsafe extern "C" fn outputModePush(mut p: *mut ShellState) {
    (*p).modePrior = (*p).mode;
    (*p).priorShFlgs = (*p).shellFlgs;
    memcpy(
        (*p).colSepPrior.as_mut_ptr() as *mut libc::c_void,
        (*p).colSeparator.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        (*p).rowSepPrior.as_mut_ptr() as *mut libc::c_void,
        (*p).rowSeparator.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
unsafe extern "C" fn outputModePop(mut p: *mut ShellState) {
    (*p).mode = (*p).modePrior;
    (*p).shellFlgs = (*p).priorShFlgs;
    memcpy(
        (*p).colSeparator.as_mut_ptr() as *mut libc::c_void,
        (*p).colSepPrior.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
    memcpy(
        (*p).rowSeparator.as_mut_ptr() as *mut libc::c_void,
        (*p).rowSepPrior.as_mut_ptr() as *const libc::c_void,
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong,
    );
}
/*
** Output the given string as a hex-encoded blob (eg. X'1234' )
*/
unsafe extern "C" fn output_hex_blob(
    mut out: *mut FILE,
    mut pBlob: *const libc::c_void,
    mut nBlob: libc::c_int,
) {
    let mut i: libc::c_int = 0;
    let mut zBlob: *mut libc::c_char = pBlob as *mut libc::c_char;
    fprintf(out, b"X\'\x00" as *const u8 as *const libc::c_char);
    i = 0 as libc::c_int;
    while i < nBlob {
        fprintf(
            out,
            b"%02x\x00" as *const u8 as *const libc::c_char,
            *zBlob.offset(i as isize) as libc::c_int & 0xff as libc::c_int,
        );
        i += 1
    }
    fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
}
/*
** Find a string that is not found anywhere in z[].  Return a pointer
** to that string.
**
** Try to use zA and zB first.  If both of those are already found in z[]
** then make up some string and store it in the buffer zBuf.
*/
unsafe extern "C" fn unused_string(
    mut z: *const libc::c_char,
    mut zA: *const libc::c_char,
    mut zB: *const libc::c_char,
    mut zBuf: *mut libc::c_char,
) -> *const libc::c_char
/* Space to store a generated string */ {
    let mut i: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    if strstr(z, zA).is_null() {
        return zA;
    } else if strstr(z, zB).is_null() {
        return zB;
    } else {
        loop {
            let fresh37 = i;
            i = i.wrapping_add(1);
            sqlite3_snprintf(
                20 as libc::c_int,
                zBuf,
                b"(%s%u)\x00" as *const u8 as *const libc::c_char,
                zA,
                fresh37,
            );
            if strstr(z, zBuf).is_null() {
                break;
            }
        }
        return zBuf;
    };
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
**
** See also: output_quoted_escaped_string()
*/
unsafe extern "C" fn output_quoted_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32) {
            break;
        }
        i += 1
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"\'%s\'\x00" as *const u8 as *const libc::c_char, z);
    } else {
        fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int && c as libc::c_int != '\'' as i32) {
                    break;
                }
                i += 1
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1
            }
            if i != 0 {
                fprintf(out, b"%.*s\x00" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize)
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1)
            }
        }
        fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
    };
}
/*
** Output the given string as a quoted string using SQL quoting conventions.
** Additionallly , escape the "\n" and "\r" characters so that they do not
** get corrupted by end-of-line translation facilities in some operating
** systems.
**
** This is like output_quoted_string() but with the addition of the \r\n
** escape mechanism.
*/
unsafe extern "C" fn output_quoted_escaped_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    i = 0 as libc::c_int;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int
            && c as libc::c_int != '\'' as i32
            && c as libc::c_int != '\n' as i32
            && c as libc::c_int != '\r' as i32)
        {
            break;
        }
        i += 1
    }
    if c as libc::c_int == 0 as libc::c_int {
        fprintf(out, b"\'%s\'\x00" as *const u8 as *const libc::c_char, z);
    } else {
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        i = 0 as libc::c_int;
        while *z.offset(i as isize) != 0 {
            if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
                nNL += 1
            }
            if *z.offset(i as isize) as libc::c_int == '\r' as i32 {
                nCR += 1
            }
            i += 1
        }
        if nNL != 0 {
            fprintf(out, b"replace(\x00" as *const u8 as *const libc::c_char);
            zNL = unused_string(
                z,
                b"\\n\x00" as *const u8 as *const libc::c_char,
                b"\\012\x00" as *const u8 as *const libc::c_char,
                zBuf1.as_mut_ptr(),
            )
        }
        if nCR != 0 {
            fprintf(out, b"replace(\x00" as *const u8 as *const libc::c_char);
            zCR = unused_string(
                z,
                b"\\r\x00" as *const u8 as *const libc::c_char,
                b"\\015\x00" as *const u8 as *const libc::c_char,
                zBuf2.as_mut_ptr(),
            )
        }
        fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
        while *z != 0 {
            i = 0 as libc::c_int;
            loop {
                c = *z.offset(i as isize);
                if !(c as libc::c_int != 0 as libc::c_int
                    && c as libc::c_int != '\n' as i32
                    && c as libc::c_int != '\r' as i32
                    && c as libc::c_int != '\'' as i32)
                {
                    break;
                }
                i += 1
            }
            if c as libc::c_int == '\'' as i32 {
                i += 1
            }
            if i != 0 {
                fprintf(out, b"%.*s\x00" as *const u8 as *const libc::c_char, i, z);
                z = z.offset(i as isize)
            }
            if c as libc::c_int == '\'' as i32 {
                fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
            } else {
                if c as libc::c_int == 0 as libc::c_int {
                    break;
                }
                z = z.offset(1);
                if c as libc::c_int == '\n' as i32 {
                    fprintf(out, b"%s\x00" as *const u8 as *const libc::c_char, zNL);
                } else {
                    fprintf(out, b"%s\x00" as *const u8 as *const libc::c_char, zCR);
                }
            }
        }
        fprintf(out, b"\'\x00" as *const u8 as *const libc::c_char);
        if nCR != 0 {
            fprintf(
                out,
                b",\'%s\',char(13))\x00" as *const u8 as *const libc::c_char,
                zCR,
            );
        }
        if nNL != 0 {
            fprintf(
                out,
                b",\'%s\',char(10))\x00" as *const u8 as *const libc::c_char,
                zNL,
            );
        }
    };
}
/*
** Output the given string as a quoted according to C or TCL quoting rules.
*/
unsafe extern "C" fn output_c_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut c: libc::c_uint = 0;
    fputc('\"' as i32, out);
    loop {
        let fresh38 = z;
        z = z.offset(1);
        c = *fresh38 as libc::c_uint;
        if !(c != 0 as libc::c_int as libc::c_uint) {
            break;
        }
        if c == '\\' as i32 as libc::c_uint {
            fputc(c as libc::c_int, out);
            fputc(c as libc::c_int, out);
        } else if c == '\"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('\"' as i32, out);
        } else if c == '\t' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('t' as i32, out);
        } else if c == '\n' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('n' as i32, out);
        } else if c == '\r' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc('r' as i32, out);
        } else if *(*__ctype_b_loc())
            .offset((c & 0xff as libc::c_int as libc::c_uint) as libc::c_int as isize)
            as libc::c_int
            & _ISprint as libc::c_int as libc::c_ushort as libc::c_int
            == 0
        {
            fprintf(
                out,
                b"\\%03o\x00" as *const u8 as *const libc::c_char,
                c & 0xff as libc::c_int as libc::c_uint,
            );
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('\"' as i32, out);
}
/*
** Output the given string as a quoted according to JSON quoting rules.
*/
unsafe extern "C" fn output_json_string(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut n: libc::c_int,
) {
    let mut c: libc::c_uint = 0;
    if n < 0 as libc::c_int {
        n = strlen(z) as libc::c_int
    }
    fputc('\"' as i32, out);
    loop {
        let fresh39 = n;
        n = n - 1;
        if !(fresh39 != 0) {
            break;
        }
        let fresh40 = z;
        z = z.offset(1);
        c = *fresh40 as libc::c_uint;
        if c == '\\' as i32 as libc::c_uint || c == '\"' as i32 as libc::c_uint {
            fputc('\\' as i32, out);
            fputc(c as libc::c_int, out);
        } else if c <= 0x1f as libc::c_int as libc::c_uint {
            fputc('\\' as i32, out);
            if c == '\u{8}' as i32 as libc::c_uint {
                fputc('b' as i32, out);
            } else if c == '\u{c}' as i32 as libc::c_uint {
                fputc('f' as i32, out);
            } else if c == '\n' as i32 as libc::c_uint {
                fputc('n' as i32, out);
            } else if c == '\r' as i32 as libc::c_uint {
                fputc('r' as i32, out);
            } else if c == '\t' as i32 as libc::c_uint {
                fputc('t' as i32, out);
            } else {
                fprintf(out, b"u%04x\x00" as *const u8 as *const libc::c_char, c);
            }
        } else {
            fputc(c as libc::c_int, out);
        }
    }
    fputc('\"' as i32, out);
}
/*
** Output the given string with characters that are special to
** HTML escaped.
*/
unsafe extern "C" fn output_html_string(mut out: *mut FILE, mut z: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    if z.is_null() {
        z = b"\x00" as *const u8 as *const libc::c_char
    }
    while *z != 0 {
        i = 0 as libc::c_int;
        while *z.offset(i as isize) as libc::c_int != 0
            && *z.offset(i as isize) as libc::c_int != '<' as i32
            && *z.offset(i as isize) as libc::c_int != '&' as i32
            && *z.offset(i as isize) as libc::c_int != '>' as i32
            && *z.offset(i as isize) as libc::c_int != '\"' as i32
            && *z.offset(i as isize) as libc::c_int != '\'' as i32
        {
            i += 1
        }
        if i > 0 as libc::c_int {
            fprintf(out, b"%.*s\x00" as *const u8 as *const libc::c_char, i, z);
        }
        if *z.offset(i as isize) as libc::c_int == '<' as i32 {
            fprintf(out, b"&lt;\x00" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '&' as i32 {
            fprintf(out, b"&amp;\x00" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '>' as i32 {
            fprintf(out, b"&gt;\x00" as *const u8 as *const libc::c_char);
        } else if *z.offset(i as isize) as libc::c_int == '\"' as i32 {
            fprintf(out, b"&quot;\x00" as *const u8 as *const libc::c_char);
        } else {
            if !(*z.offset(i as isize) as libc::c_int == '\'' as i32) {
                break;
            }
            fprintf(out, b"&#39;\x00" as *const u8 as *const libc::c_char);
        }
        z = z.offset((i + 1 as libc::c_int) as isize)
    }
}
/*
** If a field contains any character identified by a 1 in the following
** array, then the string must be quoted for CSV.
*/
static mut needCsvQuote: [libc::c_char; 256] = [
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    0 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
    1 as libc::c_int as libc::c_char,
];
/*
** Output a single term of CSV.  Actually, p->colSeparator is used for
** the separator, which may or may not be a comma.  p->nullValue is
** the null value.  Strings are quoted if necessary.  The separator
** is only issued if bSep is true.
*/
unsafe extern "C" fn output_csv(
    mut p: *mut ShellState,
    mut z: *const libc::c_char,
    mut bSep: libc::c_int,
) {
    let mut out: *mut FILE = (*p).out;
    if z.is_null() {
        fprintf(
            out,
            b"%s\x00" as *const u8 as *const libc::c_char,
            (*p).nullValue.as_mut_ptr(),
        );
    } else {
        let mut i: libc::c_int = 0;
        let mut nSep: libc::c_int = strlen30((*p).colSeparator.as_mut_ptr());
        i = 0 as libc::c_int;
        while *z.offset(i as isize) != 0 {
            if needCsvQuote[*(z as *mut libc::c_uchar).offset(i as isize) as usize] as libc::c_int
                != 0
                || *z.offset(i as isize) as libc::c_int
                    == (*p).colSeparator[0 as libc::c_int as usize] as libc::c_int
                    && (nSep == 1 as libc::c_int
                        || memcmp(
                            z as *const libc::c_void,
                            (*p).colSeparator.as_mut_ptr() as *const libc::c_void,
                            nSep as libc::c_ulong,
                        ) == 0 as libc::c_int)
            {
                i = 0 as libc::c_int;
                break;
            } else {
                i += 1
            }
        }
        if i == 0 as libc::c_int {
            let mut zQuoted: *mut libc::c_char =
                sqlite3_mprintf(b"\"%w\"\x00" as *const u8 as *const libc::c_char, z);
            fprintf(out, b"%s\x00" as *const u8 as *const libc::c_char, zQuoted);
            sqlite3_free(zQuoted as *mut libc::c_void);
        } else {
            fprintf(out, b"%s\x00" as *const u8 as *const libc::c_char, z);
        }
    }
    if bSep != 0 {
        fprintf(
            (*p).out,
            b"%s\x00" as *const u8 as *const libc::c_char,
            (*p).colSeparator.as_mut_ptr(),
        );
    };
}
/*
** This routine runs when the user presses Ctrl-C
*/
unsafe extern "C" fn interrupt_handler(mut _NotUsed: libc::c_int) {
    ::std::ptr::write_volatile(
        &mut seenInterrupt as *mut libc::c_int,
        ::std::ptr::read_volatile::<libc::c_int>(&seenInterrupt as *const libc::c_int) + 1,
    );
    if seenInterrupt > 2 as libc::c_int {
        exit(1 as libc::c_int);
    } else {
        if !globalDb.is_null() {
            sqlite3_interrupt(globalDb);
        }
        return;
    };
}
/*
** This authorizer runs in safe mode.
*/
unsafe extern "C" fn safeModeAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut _zA2: *const libc::c_char,
    mut _zA3: *const libc::c_char,
    mut _zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azProhibitedFunctions: [*const libc::c_char; 7] = [
        b"edit\x00" as *const u8 as *const libc::c_char,
        b"fts3_tokenizer\x00" as *const u8 as *const libc::c_char,
        b"load_extension\x00" as *const u8 as *const libc::c_char,
        b"readfile\x00" as *const u8 as *const libc::c_char,
        b"writefile\x00" as *const u8 as *const libc::c_char,
        b"zipfile\x00" as *const u8 as *const libc::c_char,
        b"zipfile_cds\x00" as *const u8 as *const libc::c_char,
    ];
    match op {
        24 => {
            failIfSafeMode(
                p,
                b"cannot run ATTACH in safe mode\x00" as *const u8 as *const libc::c_char,
            );
        }
        31 => {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::std::mem::size_of::<[*const libc::c_char; 7]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                    as libc::c_int
            {
                if sqlite3_stricmp(zA1, azProhibitedFunctions[i as usize]) == 0 as libc::c_int {
                    failIfSafeMode(
                        p,
                        b"cannot use the %s() function in safe mode\x00" as *const u8
                            as *const libc::c_char,
                        azProhibitedFunctions[i as usize],
                    );
                }
                i += 1
            }
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
/*
** When the ".auth ON" is set, the following authorizer callback is
** invoked.  It always returns SQLITE_OK.
*/
unsafe extern "C" fn shellAuth(
    mut pClientData: *mut libc::c_void,
    mut op: libc::c_int,
    mut zA1: *const libc::c_char,
    mut zA2: *const libc::c_char,
    mut zA3: *const libc::c_char,
    mut zA4: *const libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    static mut azAction: [*const libc::c_char; 34] = [
        0 as *const libc::c_char,
        b"CREATE_INDEX\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TABLE\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_INDEX\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TABLE\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_TRIGGER\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TEMP_VIEW\x00" as *const u8 as *const libc::c_char,
        b"CREATE_TRIGGER\x00" as *const u8 as *const libc::c_char,
        b"CREATE_VIEW\x00" as *const u8 as *const libc::c_char,
        b"DELETE\x00" as *const u8 as *const libc::c_char,
        b"DROP_INDEX\x00" as *const u8 as *const libc::c_char,
        b"DROP_TABLE\x00" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_INDEX\x00" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TABLE\x00" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_TRIGGER\x00" as *const u8 as *const libc::c_char,
        b"DROP_TEMP_VIEW\x00" as *const u8 as *const libc::c_char,
        b"DROP_TRIGGER\x00" as *const u8 as *const libc::c_char,
        b"DROP_VIEW\x00" as *const u8 as *const libc::c_char,
        b"INSERT\x00" as *const u8 as *const libc::c_char,
        b"PRAGMA\x00" as *const u8 as *const libc::c_char,
        b"READ\x00" as *const u8 as *const libc::c_char,
        b"SELECT\x00" as *const u8 as *const libc::c_char,
        b"TRANSACTION\x00" as *const u8 as *const libc::c_char,
        b"UPDATE\x00" as *const u8 as *const libc::c_char,
        b"ATTACH\x00" as *const u8 as *const libc::c_char,
        b"DETACH\x00" as *const u8 as *const libc::c_char,
        b"ALTER_TABLE\x00" as *const u8 as *const libc::c_char,
        b"REINDEX\x00" as *const u8 as *const libc::c_char,
        b"ANALYZE\x00" as *const u8 as *const libc::c_char,
        b"CREATE_VTABLE\x00" as *const u8 as *const libc::c_char,
        b"DROP_VTABLE\x00" as *const u8 as *const libc::c_char,
        b"FUNCTION\x00" as *const u8 as *const libc::c_char,
        b"SAVEPOINT\x00" as *const u8 as *const libc::c_char,
        b"RECURSIVE\x00" as *const u8 as *const libc::c_char,
    ];
    let mut i: libc::c_int = 0;
    let mut az: [*const libc::c_char; 4] = [0 as *const libc::c_char; 4];
    az[0 as libc::c_int as usize] = zA1;
    az[1 as libc::c_int as usize] = zA2;
    az[2 as libc::c_int as usize] = zA3;
    az[3 as libc::c_int as usize] = zA4;
    fprintf(
        (*p).out,
        b"authorizer: %s\x00" as *const u8 as *const libc::c_char,
        azAction[op as usize],
    );
    i = 0 as libc::c_int;
    while i < 4 as libc::c_int {
        fprintf((*p).out, b" \x00" as *const u8 as *const libc::c_char);
        if !az[i as usize].is_null() {
            output_c_string((*p).out, az[i as usize]);
        } else {
            fprintf((*p).out, b"NULL\x00" as *const u8 as *const libc::c_char);
        }
        i += 1
    }
    fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
    if (*p).bSafeMode != 0 {
        safeModeAuth(pClientData, op, zA1, zA2, zA3, zA4);
    }
    return 0 as libc::c_int;
}
/*
** Print a schema statement.  Part of MODE_Semi and MODE_Pretty output.
**
** This routine converts some CREATE TABLE statements for shadow tables
** in FTS3/4/5 into CREATE TABLE IF NOT EXISTS statements.
*/
unsafe extern "C" fn printSchemaLine(
    mut out: *mut FILE,
    mut z: *const libc::c_char,
    mut zTail: *const libc::c_char,
) {
    if z.is_null() {
        return;
    } else if zTail.is_null() {
        return;
    } else {
        if sqlite3_strglob(
            b"CREATE TABLE [\'\"]*\x00" as *const u8 as *const libc::c_char,
            z,
        ) == 0 as libc::c_int
        {
            fprintf(
                out,
                b"CREATE TABLE IF NOT EXISTS %s%s\x00" as *const u8 as *const libc::c_char,
                z.offset(13 as libc::c_int as isize),
                zTail,
            );
        } else {
            fprintf(
                out,
                b"%s%s\x00" as *const u8 as *const libc::c_char,
                z,
                zTail,
            );
        }
        return;
    };
}
unsafe extern "C" fn printSchemaLineN(
    mut out: *mut FILE,
    mut z: *mut libc::c_char,
    mut n: libc::c_int,
    mut zTail: *const libc::c_char,
) {
    let mut c: libc::c_char = *z.offset(n as isize);
    *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
    printSchemaLine(out, z, zTail);
    *z.offset(n as isize) = c;
}
/*
** Return true if string z[] has nothing but whitespace and comments to the
** end of the first line.
*/
unsafe extern "C" fn wsToEol(mut z: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while *z.offset(i as isize) != 0 {
        if *z.offset(i as isize) as libc::c_int == '\n' as i32 {
            return 1 as libc::c_int;
        } else if *(*__ctype_b_loc())
            .offset(*z.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int
            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            i += 1
        } else if *z.offset(i as isize) as libc::c_int == '-' as i32
            && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int == '-' as i32
        {
            return 1 as libc::c_int;
        } else {
            return 0 as libc::c_int;
        }
    }
    return 1 as libc::c_int;
}
/*
** Add a new entry to the EXPLAIN QUERY PLAN data
*/
unsafe extern "C" fn eqp_append(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut p2: libc::c_int,
    mut zText: *const libc::c_char,
) {
    let mut pNew: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut nText: libc::c_int = strlen30(zText);
    if (*p).autoEQPtest != 0 {
        fprintf(
            (*p).out,
            b"%d,%d,%s\n\x00" as *const u8 as *const libc::c_char,
            iEqpId,
            p2,
            zText,
        );
    }
    pNew = sqlite3_malloc64(
        (::std::mem::size_of::<EQPGraphRow>() as libc::c_ulong).wrapping_add(nText as libc::c_ulong)
            as sqlite3_uint64,
    ) as *mut EQPGraphRow;
    if pNew.is_null() {
        shell_out_of_memory();
    }
    (*pNew).iEqpId = iEqpId;
    (*pNew).iParentId = p2;
    memcpy(
        (*pNew).zText.as_mut_ptr() as *mut libc::c_void,
        zText as *const libc::c_void,
        (nText + 1 as libc::c_int) as libc::c_ulong,
    );
    (*pNew).pNext = 0 as *mut EQPGraphRow;
    if !(*p).sGraph.pLast.is_null() {
        (*(*p).sGraph.pLast).pNext = pNew
    } else {
        (*p).sGraph.pRow = pNew
    }
    (*p).sGraph.pLast = pNew;
}
/*
** Free and reset the EXPLAIN QUERY PLAN data that has been collected
** in p->sGraph.
*/
unsafe extern "C" fn eqp_reset(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    pRow = (*p).sGraph.pRow;
    while !pRow.is_null() {
        pNext = (*pRow).pNext;
        sqlite3_free(pRow as *mut libc::c_void);
        pRow = pNext
    }
    memset(
        &mut (*p).sGraph as *mut EQPGraph as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<EQPGraph>() as libc::c_ulong,
    );
}
/* Return the next EXPLAIN QUERY PLAN line with iEqpId that occurs after
** pOld, or return the first such line if pOld is NULL
*/
unsafe extern "C" fn eqp_next_row(
    mut p: *mut ShellState,
    mut iEqpId: libc::c_int,
    mut pOld: *mut EQPGraphRow,
) -> *mut EQPGraphRow {
    let mut pRow: *mut EQPGraphRow = if !pOld.is_null() {
        (*pOld).pNext
    } else {
        (*p).sGraph.pRow
    };
    while !pRow.is_null() && (*pRow).iParentId != iEqpId {
        pRow = (*pRow).pNext
    }
    return pRow;
}
/* Render a single level of the graph that has iEqpId as its parent.  Called
** recursively to render sublevels.
*/
unsafe extern "C" fn eqp_render_level(mut p: *mut ShellState, mut iEqpId: libc::c_int) {
    let mut pRow: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut pNext: *mut EQPGraphRow = 0 as *mut EQPGraphRow;
    let mut n: libc::c_int = strlen30((*p).sGraph.zPrefix.as_mut_ptr());
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    pRow = eqp_next_row(p, iEqpId, 0 as *mut EQPGraphRow);
    while !pRow.is_null() {
        pNext = eqp_next_row(p, iEqpId, pRow);
        z = (*pRow).zText.as_mut_ptr();
        fprintf(
            (*p).out,
            b"%s%s%s\n\x00" as *const u8 as *const libc::c_char,
            (*p).sGraph.zPrefix.as_mut_ptr(),
            if !pNext.is_null() {
                b"|--\x00" as *const u8 as *const libc::c_char
            } else {
                b"`--\x00" as *const u8 as *const libc::c_char
            },
            z,
        );
        if n < ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int
            - 7 as libc::c_int
        {
            memcpy(
                &mut *(*p).sGraph.zPrefix.as_mut_ptr().offset(n as isize) as *mut libc::c_char
                    as *mut libc::c_void,
                if !pNext.is_null() {
                    b"|  \x00" as *const u8 as *const libc::c_char
                } else {
                    b"   \x00" as *const u8 as *const libc::c_char
                } as *const libc::c_void,
                4 as libc::c_int as libc::c_ulong,
            );
            eqp_render_level(p, (*pRow).iEqpId);
            (*p).sGraph.zPrefix[n as usize] = 0 as libc::c_int as libc::c_char
        }
        pRow = pNext
    }
}
/*
** Display and reset the EXPLAIN QUERY PLAN data
*/
unsafe extern "C" fn eqp_render(mut p: *mut ShellState) {
    let mut pRow: *mut EQPGraphRow = (*p).sGraph.pRow;
    if !pRow.is_null() {
        if *(*pRow).zText.as_mut_ptr().offset(0 as libc::c_int as isize) as libc::c_int
            == '-' as i32
        {
            if (*pRow).pNext.is_null() {
                eqp_reset(p);
                return;
            } else {
                fprintf(
                    (*p).out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    (*pRow).zText.as_mut_ptr().offset(3 as libc::c_int as isize),
                );
                (*p).sGraph.pRow = (*pRow).pNext;
                sqlite3_free(pRow as *mut libc::c_void);
            }
        } else {
            fprintf(
                (*p).out,
                b"QUERY PLAN\n\x00" as *const u8 as *const libc::c_char,
            );
        }
        (*p).sGraph.zPrefix[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        eqp_render_level(p, 0 as libc::c_int);
        eqp_reset(p);
    };
}
/*
** Progress handler callback.
*/
unsafe extern "C" fn progress_handler(mut pClientData: *mut libc::c_void) -> libc::c_int {
    let mut p: *mut ShellState = pClientData as *mut ShellState;
    (*p).nProgress = (*p).nProgress.wrapping_add(1);
    if (*p).nProgress >= (*p).mxProgress && (*p).mxProgress > 0 as libc::c_int as libc::c_uint {
        fprintf(
            (*p).out,
            b"Progress limit reached (%u)\n\x00" as *const u8 as *const libc::c_char,
            (*p).nProgress,
        );
        if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
            (*p).nProgress = 0 as libc::c_int as libc::c_uint
        }
        if (*p).flgProgress & 0x4 as libc::c_int as libc::c_uint != 0 {
            (*p).mxProgress = 0 as libc::c_int as libc::c_uint
        }
        return 1 as libc::c_int;
    } else {
        if (*p).flgProgress & 0x1 as libc::c_int as libc::c_uint == 0 as libc::c_int as libc::c_uint
        {
            fprintf(
                (*p).out,
                b"Progress %u\n\x00" as *const u8 as *const libc::c_char,
                (*p).nProgress,
            );
        }
        return 0 as libc::c_int;
    };
}
/* SQLITE_OMIT_PROGRESS_CALLBACK */
/*
** Print N dashes
*/
unsafe extern "C" fn print_dashes(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 51] = *::std::mem::transmute::<&[u8; 51], &[libc::c_char; 51]>(
        b"--------------------------------------------------\x00",
    );
    let nDash: libc::c_int = (::std::mem::size_of::<[libc::c_char; 51]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as libc::c_int;
    while N > nDash {
        fputs(zDash.as_ptr(), out);
        N -= nDash
    }
    fprintf(
        out,
        b"%.*s\x00" as *const u8 as *const libc::c_char,
        N,
        zDash.as_ptr(),
    );
}
/*
** Print a markdown or table-style row separator using ascii-art
*/
unsafe extern "C" fn print_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fputs(zSep, (*p).out);
        print_dashes(
            (*p).out,
            *(*p).actualWidth.offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fputs(zSep, (*p).out);
            print_dashes(
                (*p).out,
                *(*p).actualWidth.offset(i as isize) + 2 as libc::c_int,
            );
            i += 1
        }
        fputs(zSep, (*p).out);
    }
    fputs(b"\n\x00" as *const u8 as *const libc::c_char, (*p).out);
}
/*
** This is the callback routine that the shell
** invokes for each row of a query result.
*/
unsafe extern "C" fn shell_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
    mut aiType: *mut libc::c_int,
) -> libc::c_int
/* Column types.  Might be NULL */ {
    let mut current_block: u64;
    let mut i: libc::c_int = 0;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    if azArg.is_null() {
        return 0 as libc::c_int;
    } else {
        match (*p).cMode {
            0 => {
                let mut w: libc::c_int = 5 as libc::c_int;
                if !azArg.is_null() {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        let mut len: libc::c_int =
                            strlen30(if !(*azCol.offset(i as isize)).is_null() {
                                *azCol.offset(i as isize) as *const libc::c_char
                            } else {
                                b"\x00" as *const u8 as *const libc::c_char
                            });
                        if len > w {
                            w = len
                        }
                        i += 1
                    }
                    let fresh41 = (*p).cnt;
                    (*p).cnt = (*p).cnt + 1;
                    if fresh41 > 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            (*p).rowSeparator.as_mut_ptr(),
                        );
                    }
                    i = 0 as libc::c_int;
                    while i < nArg {
                        fprintf(
                            (*p).out,
                            b"%*s = %s%s\x00" as *const u8 as *const libc::c_char,
                            w,
                            *azCol.offset(i as isize),
                            if !(*azArg.offset(i as isize)).is_null() {
                                *azArg.offset(i as isize)
                            } else {
                                (*p).nullValue.as_mut_ptr()
                            },
                            (*p).rowSeparator.as_mut_ptr(),
                        );
                        i += 1
                    }
                }
            }
            9 => {
                static mut aExplainWidth: [libc::c_int; 8] = [
                    4 as libc::c_int,
                    13 as libc::c_int,
                    4 as libc::c_int,
                    4 as libc::c_int,
                    4 as libc::c_int,
                    13 as libc::c_int,
                    2 as libc::c_int,
                    13 as libc::c_int,
                ];
                if nArg
                    > (::std::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        as libc::c_int
                {
                    nArg = (::std::mem::size_of::<[libc::c_int; 8]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                        as libc::c_int
                }
                let fresh42 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh42 == 0 as libc::c_int {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        let mut w_0: libc::c_int = aExplainWidth[i as usize];
                        utf8_width_print((*p).out, w_0, *azCol.offset(i as isize));
                        fputs(
                            if i == nArg - 1 as libc::c_int {
                                b"\n\x00" as *const u8 as *const libc::c_char
                            } else {
                                b"  \x00" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1
                    }
                    i = 0 as libc::c_int;
                    while i < nArg {
                        let mut w_1: libc::c_int = aExplainWidth[i as usize];
                        print_dashes((*p).out, w_1);
                        fputs(
                            if i == nArg - 1 as libc::c_int {
                                b"\n\x00" as *const u8 as *const libc::c_char
                            } else {
                                b"  \x00" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1
                    }
                }
                if !azArg.is_null() {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        let mut w_2: libc::c_int = aExplainWidth[i as usize];
                        if i == nArg - 1 as libc::c_int {
                            w_2 = 0 as libc::c_int
                        }
                        if !(*azArg.offset(i as isize)).is_null()
                            && strlenChar(*azArg.offset(i as isize)) > w_2
                        {
                            w_2 = strlenChar(*azArg.offset(i as isize))
                        }
                        if i == 1 as libc::c_int
                            && !(*p).aiIndent.is_null()
                            && !(*p).pStmt.is_null()
                        {
                            if (*p).iIndent < (*p).nIndent {
                                fprintf(
                                    (*p).out,
                                    b"%*.s\x00" as *const u8 as *const libc::c_char,
                                    *(*p).aiIndent.offset((*p).iIndent as isize),
                                    b"\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                            (*p).iIndent += 1
                        }
                        utf8_width_print(
                            (*p).out,
                            w_2,
                            if !(*azArg.offset(i as isize)).is_null() {
                                *azArg.offset(i as isize)
                            } else {
                                (*p).nullValue.as_mut_ptr()
                            },
                        );
                        fputs(
                            if i == nArg - 1 as libc::c_int {
                                b"\n\x00" as *const u8 as *const libc::c_char
                            } else {
                                b"  \x00" as *const u8 as *const libc::c_char
                            },
                            (*p).out,
                        );
                        i += 1
                    }
                }
            }
            3 => {
                /* .schema and .fullschema output */
                printSchemaLine(
                    (*p).out,
                    *azArg.offset(0 as libc::c_int as isize),
                    b";\n\x00" as *const u8 as *const libc::c_char,
                );
            }
            11 => {
                /* .schema and .fullschema with --indent */
                let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut j: libc::c_int = 0;
                let mut nParen: libc::c_int = 0 as libc::c_int;
                let mut cEnd: libc::c_char = 0 as libc::c_int as libc::c_char;
                let mut c: libc::c_char = 0;
                let mut nLine: libc::c_int = 0 as libc::c_int;
                if !(*azArg.offset(0 as libc::c_int as isize)).is_null() {
                    if sqlite3_strlike(
                        b"CREATE VIEW%\x00" as *const u8 as *const libc::c_char,
                        *azArg.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_uint,
                    ) == 0 as libc::c_int
                        || sqlite3_strlike(
                            b"CREATE TRIG%\x00" as *const u8 as *const libc::c_char,
                            *azArg.offset(0 as libc::c_int as isize),
                            0 as libc::c_int as libc::c_uint,
                        ) == 0 as libc::c_int
                    {
                        fprintf(
                            (*p).out,
                            b"%s;\n\x00" as *const u8 as *const libc::c_char,
                            *azArg.offset(0 as libc::c_int as isize),
                        );
                    } else {
                        z = sqlite3_mprintf(
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            *azArg.offset(0 as libc::c_int as isize),
                        );
                        j = 0 as libc::c_int;
                        i = 0 as libc::c_int;
                        while *(*__ctype_b_loc())
                            .offset(*z.offset(i as isize) as libc::c_uchar as libc::c_int as isize)
                            as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                        {
                            i += 1
                        }
                        loop {
                            c = *z.offset(i as isize);
                            if !(c as libc::c_int != 0 as libc::c_int) {
                                break;
                            }
                            if *(*__ctype_b_loc())
                                .offset(c as libc::c_uchar as libc::c_int as isize)
                                as libc::c_int
                                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                != 0
                            {
                                if *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                    == '\r' as i32
                                {
                                    *z.offset((j - 1 as libc::c_int) as isize) =
                                        '\n' as i32 as libc::c_char
                                }
                                if *(*__ctype_b_loc()).offset(
                                    *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                        as libc::c_int as isize,
                                ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                                    || *z.offset((j - 1 as libc::c_int) as isize) as libc::c_int
                                        == '(' as i32
                                {
                                    current_block = 5159818223158340697;
                                } else {
                                    current_block = 1134115459065347084;
                                }
                            } else if (c as libc::c_int == '(' as i32
                                || c as libc::c_int == ')' as i32)
                                && j > 0 as libc::c_int
                                && *(*__ctype_b_loc()).offset(
                                    *z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                        as libc::c_int as isize,
                                ) as libc::c_int
                                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                    != 0
                            {
                                j -= 1;
                                current_block = 1134115459065347084;
                            } else {
                                current_block = 1134115459065347084;
                            }
                            match current_block {
                                1134115459065347084 => {
                                    let fresh43 = j;
                                    j = j + 1;
                                    *z.offset(fresh43 as isize) = c
                                }
                                _ => {}
                            }
                            i += 1
                        }
                        while j > 0 as libc::c_int
                            && *(*__ctype_b_loc())
                                .offset(*z.offset((j - 1 as libc::c_int) as isize) as libc::c_uchar
                                    as libc::c_int as isize)
                                as libc::c_int
                                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                != 0
                        {
                            j -= 1
                        }
                        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char;
                        if strlen30(z) >= 79 as libc::c_int {
                            j = 0 as libc::c_int;
                            i = j;
                            loop {
                                c = *z.offset(i as isize);
                                if !(c as libc::c_int != 0 as libc::c_int) {
                                    break;
                                }
                                /* Copy from z[i] back to z[j] */
                                if c as libc::c_int == cEnd as libc::c_int {
                                    cEnd = 0 as libc::c_int as libc::c_char
                                } else if c as libc::c_int == '\"' as i32
                                    || c as libc::c_int == '\'' as i32
                                    || c as libc::c_int == '`' as i32
                                {
                                    cEnd = c
                                } else if c as libc::c_int == '[' as i32 {
                                    cEnd = ']' as i32 as libc::c_char
                                } else if c as libc::c_int == '-' as i32
                                    && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int
                                        == '-' as i32
                                {
                                    cEnd = '\n' as i32 as libc::c_char
                                } else if c as libc::c_int == '(' as i32 {
                                    nParen += 1
                                } else if c as libc::c_int == ')' as i32 {
                                    nParen -= 1;
                                    if nLine > 0 as libc::c_int
                                        && nParen == 0 as libc::c_int
                                        && j > 0 as libc::c_int
                                    {
                                        printSchemaLineN(
                                            (*p).out,
                                            z,
                                            j,
                                            b"\n\x00" as *const u8 as *const libc::c_char,
                                        );
                                        j = 0 as libc::c_int
                                    }
                                }
                                let fresh44 = j;
                                j = j + 1;
                                *z.offset(fresh44 as isize) = c;
                                if nParen == 1 as libc::c_int
                                    && cEnd as libc::c_int == 0 as libc::c_int
                                    && (c as libc::c_int == '(' as i32
                                        || c as libc::c_int == '\n' as i32
                                        || c as libc::c_int == ',' as i32
                                            && wsToEol(
                                                z.offset(i as isize)
                                                    .offset(1 as libc::c_int as isize),
                                            ) == 0)
                                {
                                    if c as libc::c_int == '\n' as i32 {
                                        j -= 1
                                    }
                                    printSchemaLineN(
                                        (*p).out,
                                        z,
                                        j,
                                        b"\n  \x00" as *const u8 as *const libc::c_char,
                                    );
                                    j = 0 as libc::c_int;
                                    nLine += 1;
                                    while *(*__ctype_b_loc()).offset(
                                        *z.offset((i + 1 as libc::c_int) as isize) as libc::c_uchar
                                            as libc::c_int
                                            as isize,
                                    ) as libc::c_int
                                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                                        != 0
                                    {
                                        i += 1
                                    }
                                }
                                i += 1
                            }
                            *z.offset(j as isize) = 0 as libc::c_int as libc::c_char
                        }
                        printSchemaLine(
                            (*p).out,
                            z,
                            b";\n\x00" as *const u8 as *const libc::c_char,
                        );
                        sqlite3_free(z as *mut libc::c_void);
                    }
                }
            }
            2 => {
                let fresh45 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh45 == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        fprintf(
                            (*p).out,
                            b"%s%s\x00" as *const u8 as *const libc::c_char,
                            *azCol.offset(i as isize),
                            if i == nArg - 1 as libc::c_int {
                                (*p).rowSeparator.as_mut_ptr()
                            } else {
                                (*p).colSeparator.as_mut_ptr()
                            },
                        );
                        i += 1
                    }
                }
                if !azArg.is_null() {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        let mut z_0: *mut libc::c_char = *azArg.offset(i as isize);
                        if z_0.is_null() {
                            z_0 = (*p).nullValue.as_mut_ptr()
                        }
                        fprintf((*p).out, b"%s\x00" as *const u8 as *const libc::c_char, z_0);
                        if i < nArg - 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).colSeparator.as_mut_ptr(),
                            );
                        } else {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).rowSeparator.as_mut_ptr(),
                            );
                        }
                        i += 1
                    }
                }
            }
            4 => {
                let fresh46 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh46 == 0 as libc::c_int && (*p).showHeader != 0 {
                    fprintf((*p).out, b"<TR>\x00" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int;
                    while i < nArg {
                        fprintf((*p).out, b"<TH>\x00" as *const u8 as *const libc::c_char);
                        output_html_string((*p).out, *azCol.offset(i as isize));
                        fprintf((*p).out, b"</TH>\n\x00" as *const u8 as *const libc::c_char);
                        i += 1
                    }
                    fprintf((*p).out, b"</TR>\n\x00" as *const u8 as *const libc::c_char);
                }
                if !azArg.is_null() {
                    fprintf((*p).out, b"<TR>\x00" as *const u8 as *const libc::c_char);
                    i = 0 as libc::c_int;
                    while i < nArg {
                        fprintf((*p).out, b"<TD>\x00" as *const u8 as *const libc::c_char);
                        output_html_string(
                            (*p).out,
                            if !(*azArg.offset(i as isize)).is_null() {
                                *azArg.offset(i as isize)
                            } else {
                                (*p).nullValue.as_mut_ptr()
                            },
                        );
                        fprintf((*p).out, b"</TD>\n\x00" as *const u8 as *const libc::c_char);
                        i += 1
                    }
                    fprintf((*p).out, b"</TR>\n\x00" as *const u8 as *const libc::c_char);
                }
            }
            7 => {
                let fresh47 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh47 == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        output_c_string(
                            (*p).out,
                            if !(*azCol.offset(i as isize)).is_null() {
                                *azCol.offset(i as isize) as *const libc::c_char
                            } else {
                                b"\x00" as *const u8 as *const libc::c_char
                            },
                        );
                        if i < nArg - 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).colSeparator.as_mut_ptr(),
                            );
                        }
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
                if !azArg.is_null() {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        output_c_string(
                            (*p).out,
                            if !(*azArg.offset(i as isize)).is_null() {
                                *azArg.offset(i as isize)
                            } else {
                                (*p).nullValue.as_mut_ptr()
                            },
                        );
                        if i < nArg - 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).colSeparator.as_mut_ptr(),
                            );
                        }
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
            }
            8 => {
                let fresh48 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh48 == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        output_csv(
                            p,
                            if !(*azCol.offset(i as isize)).is_null() {
                                *azCol.offset(i as isize) as *const libc::c_char
                            } else {
                                b"\x00" as *const u8 as *const libc::c_char
                            },
                            (i < nArg - 1 as libc::c_int) as libc::c_int,
                        );
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
                if nArg > 0 as libc::c_int {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        output_csv(
                            p,
                            *azArg.offset(i as isize),
                            (i < nArg - 1 as libc::c_int) as libc::c_int,
                        );
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
            }
            5 => {
                if !azArg.is_null() {
                    fprintf(
                        (*p).out,
                        b"INSERT INTO %s\x00" as *const u8 as *const libc::c_char,
                        (*p).zDestTable,
                    );
                    if (*p).showHeader != 0 {
                        fprintf((*p).out, b"(\x00" as *const u8 as *const libc::c_char);
                        i = 0 as libc::c_int;
                        while i < nArg {
                            if i > 0 as libc::c_int {
                                fprintf((*p).out, b",\x00" as *const u8 as *const libc::c_char);
                            }
                            if quoteChar(*azCol.offset(i as isize)) != 0 {
                                let mut z_1: *mut libc::c_char = sqlite3_mprintf(
                                    b"\"%w\"\x00" as *const u8 as *const libc::c_char,
                                    *azCol.offset(i as isize),
                                );
                                fprintf(
                                    (*p).out,
                                    b"%s\x00" as *const u8 as *const libc::c_char,
                                    z_1,
                                );
                                sqlite3_free(z_1 as *mut libc::c_void);
                            } else {
                                fprintf(
                                    (*p).out,
                                    b"%s\x00" as *const u8 as *const libc::c_char,
                                    *azCol.offset(i as isize),
                                );
                            }
                            i += 1
                        }
                        fprintf((*p).out, b")\x00" as *const u8 as *const libc::c_char);
                    }
                    (*p).cnt += 1;
                    i = 0 as libc::c_int;
                    while i < nArg {
                        fprintf(
                            (*p).out,
                            if i > 0 as libc::c_int {
                                b",\x00" as *const u8 as *const libc::c_char
                            } else {
                                b" VALUES(\x00" as *const u8 as *const libc::c_char
                            },
                        );
                        if (*azArg.offset(i as isize)).is_null()
                            || !aiType.is_null() && *aiType.offset(i as isize) == 5 as libc::c_int
                        {
                            fprintf((*p).out, b"NULL\x00" as *const u8 as *const libc::c_char);
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 3 as libc::c_int
                        {
                            if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                                != 0 as libc::c_int as libc::c_uint
                            {
                                output_quoted_string((*p).out, *azArg.offset(i as isize));
                            } else {
                                output_quoted_escaped_string((*p).out, *azArg.offset(i as isize));
                            }
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 1 as libc::c_int
                        {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                *azArg.offset(i as isize),
                            );
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 2 as libc::c_int
                        {
                            let mut z_2: [libc::c_char; 50] = [0; 50];
                            let mut r: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                            let mut ur: sqlite3_uint64 = 0;
                            memcpy(
                                &mut ur as *mut sqlite3_uint64 as *mut libc::c_void,
                                &mut r as *mut libc::c_double as *const libc::c_void,
                                ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                            );
                            if ur == 0x7ff0000000000000 as libc::c_longlong as libc::c_ulonglong {
                                fprintf((*p).out, b"1e999\x00" as *const u8 as *const libc::c_char);
                            } else if ur == 0xfff0000000000000 as libc::c_ulonglong {
                                fprintf(
                                    (*p).out,
                                    b"-1e999\x00" as *const u8 as *const libc::c_char,
                                );
                            } else {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_2.as_mut_ptr(),
                                    b"%!.20g\x00" as *const u8 as *const libc::c_char,
                                    r,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%s\x00" as *const u8 as *const libc::c_char,
                                    z_2.as_mut_ptr(),
                                );
                            }
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 4 as libc::c_int
                            && !(*p).pStmt.is_null()
                        {
                            let mut pBlob: *const libc::c_void = sqlite3_column_blob((*p).pStmt, i);
                            let mut nBlob: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                            output_hex_blob((*p).out, pBlob, nBlob);
                        } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int) != 0 {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                *azArg.offset(i as isize),
                            );
                        } else if (*p).shellFlgs & 0x10 as libc::c_int as libc::c_uint
                            != 0 as libc::c_int as libc::c_uint
                        {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        } else {
                            output_quoted_escaped_string((*p).out, *azArg.offset(i as isize));
                        }
                        i += 1
                    }
                    fprintf((*p).out, b");\n\x00" as *const u8 as *const libc::c_char);
                }
            }
            13 => {
                if !azArg.is_null() {
                    if (*p).cnt == 0 as libc::c_int {
                        fputs(b"[{\x00" as *const u8 as *const libc::c_char, (*p).out);
                    } else {
                        fputs(b",\n{\x00" as *const u8 as *const libc::c_char, (*p).out);
                    }
                    (*p).cnt += 1;
                    i = 0 as libc::c_int;
                    while i < nArg {
                        output_json_string(
                            (*p).out,
                            *azCol.offset(i as isize),
                            -(1 as libc::c_int),
                        );
                        putc(':' as i32, (*p).out);
                        if (*azArg.offset(i as isize)).is_null()
                            || !aiType.is_null() && *aiType.offset(i as isize) == 5 as libc::c_int
                        {
                            fputs(b"null\x00" as *const u8 as *const libc::c_char, (*p).out);
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 2 as libc::c_int
                        {
                            let mut z_3: [libc::c_char; 50] = [0; 50];
                            let mut r_0: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                            let mut ur_0: sqlite3_uint64 = 0;
                            memcpy(
                                &mut ur_0 as *mut sqlite3_uint64 as *mut libc::c_void,
                                &mut r_0 as *mut libc::c_double as *const libc::c_void,
                                ::std::mem::size_of::<libc::c_double>() as libc::c_ulong,
                            );
                            if ur_0 == 0x7ff0000000000000 as libc::c_longlong as libc::c_ulonglong {
                                fprintf((*p).out, b"1e999\x00" as *const u8 as *const libc::c_char);
                            } else if ur_0 == 0xfff0000000000000 as libc::c_ulonglong {
                                fprintf(
                                    (*p).out,
                                    b"-1e999\x00" as *const u8 as *const libc::c_char,
                                );
                            } else {
                                sqlite3_snprintf(
                                    50 as libc::c_int,
                                    z_3.as_mut_ptr(),
                                    b"%!.20g\x00" as *const u8 as *const libc::c_char,
                                    r_0,
                                );
                                fprintf(
                                    (*p).out,
                                    b"%s\x00" as *const u8 as *const libc::c_char,
                                    z_3.as_mut_ptr(),
                                );
                            }
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 4 as libc::c_int
                            && !(*p).pStmt.is_null()
                        {
                            let mut pBlob_0: *const libc::c_void =
                                sqlite3_column_blob((*p).pStmt, i);
                            let mut nBlob_0: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                            output_json_string((*p).out, pBlob_0 as *const libc::c_char, nBlob_0);
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 3 as libc::c_int
                        {
                            output_json_string(
                                (*p).out,
                                *azArg.offset(i as isize),
                                -(1 as libc::c_int),
                            );
                        } else {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                *azArg.offset(i as isize),
                            );
                        }
                        if i < nArg - 1 as libc::c_int {
                            putc(',' as i32, (*p).out);
                        }
                        i += 1
                    }
                    putc('}' as i32, (*p).out);
                }
            }
            6 => {
                if !azArg.is_null() {
                    if (*p).cnt == 0 as libc::c_int && (*p).showHeader != 0 {
                        i = 0 as libc::c_int;
                        while i < nArg {
                            if i > 0 as libc::c_int {
                                fputs((*p).colSeparator.as_mut_ptr(), (*p).out);
                            }
                            output_quoted_string((*p).out, *azCol.offset(i as isize));
                            i += 1
                        }
                        fputs((*p).rowSeparator.as_mut_ptr(), (*p).out);
                    }
                    (*p).cnt += 1;
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fputs((*p).colSeparator.as_mut_ptr(), (*p).out);
                        }
                        if (*azArg.offset(i as isize)).is_null()
                            || !aiType.is_null() && *aiType.offset(i as isize) == 5 as libc::c_int
                        {
                            fprintf((*p).out, b"NULL\x00" as *const u8 as *const libc::c_char);
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 3 as libc::c_int
                        {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 1 as libc::c_int
                        {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                *azArg.offset(i as isize),
                            );
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 2 as libc::c_int
                        {
                            let mut z_4: [libc::c_char; 50] = [0; 50];
                            let mut r_1: libc::c_double = sqlite3_column_double((*p).pStmt, i);
                            sqlite3_snprintf(
                                50 as libc::c_int,
                                z_4.as_mut_ptr(),
                                b"%!.20g\x00" as *const u8 as *const libc::c_char,
                                r_1,
                            );
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                z_4.as_mut_ptr(),
                            );
                        } else if !aiType.is_null()
                            && *aiType.offset(i as isize) == 4 as libc::c_int
                            && !(*p).pStmt.is_null()
                        {
                            let mut pBlob_1: *const libc::c_void =
                                sqlite3_column_blob((*p).pStmt, i);
                            let mut nBlob_1: libc::c_int = sqlite3_column_bytes((*p).pStmt, i);
                            output_hex_blob((*p).out, pBlob_1, nBlob_1);
                        } else if isNumber(*azArg.offset(i as isize), 0 as *mut libc::c_int) != 0 {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                *azArg.offset(i as isize),
                            );
                        } else {
                            output_quoted_string((*p).out, *azArg.offset(i as isize));
                        }
                        i += 1
                    }
                    fputs((*p).rowSeparator.as_mut_ptr(), (*p).out);
                }
            }
            10 => {
                let fresh49 = (*p).cnt;
                (*p).cnt = (*p).cnt + 1;
                if fresh49 == 0 as libc::c_int && (*p).showHeader != 0 {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).colSeparator.as_mut_ptr(),
                            );
                        }
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            if !(*azCol.offset(i as isize)).is_null() {
                                *azCol.offset(i as isize) as *const libc::c_char
                            } else {
                                b"\x00" as *const u8 as *const libc::c_char
                            },
                        );
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
                if !azArg.is_null() {
                    i = 0 as libc::c_int;
                    while i < nArg {
                        if i > 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                (*p).colSeparator.as_mut_ptr(),
                            );
                        }
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            if !(*azArg.offset(i as isize)).is_null() {
                                *azArg.offset(i as isize)
                            } else {
                                (*p).nullValue.as_mut_ptr()
                            },
                        );
                        i += 1
                    }
                    fprintf(
                        (*p).out,
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        (*p).rowSeparator.as_mut_ptr(),
                    );
                }
            }
            12 => {
                eqp_append(
                    p,
                    atoi(*azArg.offset(0 as libc::c_int as isize)),
                    atoi(*azArg.offset(1 as libc::c_int as isize)),
                    *azArg.offset(3 as libc::c_int as isize),
                );
            }
            _ => {}
        }
        return 0 as libc::c_int;
    };
}
/*
** This is the callback routine that the SQLite library
** invokes for each row of a query result.
*/
unsafe extern "C" fn callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut azCol: *mut *mut libc::c_char,
) -> libc::c_int {
    /* since we don't have type info, call the shell_callback with a NULL value */
    return shell_callback(pArg, nArg, azArg, azCol, 0 as *mut libc::c_int);
}
/*
** This is the callback routine from sqlite3_exec() that appends all
** output onto the end of a ShellText object.
*/
unsafe extern "C" fn captureOutputCallback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut _az: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut p: *mut ShellText = pArg as *mut ShellText;
    let mut i: libc::c_int = 0;
    if azArg.is_null() {
        return 0 as libc::c_int;
    } else {
        if (*p).n != 0 {
            appendText(
                p,
                b"|\x00" as *const u8 as *const libc::c_char,
                0 as libc::c_int as libc::c_char,
            );
        }
        i = 0 as libc::c_int;
        while i < nArg {
            if i != 0 {
                appendText(
                    p,
                    b",\x00" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
            }
            if !(*azArg.offset(i as isize)).is_null() {
                appendText(
                    p,
                    *azArg.offset(i as isize),
                    0 as libc::c_int as libc::c_char,
                );
            }
            i += 1
        }
        return 0 as libc::c_int;
    };
}
/*
** Generate an appropriate SELFTEST table in the main database.
*/
unsafe extern "C" fn createSelftestTable(mut p: *mut ShellState) {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    sqlite3_exec((*p).db,
                 b"SAVEPOINT selftest_init;\nCREATE TABLE IF NOT EXISTS selftest(\n  tno INTEGER PRIMARY KEY,\n  op TEXT,\n  cmd TEXT,\n  ans TEXT\n);CREATE TEMP TABLE [_shell$self](op,cmd,ans);\nINSERT INTO [_shell$self](rowid,op,cmd)\n  VALUES(coalesce((SELECT (max(tno)+100)/10 FROM selftest),10),\n         \'memo\',\'Tests generated by --init\');\nINSERT INTO [_shell$self]\n  SELECT \'run\',\n    \'SELECT hex(sha3_query(\'\'SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2\'\',224))\',\n    hex(sha3_query(\'SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY 2\',224));\nINSERT INTO [_shell$self]\n  SELECT \'run\',    \'SELECT hex(sha3_query(\'\'SELECT * FROM \"\' ||        printf(\'%w\',name) || \'\" NOT INDEXED\'\',224))\',\n    hex(sha3_query(printf(\'SELECT * FROM \"%w\" NOT INDEXED\',name),224))\n  FROM (\n    SELECT name FROM sqlite_schema\n     WHERE type=\'table\'\n       AND name<>\'selftest\'\n       AND coalesce(rootpage,0)>0\n  )\n ORDER BY name;\nINSERT INTO [_shell$self]\n  VALUES(\'run\',\'PRAGMA integrity_check\',\'ok\');\nINSERT INTO selftest(tno,op,cmd,ans)  SELECT rowid*10,op,cmd,ans FROM [_shell$self];\nDROP TABLE [_shell$self];\x00"
                     as *const u8 as *const libc::c_char, None,
                 0 as *mut libc::c_void, &mut zErrMsg);
    if !zErrMsg.is_null() {
        fprintf(
            stderr,
            b"SELFTEST initialization failure: %s\n\x00" as *const u8 as *const libc::c_char,
            zErrMsg,
        );
        sqlite3_free(zErrMsg as *mut libc::c_void);
    }
    sqlite3_exec(
        (*p).db,
        b"RELEASE selftest_init\x00" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
/*
** Set the destination table field of the ShellState structure to
** the name of the table given.  Escape any quote characters in the
** table name.
*/
unsafe extern "C" fn set_table_name(mut p: *mut ShellState, mut zName: *const libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut cQuote: libc::c_char = 0;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if !(*p).zDestTable.is_null() {
        free((*p).zDestTable as *mut libc::c_void);
        (*p).zDestTable = 0 as *mut libc::c_char
    }
    if zName.is_null() {
        return;
    } else {
        cQuote = quoteChar(zName);
        n = strlen30(zName);
        if cQuote != 0 {
            n += n + 2 as libc::c_int
        }
        (*p).zDestTable = malloc((n + 1 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
        z = (*p).zDestTable;
        if z.is_null() {
            shell_out_of_memory();
        }
        n = 0 as libc::c_int;
        if cQuote != 0 {
            let fresh50 = n;
            n = n + 1;
            *z.offset(fresh50 as isize) = cQuote
        }
        i = 0 as libc::c_int;
        while *zName.offset(i as isize) != 0 {
            let fresh51 = n;
            n = n + 1;
            *z.offset(fresh51 as isize) = *zName.offset(i as isize);
            if *zName.offset(i as isize) as libc::c_int == cQuote as libc::c_int {
                let fresh52 = n;
                n = n + 1;
                *z.offset(fresh52 as isize) = cQuote
            }
            i += 1
        }
        if cQuote != 0 {
            let fresh53 = n;
            n = n + 1;
            *z.offset(fresh53 as isize) = cQuote
        }
        *z.offset(n as isize) = 0 as libc::c_int as libc::c_char;
        return;
    };
}
/*
** Execute a query statement that will generate SQL output.  Print
** the result columns, comma-separated, on a line and then add a
** semicolon terminator to the end of that line.
**
** If the number of columns is 1 and that column contains text "--"
** then write the semicolon on a separate line.  That way, if a
** "--" comment occurs at the end of the statement, the comment
** won't consume the semicolon terminator.
*/
unsafe extern "C" fn run_table_dump_query(
    mut p: *mut ShellState,
    mut zSelect: *const libc::c_char,
) -> libc::c_int
/* SELECT statement to extract content */ {
    let mut pSelect: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    let mut nResult: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSelect,
        -(1 as libc::c_int),
        &mut pSelect,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 as libc::c_int || pSelect.is_null() {
        fprintf(
            (*p).out,
            b"/**** ERROR: (%d) %s *****/\n\x00" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg((*p).db),
        );
        if rc & 0xff as libc::c_int != 11 as libc::c_int {
            (*p).nErr += 1
        }
        return rc;
    } else {
        rc = sqlite3_step(pSelect);
        nResult = sqlite3_column_count(pSelect);
        while rc == 100 as libc::c_int {
            z = sqlite3_column_text(pSelect, 0 as libc::c_int) as *const libc::c_char;
            fprintf((*p).out, b"%s\x00" as *const u8 as *const libc::c_char, z);
            i = 1 as libc::c_int;
            while i < nResult {
                fprintf(
                    (*p).out,
                    b",%s\x00" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSelect, i),
                );
                i += 1
            }
            if z.is_null() {
                z = b"\x00" as *const u8 as *const libc::c_char
            }
            while *z.offset(0 as libc::c_int as isize) as libc::c_int != 0
                && (*z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32
                    || *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32)
            {
                z = z.offset(1)
            }
            if *z.offset(0 as libc::c_int as isize) != 0 {
                fprintf((*p).out, b"\n;\n\x00" as *const u8 as *const libc::c_char);
            } else {
                fprintf((*p).out, b";\n\x00" as *const u8 as *const libc::c_char);
            }
            rc = sqlite3_step(pSelect)
        }
        rc = sqlite3_finalize(pSelect);
        if rc != 0 as libc::c_int {
            fprintf(
                (*p).out,
                b"/**** ERROR: (%d) %s *****/\n\x00" as *const u8 as *const libc::c_char,
                rc,
                sqlite3_errmsg((*p).db),
            );
            if rc & 0xff as libc::c_int != 11 as libc::c_int {
                (*p).nErr += 1
            }
        }
        return rc;
    };
}
/*
** Allocate space and save off current error string.
*/
unsafe extern "C" fn save_err_msg(mut db: *mut sqlite3) -> *mut libc::c_char
/* Database to query */ {
    let mut nErrMsg: libc::c_int = 1 as libc::c_int + strlen30(sqlite3_errmsg(db));
    let mut zErrMsg: *mut libc::c_char =
        sqlite3_malloc64(nErrMsg as sqlite3_uint64) as *mut libc::c_char;
    if !zErrMsg.is_null() {
        memcpy(
            zErrMsg as *mut libc::c_void,
            sqlite3_errmsg(db) as *const libc::c_void,
            nErrMsg as libc::c_ulong,
        );
    }
    return zErrMsg;
}
/*
** Attempt to display I/O stats on Linux using /proc/PID/io
*/
unsafe extern "C" fn displayLinuxIoStats(mut out: *mut FILE) {
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut z: [libc::c_char; 200] = [0; 200];
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
        z.as_mut_ptr(),
        b"/proc/%d/io\x00" as *const u8 as *const libc::c_char,
        getpid(),
    );
    in_0 = fopen(
        z.as_mut_ptr(),
        b"rb\x00" as *const u8 as *const libc::c_char,
    );
    if in_0.is_null() {
        return;
    } else {
        while !fgets(
            z.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
            in_0,
        )
        .is_null()
        {
            static mut aTrans: [C2RustUnnamed_18; 7] = [
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"rchar: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Bytes received by read():\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"wchar: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Bytes sent to write():\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"syscr: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Read() system calls:\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"syscw: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Write() system calls:\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"read_bytes: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Bytes read from storage:\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"write_bytes: \x00" as *const u8 as *const libc::c_char,
                        zDesc: b"Bytes written to storage:\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_18 {
                        zPattern: b"cancelled_write_bytes: \x00" as *const u8
                            as *const libc::c_char,
                        zDesc: b"Cancelled write bytes:\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
            ];
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i
                < (::std::mem::size_of::<[C2RustUnnamed_18; 7]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<C2RustUnnamed_18>() as libc::c_ulong)
                    as libc::c_int
            {
                let mut n: libc::c_int = strlen30(aTrans[i as usize].zPattern);
                if strncmp(
                    aTrans[i as usize].zPattern,
                    z.as_mut_ptr(),
                    n as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    fprintf(
                        out,
                        b"%-36s %s\x00" as *const u8 as *const libc::c_char,
                        aTrans[i as usize].zDesc,
                        &mut *z.as_mut_ptr().offset(n as isize) as *mut libc::c_char,
                    );
                    break;
                } else {
                    i += 1
                }
            }
        }
        fclose(in_0);
        return;
    };
}
/*
** Display a single line of status using 64-bit values.
*/
unsafe extern "C" fn displayStatLine(
    mut p: *mut ShellState,
    mut zLabel: *mut libc::c_char,
    mut zFormat: *mut libc::c_char,
    mut iStatusCtrl: libc::c_int,
    mut bReset: libc::c_int,
)
/* True to reset the stats */
{
    let mut iCur: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut iHiwtr: sqlite3_int64 = -(1 as libc::c_int) as sqlite3_int64;
    let mut i: libc::c_int = 0;
    let mut nPercent: libc::c_int = 0;
    let mut zLine: [libc::c_char; 200] = [0; 200];
    sqlite3_status64(iStatusCtrl, &mut iCur, &mut iHiwtr, bReset);
    i = 0 as libc::c_int;
    nPercent = 0 as libc::c_int;
    while *zFormat.offset(i as isize) != 0 {
        if *zFormat.offset(i as isize) as libc::c_int == '%' as i32 {
            nPercent += 1
        }
        i += 1
    }
    if nPercent > 1 as libc::c_int {
        sqlite3_snprintf(
            ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iCur,
            iHiwtr,
        );
    } else {
        sqlite3_snprintf(
            ::std::mem::size_of::<[libc::c_char; 200]>() as libc::c_ulong as libc::c_int,
            zLine.as_mut_ptr(),
            zFormat,
            iHiwtr,
        );
    }
    fprintf(
        (*p).out,
        b"%-36s %s\n\x00" as *const u8 as *const libc::c_char,
        zLabel,
        zLine.as_mut_ptr(),
    );
}
/*
** Display memory stats.
*/
unsafe extern "C" fn display_stats(
    mut db: *mut sqlite3,
    mut pArg: *mut ShellState,
    mut bReset: libc::c_int,
) -> libc::c_int
/* True to reset the stats */ {
    let mut iCur: libc::c_int = 0;
    let mut iHiwtr: libc::c_int = 0;
    let mut out: *mut FILE = 0 as *mut FILE;
    if pArg.is_null() || (*pArg).out.is_null() {
        return 0 as libc::c_int;
    } else {
        out = (*pArg).out;
        if !(*pArg).pStmt.is_null() && (*pArg).statsOn == 2 as libc::c_int as libc::c_uint {
            let mut nCol: libc::c_int = 0;
            let mut i: libc::c_int = 0;
            let mut x: libc::c_int = 0;
            let mut pStmt: *mut sqlite3_stmt = (*pArg).pStmt;
            let mut z: [libc::c_char; 100] = [0; 100];
            nCol = sqlite3_column_count(pStmt);
            fprintf(
                out,
                b"%-36s %d\n\x00" as *const u8 as *const libc::c_char,
                b"Number of output columns:\x00" as *const u8 as *const libc::c_char,
                nCol,
            );
            i = 0 as libc::c_int;
            while i < nCol {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
                    z.as_mut_ptr(),
                    b"Column %d %nname:\x00" as *const u8 as *const libc::c_char,
                    i,
                    &mut x as *mut libc::c_int,
                );
                fprintf(
                    out,
                    b"%-36s %s\n\x00" as *const u8 as *const libc::c_char,
                    z.as_mut_ptr(),
                    sqlite3_column_name(pStmt, i),
                );
                sqlite3_snprintf(
                    30 as libc::c_int,
                    z.as_mut_ptr().offset(x as isize),
                    b"declared type:\x00" as *const u8 as *const libc::c_char,
                );
                fprintf(
                    out,
                    b"%-36s %s\n\x00" as *const u8 as *const libc::c_char,
                    z.as_mut_ptr(),
                    sqlite3_column_decltype(pStmt, i),
                );
                i += 1
            }
        }
        if (*pArg).statsOn == 3 as libc::c_int as libc::c_uint {
            if !(*pArg).pStmt.is_null() {
                iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"VM-steps: %d\n\x00" as *const u8 as *const libc::c_char,
                    iCur,
                );
            }
            return 0 as libc::c_int;
        } else {
            displayStatLine(
                pArg,
                b"Memory Used:\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                b"%lld (max %lld) bytes\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                0 as libc::c_int,
                bReset,
            );
            displayStatLine(
                pArg,
                b"Number of Outstanding Allocations:\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"%lld (max %lld)\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                9 as libc::c_int,
                bReset,
            );
            if (*pArg).shellFlgs & 0x1 as libc::c_int as libc::c_uint != 0 {
                displayStatLine(
                    pArg,
                    b"Number of Pcache Pages Used:\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    b"%lld (max %lld) pages\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char,
                    1 as libc::c_int,
                    bReset,
                );
            }
            displayStatLine(
                pArg,
                b"Number of Pcache Overflow Bytes:\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"%lld (max %lld) bytes\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                2 as libc::c_int,
                bReset,
            );
            displayStatLine(
                pArg,
                b"Largest Allocation:\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                b"%lld bytes\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                5 as libc::c_int,
                bReset,
            );
            displayStatLine(
                pArg,
                b"Largest Pcache Allocation:\x00" as *const u8 as *const libc::c_char
                    as *mut libc::c_char,
                b"%lld bytes\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                7 as libc::c_int,
                bReset,
            );
            if !db.is_null() {
                if (*pArg).shellFlgs & 0x2 as libc::c_int as libc::c_uint != 0 {
                    iCur = -(1 as libc::c_int);
                    iHiwtr = iCur;
                    sqlite3_db_status(db, 0 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                    fprintf(
                        (*pArg).out,
                        b"Lookaside Slots Used:                %d (max %d)\n\x00" as *const u8
                            as *const libc::c_char,
                        iCur,
                        iHiwtr,
                    );
                    sqlite3_db_status(db, 4 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                    fprintf(
                        (*pArg).out,
                        b"Successful lookaside attempts:       %d\n\x00" as *const u8
                            as *const libc::c_char,
                        iHiwtr,
                    );
                    sqlite3_db_status(db, 5 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                    fprintf(
                        (*pArg).out,
                        b"Lookaside failures due to size:      %d\n\x00" as *const u8
                            as *const libc::c_char,
                        iHiwtr,
                    );
                    sqlite3_db_status(db, 6 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                    fprintf(
                        (*pArg).out,
                        b"Lookaside failures due to OOM:       %d\n\x00" as *const u8
                            as *const libc::c_char,
                        iHiwtr,
                    );
                }
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(db, 1 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                fprintf(
                    (*pArg).out,
                    b"Pager Heap Usage:                    %d bytes\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(
                    db,
                    7 as libc::c_int,
                    &mut iCur,
                    &mut iHiwtr,
                    1 as libc::c_int,
                );
                fprintf(
                    (*pArg).out,
                    b"Page cache hits:                     %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(
                    db,
                    8 as libc::c_int,
                    &mut iCur,
                    &mut iHiwtr,
                    1 as libc::c_int,
                );
                fprintf(
                    (*pArg).out,
                    b"Page cache misses:                   %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(
                    db,
                    9 as libc::c_int,
                    &mut iCur,
                    &mut iHiwtr,
                    1 as libc::c_int,
                );
                fprintf(
                    (*pArg).out,
                    b"Page cache writes:                   %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(
                    db,
                    12 as libc::c_int,
                    &mut iCur,
                    &mut iHiwtr,
                    1 as libc::c_int,
                );
                fprintf(
                    (*pArg).out,
                    b"Page cache spills:                   %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(db, 2 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                fprintf(
                    (*pArg).out,
                    b"Schema Heap Usage:                   %d bytes\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = -(1 as libc::c_int);
                iHiwtr = iCur;
                sqlite3_db_status(db, 3 as libc::c_int, &mut iCur, &mut iHiwtr, bReset);
                fprintf(
                    (*pArg).out,
                    b"Statement Heap/Lookaside Usage:      %d bytes\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
            }
            if !(*pArg).pStmt.is_null() {
                iCur = sqlite3_stmt_status((*pArg).pStmt, 1 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Fullscan Steps:                      %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 2 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Sort Operations:                     %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 3 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Autoindex Inserts:                   %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 4 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Virtual Machine Steps:               %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 5 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Reprepare operations:                %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 6 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Number of times run:                 %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
                iCur = sqlite3_stmt_status((*pArg).pStmt, 99 as libc::c_int, bReset);
                fprintf(
                    (*pArg).out,
                    b"Memory used by prepared stmt:        %d\n\x00" as *const u8
                        as *const libc::c_char,
                    iCur,
                );
            }
            displayLinuxIoStats((*pArg).out);
            /* Do not remove this machine readable comment: extra-stats-output-here */
            return 0 as libc::c_int;
        }
    };
}
/*
** Display scan stats.
*/
unsafe extern "C" fn display_scanstats(mut _db: *mut sqlite3, mut _pArg: *mut ShellState)
/* Pointer to ShellState */
{
}
/*
** Parameter azArray points to a zero-terminated array of strings. zStr
** points to a single nul-terminated string. Return non-zero if zStr
** is equal, according to strcmp(), to any of the strings in the array.
** Otherwise, return zero.
*/
unsafe extern "C" fn str_in_array(
    mut zStr: *const libc::c_char,
    mut azArray: *mut *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0;
    i = 0 as libc::c_int;
    while !(*azArray.offset(i as isize)).is_null() {
        if 0 as libc::c_int == strcmp(zStr, *azArray.offset(i as isize)) {
            return 1 as libc::c_int;
        } else {
            i += 1
        }
    }
    return 0 as libc::c_int;
}
/*
** If compiled statement pSql appears to be an EXPLAIN statement, allocate
** and populate the ShellState.aiIndent[] array with the number of
** spaces each opcode should be indented before it is output.
**
** The indenting rules are:
**
**     * For each "Next", "Prev", "VNext" or "VPrev" instruction, indent
**       all opcodes that occur between the p2 jump destination and the opcode
**       itself by 2 spaces.
**
**     * For each "Goto", if the jump destination is earlier in the program
**       and ends on one of:
**          Yield  SeekGt  SeekLt  RowSetRead  Rewind
**       or if the P1 parameter is one instead of zero,
**       then indent all opcodes between the earlier instruction
**       and "Goto" by 2 spaces.
*/
unsafe extern "C" fn explain_data_prepare(mut p: *mut ShellState, mut pSql: *mut sqlite3_stmt) {
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char; /* The text of the SQL statement */
    let mut z: *const libc::c_char = 0 as *const libc::c_char; /* Used to check if this is an EXPLAIN */
    let mut abYield: *mut libc::c_int = 0 as *mut libc::c_int; /* True if op is an OP_Yield */
    let mut nAlloc: libc::c_int = 0 as libc::c_int; /* Allocated size of p->aiIndent[], abYield */
    let mut iOp: libc::c_int = 0; /* Index of operation in p->aiIndent[] */
    let mut azNext: [*const libc::c_char; 6] = [
        b"Next\x00" as *const u8 as *const libc::c_char,
        b"Prev\x00" as *const u8 as *const libc::c_char,
        b"VPrev\x00" as *const u8 as *const libc::c_char,
        b"VNext\x00" as *const u8 as *const libc::c_char,
        b"SorterNext\x00" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azYield: [*const libc::c_char; 6] = [
        b"Yield\x00" as *const u8 as *const libc::c_char,
        b"SeekLT\x00" as *const u8 as *const libc::c_char,
        b"SeekGT\x00" as *const u8 as *const libc::c_char,
        b"RowSetRead\x00" as *const u8 as *const libc::c_char,
        b"Rewind\x00" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    let mut azGoto: [*const libc::c_char; 2] = [
        b"Goto\x00" as *const u8 as *const libc::c_char,
        0 as *const libc::c_char,
    ];
    /* Try to figure out if this is really an EXPLAIN statement. If this
     ** cannot be verified, return early.  */
    if sqlite3_column_count(pSql) != 8 as libc::c_int {
        (*p).cMode = (*p).mode;
        return;
    } else {
        zSql = sqlite3_sql(pSql);
        if zSql.is_null() {
            return;
        } else {
            z = zSql;
            while *z as libc::c_int == ' ' as i32
                || *z as libc::c_int == '\t' as i32
                || *z as libc::c_int == '\n' as i32
                || *z as libc::c_int == '\u{c}' as i32
                || *z as libc::c_int == '\r' as i32
            {
                z = z.offset(1)
            }
            if sqlite3_strnicmp(
                z,
                b"explain\x00" as *const u8 as *const libc::c_char,
                7 as libc::c_int,
            ) != 0
            {
                (*p).cMode = (*p).mode;
                return;
            } else {
                iOp = 0 as libc::c_int;
                while 100 as libc::c_int == sqlite3_step(pSql) {
                    let mut i: libc::c_int = 0;
                    let mut iAddr: libc::c_int = sqlite3_column_int(pSql, 0 as libc::c_int);
                    let mut zOp: *const libc::c_char =
                        sqlite3_column_text(pSql, 1 as libc::c_int) as *const libc::c_char;
                    /* Set p2 to the P2 field of the current opcode. Then, assuming that
                     ** p2 is an instruction address, set variable p2op to the index of that
                     ** instruction in the aiIndent[] array. p2 and p2op may be different if
                     ** the current instruction is part of a sub-program generated by an
                     ** SQL trigger or foreign key.  */
                    let mut p2: libc::c_int = sqlite3_column_int(pSql, 3 as libc::c_int);
                    let mut p2op: libc::c_int = p2 + (iOp - iAddr);
                    /* Grow the p->aiIndent array as required */
                    if iOp >= nAlloc {
                        if iOp == 0 as libc::c_int {
                            /* Do further verfication that this is explain output.  Abort if
                             ** it is not */
                            static mut explainCols: [*const libc::c_char; 8] = [
                                b"addr\x00" as *const u8 as *const libc::c_char,
                                b"opcode\x00" as *const u8 as *const libc::c_char,
                                b"p1\x00" as *const u8 as *const libc::c_char,
                                b"p2\x00" as *const u8 as *const libc::c_char,
                                b"p3\x00" as *const u8 as *const libc::c_char,
                                b"p4\x00" as *const u8 as *const libc::c_char,
                                b"p5\x00" as *const u8 as *const libc::c_char,
                                b"comment\x00" as *const u8 as *const libc::c_char,
                            ];
                            let mut jj: libc::c_int = 0;
                            jj = 0 as libc::c_int;
                            while jj
                                < (::std::mem::size_of::<[*const libc::c_char; 8]>()
                                    as libc::c_ulong)
                                    .wrapping_div(::std::mem::size_of::<*const libc::c_char>()
                                        as libc::c_ulong)
                                    as libc::c_int
                            {
                                if strcmp(sqlite3_column_name(pSql, jj), explainCols[jj as usize])
                                    != 0 as libc::c_int
                                {
                                    (*p).cMode = (*p).mode;
                                    sqlite3_reset(pSql);
                                    return;
                                } else {
                                    jj += 1
                                }
                            }
                        }
                        nAlloc += 100 as libc::c_int;
                        (*p).aiIndent = sqlite3_realloc64(
                            (*p).aiIndent as *mut libc::c_void,
                            (nAlloc as libc::c_ulong)
                                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                as sqlite3_uint64,
                        ) as *mut libc::c_int;
                        if (*p).aiIndent.is_null() {
                            shell_out_of_memory();
                        }
                        abYield = sqlite3_realloc64(
                            abYield as *mut libc::c_void,
                            (nAlloc as libc::c_ulong)
                                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                                as sqlite3_uint64,
                        ) as *mut libc::c_int;
                        if abYield.is_null() {
                            shell_out_of_memory();
                        }
                    }
                    *abYield.offset(iOp as isize) = str_in_array(zOp, azYield.as_mut_ptr());
                    *(*p).aiIndent.offset(iOp as isize) = 0 as libc::c_int;
                    (*p).nIndent = iOp + 1 as libc::c_int;
                    if str_in_array(zOp, azNext.as_mut_ptr()) != 0 {
                        i = p2op;
                        while i < iOp {
                            *(*p).aiIndent.offset(i as isize) += 2 as libc::c_int;
                            i += 1
                        }
                    }
                    if str_in_array(zOp, azGoto.as_mut_ptr()) != 0
                        && p2op < (*p).nIndent
                        && (*abYield.offset(p2op as isize) != 0
                            || sqlite3_column_int(pSql, 2 as libc::c_int) != 0)
                    {
                        i = p2op;
                        while i < iOp {
                            *(*p).aiIndent.offset(i as isize) += 2 as libc::c_int;
                            i += 1
                        }
                    }
                    iOp += 1
                }
                (*p).iIndent = 0 as libc::c_int;
                sqlite3_free(abYield as *mut libc::c_void);
                sqlite3_reset(pSql);
                return;
            }
        }
    };
}
/*
** Free the array allocated by explain_data_prepare().
*/
unsafe extern "C" fn explain_data_delete(mut p: *mut ShellState) {
    sqlite3_free((*p).aiIndent as *mut libc::c_void);
    (*p).aiIndent = 0 as *mut libc::c_int;
    (*p).nIndent = 0 as libc::c_int;
    (*p).iIndent = 0 as libc::c_int;
}
/*
** Disable and restore .wheretrace and .selecttrace settings.
*/
static mut savedSelectTrace: libc::c_uint = 0;
static mut savedWhereTrace: libc::c_uint = 0;
unsafe extern "C" fn disable_debug_trace_modes() {
    let mut zero: libc::c_uint = 0 as libc::c_int as libc::c_uint;
    sqlite3_test_control(
        31 as libc::c_int,
        0 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        2 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut zero as *mut libc::c_uint,
    );
}
unsafe extern "C" fn restore_debug_trace_modes() {
    sqlite3_test_control(
        31 as libc::c_int,
        1 as libc::c_int,
        &mut savedSelectTrace as *mut libc::c_uint,
    );
    sqlite3_test_control(
        31 as libc::c_int,
        3 as libc::c_int,
        &mut savedWhereTrace as *mut libc::c_uint,
    );
}
/* Create the TEMP table used to store parameter bindings */
unsafe extern "C" fn bind_table_init(mut p: *mut ShellState) {
    let mut wrSchema: libc::c_int = 0 as libc::c_int;
    let mut defensiveMode: libc::c_int = 0 as libc::c_int;
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        -(1 as libc::c_int),
        &mut defensiveMode as *mut libc::c_int,
    );
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        0 as libc::c_int,
        0 as libc::c_int,
    );
    sqlite3_db_config(
        (*p).db,
        1011 as libc::c_int,
        -(1 as libc::c_int),
        &mut wrSchema as *mut libc::c_int,
    );
    sqlite3_db_config(
        (*p).db,
        1011 as libc::c_int,
        1 as libc::c_int,
        0 as libc::c_int,
    );
    sqlite3_exec((*p).db,
                 b"CREATE TABLE IF NOT EXISTS temp.sqlite_parameters(\n  key TEXT PRIMARY KEY,\n  value\n) WITHOUT ROWID;\x00"
                     as *const u8 as *const libc::c_char, None,
                 0 as *mut libc::c_void, 0 as *mut *mut libc::c_char);
    sqlite3_db_config((*p).db, 1011 as libc::c_int, wrSchema, 0 as libc::c_int);
    sqlite3_db_config(
        (*p).db,
        1010 as libc::c_int,
        defensiveMode,
        0 as libc::c_int,
    );
}
/*
** Bind parameters on a prepared statement.
**
** Parameter bindings are taken from a TEMP table of the form:
**
**    CREATE TEMP TABLE sqlite_parameters(key TEXT PRIMARY KEY, value)
**    WITHOUT ROWID;
**
** No bindings occur if this table does not exist.  The name of the table
** begins with "sqlite_" so that it will not collide with ordinary application
** tables.  The table must be in the TEMP schema.
*/
unsafe extern "C" fn bind_prepared_stmt(mut pArg: *mut ShellState, mut pStmt: *mut sqlite3_stmt) {
    let mut nVar: libc::c_int = 0; /* Nothing to do */
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut pQ: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    nVar = sqlite3_bind_parameter_count(pStmt);
    if nVar == 0 as libc::c_int {
        return;
    } else if sqlite3_table_column_metadata(
        (*pArg).db,
        b"TEMP\x00" as *const u8 as *const libc::c_char,
        b"sqlite_parameters\x00" as *const u8 as *const libc::c_char,
        b"key\x00" as *const u8 as *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut *const libc::c_char,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    ) != 0 as libc::c_int
    {
        return;
        /* Parameter table does not exist */
    } else {
        rc = sqlite3_prepare_v2(
            (*pArg).db,
            b"SELECT value FROM temp.sqlite_parameters WHERE key=?1\x00" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pQ,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 || pQ.is_null() {
            return;
        } else {
            i = 1 as libc::c_int;
            while i <= nVar {
                let mut zNum: [libc::c_char; 30] = [0; 30];
                let mut zVar: *const libc::c_char = sqlite3_bind_parameter_name(pStmt, i);
                if zVar.is_null() {
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as libc::c_int,
                        zNum.as_mut_ptr(),
                        b"?%d\x00" as *const u8 as *const libc::c_char,
                        i,
                    );
                    zVar = zNum.as_mut_ptr()
                }
                sqlite3_bind_text(pQ, 1 as libc::c_int, zVar, -(1 as libc::c_int), None);
                if sqlite3_step(pQ) == 100 as libc::c_int {
                    sqlite3_bind_value(pStmt, i, sqlite3_column_value(pQ, 0 as libc::c_int));
                } else {
                    sqlite3_bind_null(pStmt, i);
                }
                sqlite3_reset(pQ);
                i += 1
            }
            sqlite3_finalize(pQ);
            return;
        }
    };
}
/* U+253c -|- */
/* Draw horizontal line N characters long using unicode box
** characters
*/
unsafe extern "C" fn print_box_line(mut out: *mut FILE, mut N: libc::c_int) {
    let zDash: [libc::c_char; 61] =
        *::std::mem::transmute::<&[u8; 61],
                                 &[libc::c_char; 61]>(b"\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\xe2\x94\x80\x00");
    let nDash: libc::c_int = (::std::mem::size_of::<[libc::c_char; 61]>() as libc::c_ulong)
        .wrapping_sub(1 as libc::c_int as libc::c_ulong)
        as libc::c_int;
    N *= 3 as libc::c_int;
    while N > nDash {
        fprintf(out, zDash.as_ptr());
        N -= nDash
    }
    fprintf(
        out,
        b"%.*s\x00" as *const u8 as *const libc::c_char,
        N,
        zDash.as_ptr(),
    );
}
/*
** Draw a horizontal separator for a MODE_Box table.
*/
unsafe extern "C" fn print_box_row_separator(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut zSep1: *const libc::c_char,
    mut zSep2: *const libc::c_char,
    mut zSep3: *const libc::c_char,
) {
    let mut i: libc::c_int = 0;
    if nArg > 0 as libc::c_int {
        fprintf(
            (*p).out,
            b"%s\x00" as *const u8 as *const libc::c_char,
            zSep1,
        );
        print_box_line(
            (*p).out,
            *(*p).actualWidth.offset(0 as libc::c_int as isize) + 2 as libc::c_int,
        );
        i = 1 as libc::c_int;
        while i < nArg {
            fprintf(
                (*p).out,
                b"%s\x00" as *const u8 as *const libc::c_char,
                zSep2,
            );
            print_box_line(
                (*p).out,
                *(*p).actualWidth.offset(i as isize) + 2 as libc::c_int,
            );
            i += 1
        }
        fprintf(
            (*p).out,
            b"%s\x00" as *const u8 as *const libc::c_char,
            zSep3,
        );
    }
    fputs(b"\n\x00" as *const u8 as *const libc::c_char, (*p).out);
}
/*
** Run a prepared statement and output the result in one of the
** table-oriented formats: MODE_Column, MODE_Markdown, MODE_Table,
** or MODE_Box.
**
** This is different from ordinary exec_prepared_stmt() in that
** it has to run the entire query and gather the results into memory
** first, in order to determine column widths, before providing
** any output.
*/
unsafe extern "C" fn exec_prepared_stmt_columnar(
    mut p: *mut ShellState,
    mut pStmt: *mut sqlite3_stmt,
)
/* Statment to run */
{
    let mut current_block: u64;
    let mut nRow: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut nColumn: libc::c_int = 0 as libc::c_int;
    let mut azData: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut nAlloc: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
    let mut z: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: sqlite3_int64 = 0;
    let mut nData: sqlite3_int64 = 0;
    let mut j: libc::c_int = 0;
    let mut nTotal: libc::c_int = 0;
    let mut w: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut colSep: *const libc::c_char = 0 as *const libc::c_char;
    let mut rowSep: *const libc::c_char = 0 as *const libc::c_char;
    rc = sqlite3_step(pStmt);
    if rc != 100 as libc::c_int {
        return;
    } else {
        nColumn = sqlite3_column_count(pStmt);
        nAlloc = (nColumn * 4 as libc::c_int) as sqlite3_int64;
        if nAlloc <= 0 as libc::c_int as libc::c_longlong {
            nAlloc = 1 as libc::c_int as sqlite3_int64
        }
        azData = sqlite3_malloc64((nAlloc as libc::c_ulonglong).wrapping_mul(
            ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong as libc::c_ulonglong,
        )) as *mut *mut libc::c_char;
        if azData.is_null() {
            shell_out_of_memory();
        }
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            let ref mut fresh54 = *azData.offset(i as isize);
            *fresh54 = strdup(sqlite3_column_name(pStmt, i as libc::c_int));
            i += 1
        }
        loop {
            if (nRow + 2 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong >= nAlloc
            {
                nAlloc *= 2 as libc::c_int as libc::c_longlong;
                azData = sqlite3_realloc64(
                    azData as *mut libc::c_void,
                    (nAlloc as libc::c_ulonglong).wrapping_mul(::std::mem::size_of::<
                        *mut libc::c_char,
                    >()
                        as libc::c_ulong
                        as libc::c_ulonglong),
                ) as *mut *mut libc::c_char;
                if azData.is_null() {
                    shell_out_of_memory();
                }
            }
            nRow += 1;
            i = 0 as libc::c_int as sqlite3_int64;
            while i < nColumn as libc::c_longlong {
                z = sqlite3_column_text(pStmt, i as libc::c_int) as *const libc::c_char;
                let ref mut fresh55 =
                    *azData.offset((nRow * nColumn as libc::c_longlong + i) as isize);
                *fresh55 = if !z.is_null() {
                    strdup(z)
                } else {
                    0 as *mut libc::c_char
                };
                i += 1
            }
            if !(sqlite3_step(pStmt) == 100 as libc::c_int) {
                break;
            }
        }
        if nColumn > (*p).nWidth {
            (*p).colWidth = realloc(
                (*p).colWidth as *mut libc::c_void,
                (((nColumn + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
            ) as *mut libc::c_int;
            if (*p).colWidth.is_null() {
                shell_out_of_memory();
            }
            i = (*p).nWidth as sqlite3_int64;
            while i < nColumn as libc::c_longlong {
                *(*p).colWidth.offset(i as isize) = 0 as libc::c_int;
                i += 1
            }
            (*p).nWidth = nColumn;
            (*p).actualWidth = &mut *(*p).colWidth.offset(nColumn as isize) as *mut libc::c_int
        }
        memset(
            (*p).actualWidth as *mut libc::c_void,
            0 as libc::c_int,
            (nColumn as libc::c_ulong)
                .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong),
        );
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nColumn as libc::c_longlong {
            w = *(*p).colWidth.offset(i as isize);
            if w < 0 as libc::c_int {
                w = -w
            }
            *(*p).actualWidth.offset(i as isize) = w;
            i += 1
        }
        nTotal = (nColumn as libc::c_longlong * (nRow + 1 as libc::c_int as libc::c_longlong))
            as libc::c_int;
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nTotal as libc::c_longlong {
            z = *azData.offset(i as isize);
            if z.is_null() {
                z = (*p).nullValue.as_mut_ptr()
            }
            n = strlenChar(z);
            j = (i % nColumn as libc::c_longlong) as libc::c_int;
            if n > *(*p).actualWidth.offset(j as isize) {
                *(*p).actualWidth.offset(j as isize) = n
            }
            i += 1
        }
        if !(seenInterrupt != 0) {
            if !(nColumn == 0 as libc::c_int) {
                match (*p).cMode {
                    1 => {
                        colSep = b"  \x00" as *const u8 as *const libc::c_char;
                        rowSep = b"\n\x00" as *const u8 as *const libc::c_char;
                        if (*p).showHeader != 0 {
                            i = 0 as libc::c_int as sqlite3_int64;
                            while i < nColumn as libc::c_longlong {
                                w = *(*p).actualWidth.offset(i as isize);
                                if *(*p).colWidth.offset(i as isize) < 0 as libc::c_int {
                                    w = -w
                                }
                                utf8_width_print((*p).out, w, *azData.offset(i as isize));
                                fputs(
                                    if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                        b"\n\x00" as *const u8 as *const libc::c_char
                                    } else {
                                        b"  \x00" as *const u8 as *const libc::c_char
                                    },
                                    (*p).out,
                                );
                                i += 1
                            }
                            i = 0 as libc::c_int as sqlite3_int64;
                            while i < nColumn as libc::c_longlong {
                                print_dashes((*p).out, *(*p).actualWidth.offset(i as isize));
                                fputs(
                                    if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                        b"\n\x00" as *const u8 as *const libc::c_char
                                    } else {
                                        b"  \x00" as *const u8 as *const libc::c_char
                                    },
                                    (*p).out,
                                );
                                i += 1
                            }
                        }
                    }
                    15 => {
                        colSep = b" | \x00" as *const u8 as *const libc::c_char;
                        rowSep = b" |\n\x00" as *const u8 as *const libc::c_char;
                        print_row_separator(
                            p,
                            nColumn,
                            b"+\x00" as *const u8 as *const libc::c_char,
                        );
                        fputs(b"| \x00" as *const u8 as *const libc::c_char, (*p).out);
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *(*p).actualWidth.offset(i as isize);
                            n = strlenChar(*azData.offset(i as isize));
                            fprintf(
                                (*p).out,
                                b"%*s%s%*s\x00" as *const u8 as *const libc::c_char,
                                (w - n) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                                *azData.offset(i as isize),
                                (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                            );
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b" |\n\x00" as *const u8 as *const libc::c_char
                                } else {
                                    b" | \x00" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1
                        }
                        print_row_separator(
                            p,
                            nColumn,
                            b"+\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                    14 => {
                        colSep = b" | \x00" as *const u8 as *const libc::c_char;
                        rowSep = b" |\n\x00" as *const u8 as *const libc::c_char;
                        fputs(b"| \x00" as *const u8 as *const libc::c_char, (*p).out);
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *(*p).actualWidth.offset(i as isize);
                            n = strlenChar(*azData.offset(i as isize));
                            fprintf(
                                (*p).out,
                                b"%*s%s%*s\x00" as *const u8 as *const libc::c_char,
                                (w - n) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                                *azData.offset(i as isize),
                                (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                            );
                            fputs(
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b" |\n\x00" as *const u8 as *const libc::c_char
                                } else {
                                    b" | \x00" as *const u8 as *const libc::c_char
                                },
                                (*p).out,
                            );
                            i += 1
                        }
                        print_row_separator(
                            p,
                            nColumn,
                            b"|\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                    16 => {
                        colSep = b" \xe2\x94\x82 \x00" as *const u8 as *const libc::c_char;
                        rowSep = b" \xe2\x94\x82\n\x00" as *const u8 as *const libc::c_char;
                        print_box_row_separator(
                            p,
                            nColumn,
                            b"\xe2\x94\x8c\x00" as *const u8 as *const libc::c_char,
                            b"\xe2\x94\xac\x00" as *const u8 as *const libc::c_char,
                            b"\xe2\x94\x90\x00" as *const u8 as *const libc::c_char,
                        );
                        fprintf(
                            (*p).out,
                            b"\xe2\x94\x82 \x00" as *const u8 as *const libc::c_char,
                        );
                        i = 0 as libc::c_int as sqlite3_int64;
                        while i < nColumn as libc::c_longlong {
                            w = *(*p).actualWidth.offset(i as isize);
                            n = strlenChar(*azData.offset(i as isize));
                            fprintf(
                                (*p).out,
                                b"%*s%s%*s%s\x00" as *const u8 as *const libc::c_char,
                                (w - n) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                                *azData.offset(i as isize),
                                (w - n + 1 as libc::c_int) / 2 as libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                                if i == (nColumn - 1 as libc::c_int) as libc::c_longlong {
                                    b" \xe2\x94\x82\n\x00" as *const u8 as *const libc::c_char
                                } else {
                                    b" \xe2\x94\x82 \x00" as *const u8 as *const libc::c_char
                                },
                            );
                            i += 1
                        }
                        print_box_row_separator(
                            p,
                            nColumn,
                            b"\xe2\x94\x9c\x00" as *const u8 as *const libc::c_char,
                            b"\xe2\x94\xbc\x00" as *const u8 as *const libc::c_char,
                            b"\xe2\x94\xa4\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                    _ => {}
                }
                i = nColumn as sqlite3_int64;
                j = 0 as libc::c_int;
                loop {
                    if !(i < nTotal as libc::c_longlong) {
                        current_block = 7739940392431776979;
                        break;
                    }
                    if j == 0 as libc::c_int && (*p).cMode != 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            if (*p).cMode == 16 as libc::c_int {
                                b"\xe2\x94\x82 \x00" as *const u8 as *const libc::c_char
                            } else {
                                b"| \x00" as *const u8 as *const libc::c_char
                            },
                        );
                    }
                    z = *azData.offset(i as isize);
                    if z.is_null() {
                        z = (*p).nullValue.as_mut_ptr()
                    }
                    w = *(*p).actualWidth.offset(j as isize);
                    if *(*p).colWidth.offset(j as isize) < 0 as libc::c_int {
                        w = -w
                    }
                    utf8_width_print((*p).out, w, z);
                    if j == nColumn - 1 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            rowSep,
                        );
                        j = -(1 as libc::c_int);
                        if seenInterrupt != 0 {
                            current_block = 5731132729875008911;
                            break;
                        }
                    } else {
                        fprintf(
                            (*p).out,
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            colSep,
                        );
                    }
                    i += 1;
                    j += 1
                }
                match current_block {
                    5731132729875008911 => {}
                    _ => {
                        if (*p).cMode == 15 as libc::c_int {
                            print_row_separator(
                                p,
                                nColumn,
                                b"+\x00" as *const u8 as *const libc::c_char,
                            );
                        } else if (*p).cMode == 16 as libc::c_int {
                            print_box_row_separator(
                                p,
                                nColumn,
                                b"\xe2\x94\x94\x00" as *const u8 as *const libc::c_char,
                                b"\xe2\x94\xb4\x00" as *const u8 as *const libc::c_char,
                                b"\xe2\x94\x98\x00" as *const u8 as *const libc::c_char,
                            );
                        }
                    }
                }
            }
        }
        if seenInterrupt != 0 {
            fprintf(
                (*p).out,
                b"Interrupt\n\x00" as *const u8 as *const libc::c_char,
            );
        }
        nData = (nRow + 1 as libc::c_int as libc::c_longlong) * nColumn as libc::c_longlong;
        i = 0 as libc::c_int as sqlite3_int64;
        while i < nData {
            free(*azData.offset(i as isize) as *mut libc::c_void);
            i += 1
        }
        sqlite3_free(azData as *mut libc::c_void);
        return;
    };
}
/*
** Run a prepared statement
*/
unsafe extern "C" fn exec_prepared_stmt(mut pArg: *mut ShellState, mut pStmt: *mut sqlite3_stmt)
/* Statment to run */
{
    let mut rc: libc::c_int = 0;
    if (*pArg).cMode == 1 as libc::c_int
        || (*pArg).cMode == 15 as libc::c_int
        || (*pArg).cMode == 16 as libc::c_int
        || (*pArg).cMode == 14 as libc::c_int
    {
        exec_prepared_stmt_columnar(pArg, pStmt);
        return;
    } else {
        /* perform the first step.  this will tell us if we
         ** have a result set or not and how wide it is.
         */
        rc = sqlite3_step(pStmt);
        /* if we have a result set... */
        if 100 as libc::c_int == rc {
            /* allocate space for col name ptr, value ptr, and type */
            let mut nCol: libc::c_int = sqlite3_column_count(pStmt); /* Names of result columns */
            let mut pData: *mut libc::c_void = sqlite3_malloc64(
                ((3 as libc::c_int * nCol) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                    .wrapping_add(1 as libc::c_int as libc::c_ulong)
                    as sqlite3_uint64,
            ); /* Results */
            if pData.is_null() {
                shell_out_of_memory(); /* Result types */
            } else {
                let mut azCols: *mut *mut libc::c_char = pData as *mut *mut libc::c_char;
                let mut azVals: *mut *mut libc::c_char =
                    &mut *azCols.offset(nCol as isize) as *mut *mut libc::c_char;
                let mut aiTypes: *mut libc::c_int = &mut *azVals.offset(nCol as isize)
                    as *mut *mut libc::c_char
                    as *mut libc::c_int;
                let mut i: libc::c_int = 0;
                let mut x: libc::c_int = 0;
                /* save off ptrs to column names */
                i = 0 as libc::c_int;
                while i < nCol {
                    let ref mut fresh56 = *azCols.offset(i as isize);
                    *fresh56 = sqlite3_column_name(pStmt, i) as *mut libc::c_char;
                    i += 1
                }
                loop
                /* extract the data and data types */
                {
                    i = 0 as libc::c_int; /* end for */
                    while i < nCol {
                        x = sqlite3_column_type(pStmt, i);
                        *aiTypes.offset(i as isize) = x;
                        if x == 4 as libc::c_int
                            && !pArg.is_null()
                            && (*pArg).cMode == 5 as libc::c_int
                        {
                            let ref mut fresh57 = *azVals.offset(i as isize);
                            *fresh57 =
                                b"\x00" as *const u8 as *const libc::c_char as *mut libc::c_char
                        } else {
                            let ref mut fresh58 = *azVals.offset(i as isize);
                            *fresh58 = sqlite3_column_text(pStmt, i) as *mut libc::c_char
                        }
                        if (*azVals.offset(i as isize)).is_null()
                            && *aiTypes.offset(i as isize) != 5 as libc::c_int
                        {
                            rc = 7 as libc::c_int;
                            break;
                            /* from for */
                        } else {
                            i += 1
                        }
                    }
                    /* if data and types extracted successfully... */
                    if 100 as libc::c_int == rc {
                        /* call the supplied callback with the result row data */
                        if shell_callback(pArg as *mut libc::c_void, nCol, azVals, azCols, aiTypes)
                            != 0
                        {
                            rc = 4 as libc::c_int
                        } else {
                            rc = sqlite3_step(pStmt)
                        }
                    }
                    if !(100 as libc::c_int == rc) {
                        break;
                    }
                }
                sqlite3_free(pData);
                if (*pArg).cMode == 13 as libc::c_int {
                    fputs(b"]\n\x00" as *const u8 as *const libc::c_char, (*pArg).out);
                }
            }
        }
        return;
    };
}
/*
** This function is called to process SQL if the previous shell command
** was ".expert". It passes the SQL in the second argument directly to
** the sqlite3expert object.
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
** code. In this case, (*pzErr) may be set to point to a buffer containing
** an English language error message. It is the responsibility of the
** caller to eventually free this buffer using sqlite3_free().
*/
unsafe extern "C" fn expertHandleSQL(
    mut pState: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    return sqlite3_expert_sql((*pState).expert.pExpert, zSql, pzErr);
}
/*
** This function is called either to silently clean up the object
** created by the ".expert" command (if bCancel==1), or to generate a
** report from it and then clean it up (if bCancel==0).
**
** If successful, SQLITE_OK is returned. Otherwise, an SQLite error
** code. In this case, (*pzErr) may be set to point to a buffer containing
** an English language error message. It is the responsibility of the
** caller to eventually free this buffer using sqlite3_free().
*/
unsafe extern "C" fn expertFinish(
    mut pState: *mut ShellState,
    mut bCancel: libc::c_int,
    mut pzErr: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut p: *mut sqlite3expert = (*pState).expert.pExpert;
    if bCancel == 0 as libc::c_int {
        let mut out: *mut FILE = (*pState).out;
        let mut bVerbose: libc::c_int = (*pState).expert.bVerbose;
        rc = sqlite3_expert_analyze(p, pzErr);
        if rc == 0 as libc::c_int {
            let mut nQuery: libc::c_int = sqlite3_expert_count(p);
            let mut i: libc::c_int = 0;
            if bVerbose != 0 {
                let mut zCand: *const libc::c_char =
                    sqlite3_expert_report(p, 0 as libc::c_int, 4 as libc::c_int);
                fprintf(
                    out,
                    b"-- Candidates -----------------------------\n\x00" as *const u8
                        as *const libc::c_char,
                );
                fprintf(out, b"%s\n\x00" as *const u8 as *const libc::c_char, zCand);
            }
            i = 0 as libc::c_int;
            while i < nQuery {
                let mut zSql: *const libc::c_char = sqlite3_expert_report(p, i, 1 as libc::c_int);
                let mut zIdx: *const libc::c_char = sqlite3_expert_report(p, i, 2 as libc::c_int);
                let mut zEQP: *const libc::c_char = sqlite3_expert_report(p, i, 3 as libc::c_int);
                if zIdx.is_null() {
                    zIdx = b"(no new indexes)\n\x00" as *const u8 as *const libc::c_char
                }
                if bVerbose != 0 {
                    fprintf(
                        out,
                        b"-- Query %d --------------------------------\n\x00" as *const u8
                            as *const libc::c_char,
                        i + 1 as libc::c_int,
                    );
                    fprintf(out, b"%s\n\n\x00" as *const u8 as *const libc::c_char, zSql);
                }
                fprintf(out, b"%s\n\x00" as *const u8 as *const libc::c_char, zIdx);
                fprintf(out, b"%s\n\x00" as *const u8 as *const libc::c_char, zEQP);
                i += 1
            }
        }
    }
    sqlite3_expert_destroy(p);
    (*pState).expert.pExpert = 0 as *mut sqlite3expert;
    return rc;
}
/*
** Implementation of ".expert" dot command.
*/
unsafe extern "C" fn expertDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int
/* Number of entries in azArg[] */ {
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut iSample: libc::c_int = 0 as libc::c_int;
    memset(
        &mut (*pState).expert as *mut ExpertInfo as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ExpertInfo>() as libc::c_ulong,
    );
    i = 1 as libc::c_int;
    while rc == 0 as libc::c_int && i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1)
        }
        n = strlen30(z);
        if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == strncmp(
                    z,
                    b"-verbose\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                )
        {
            (*pState).expert.bVerbose = 1 as libc::c_int
        } else if n >= 2 as libc::c_int
            && 0 as libc::c_int
                == strncmp(
                    z,
                    b"-sample\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                )
        {
            if i == nArg - 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"option requires an argument: %s\n\x00" as *const u8 as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int
            } else {
                i += 1;
                iSample = integerValue(*azArg.offset(i as isize)) as libc::c_int;
                if iSample < 0 as libc::c_int || iSample > 100 as libc::c_int {
                    fprintf(
                        stderr,
                        b"value out of range: %s\n\x00" as *const u8 as *const libc::c_char,
                        *azArg.offset(i as isize),
                    );
                    rc = 1 as libc::c_int
                }
            }
        } else {
            fprintf(
                stderr,
                b"unknown option: %s\n\x00" as *const u8 as *const libc::c_char,
                z,
            );
            rc = 1 as libc::c_int
        }
        i += 1
    }
    if rc == 0 as libc::c_int {
        (*pState).expert.pExpert = sqlite3_expert_new((*pState).db, &mut zErr);
        if (*pState).expert.pExpert.is_null() {
            fprintf(
                stderr,
                b"sqlite3_expert_new: %s\n\x00" as *const u8 as *const libc::c_char,
                zErr,
            );
            rc = 1 as libc::c_int
        } else {
            sqlite3_expert_config((*pState).expert.pExpert, 1 as libc::c_int, iSample);
        }
    }
    return rc;
}
/* ifndef SQLITE_OMIT_VIRTUALTABLE */
/*
** Execute a statement or set of statements.  Print
** any result rows/columns depending on the current mode
** set via the supplied callback.
**
** This is very similar to SQLite's built-in sqlite3_exec()
** function except it takes a slightly different callback
** and callback data argument.
*/
unsafe extern "C" fn shell_exec(
    mut pArg: *mut ShellState,
    mut zSql: *const libc::c_char,
    mut pzErrMsg: *mut *mut libc::c_char,
) -> libc::c_int
/* Error msg written here */ {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* Statement to execute. */
    let mut rc: libc::c_int = 0 as libc::c_int; /* Return Code */
    let mut rc2: libc::c_int = 0; /* Tail of unprocessed SQL */
    let mut zLeftover: *const libc::c_char = 0 as *const libc::c_char; /* end while */
    let mut db: *mut sqlite3 = (*pArg).db;
    if !pzErrMsg.is_null() {
        *pzErrMsg = 0 as *mut libc::c_char
    }
    if !(*pArg).expert.pExpert.is_null() {
        rc = expertHandleSQL(pArg, zSql, pzErrMsg);
        return expertFinish(pArg, (rc != 0 as libc::c_int) as libc::c_int, pzErrMsg);
    } else {
        while *zSql.offset(0 as libc::c_int as isize) as libc::c_int != 0 && 0 as libc::c_int == rc
        {
            static mut zStmtSql: *const libc::c_char = 0 as *const libc::c_char;
            rc = sqlite3_prepare_v2(db, zSql, -(1 as libc::c_int), &mut pStmt, &mut zLeftover);
            if 0 as libc::c_int != rc {
                if pzErrMsg.is_null() {
                    continue;
                }
                *pzErrMsg = save_err_msg(db)
            } else if pStmt.is_null() {
                /* this happens for a comment or white-space */
                zSql = zLeftover;
                while *(*__ctype_b_loc()).offset(*zSql.offset(0 as libc::c_int as isize)
                    as libc::c_uchar as libc::c_int
                    as isize) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    zSql = zSql.offset(1)
                }
            } else {
                zStmtSql = sqlite3_sql(pStmt);
                if zStmtSql.is_null() {
                    zStmtSql = b"\x00" as *const u8 as *const libc::c_char
                }
                while *(*__ctype_b_loc())
                    .offset(*zStmtSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                        as libc::c_int as isize) as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    zStmtSql = zStmtSql.offset(1)
                }
                /* save off the prepared statment handle and reset row count */
                if !pArg.is_null() {
                    (*pArg).pStmt = pStmt;
                    (*pArg).cnt = 0 as libc::c_int
                }
                /* echo the sql statement if echo on */
                if !pArg.is_null()
                    && (*pArg).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                {
                    fprintf(
                        (*pArg).out,
                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                        if !zStmtSql.is_null() { zStmtSql } else { zSql },
                    );
                }
                /* Show the EXPLAIN QUERY PLAN if .eqp is on */
                if !pArg.is_null()
                    && (*pArg).autoEQP as libc::c_int != 0
                    && sqlite3_stmt_isexplain(pStmt) == 0 as libc::c_int
                {
                    let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    let mut zEQP: *mut libc::c_char = 0 as *mut libc::c_char;
                    let mut triggerEQP: libc::c_int = 0 as libc::c_int;
                    disable_debug_trace_modes();
                    sqlite3_db_config(
                        db,
                        1008 as libc::c_int,
                        -(1 as libc::c_int),
                        &mut triggerEQP as *mut libc::c_int,
                    );
                    if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int {
                        sqlite3_db_config(
                            db,
                            1008 as libc::c_int,
                            1 as libc::c_int,
                            0 as libc::c_int,
                        );
                    }
                    zEQP = sqlite3_mprintf(
                        b"EXPLAIN QUERY PLAN %s\x00" as *const u8 as *const libc::c_char,
                        zStmtSql,
                    );
                    rc = sqlite3_prepare_v2(
                        db,
                        zEQP,
                        -(1 as libc::c_int),
                        &mut pExplain,
                        0 as *mut *const libc::c_char,
                    );
                    if rc == 0 as libc::c_int {
                        while sqlite3_step(pExplain) == 100 as libc::c_int {
                            let mut zEQPLine: *const libc::c_char =
                                sqlite3_column_text(pExplain, 3 as libc::c_int)
                                    as *const libc::c_char;
                            let mut iEqpId: libc::c_int =
                                sqlite3_column_int(pExplain, 0 as libc::c_int);
                            let mut iParentId: libc::c_int =
                                sqlite3_column_int(pExplain, 1 as libc::c_int);
                            if zEQPLine.is_null() {
                                zEQPLine = b"\x00" as *const u8 as *const libc::c_char
                            }
                            if *zEQPLine.offset(0 as libc::c_int as isize) as libc::c_int
                                == '-' as i32
                            {
                                eqp_render(pArg);
                            }
                            eqp_append(pArg, iEqpId, iParentId, zEQPLine);
                        }
                        eqp_render(pArg);
                    }
                    sqlite3_finalize(pExplain);
                    sqlite3_free(zEQP as *mut libc::c_void);
                    if (*pArg).autoEQP as libc::c_int >= 3 as libc::c_int {
                        /* Also do an EXPLAIN for ".eqp full" mode */
                        zEQP = sqlite3_mprintf(
                            b"EXPLAIN %s\x00" as *const u8 as *const libc::c_char,
                            zStmtSql,
                        );
                        rc = sqlite3_prepare_v2(
                            db,
                            zEQP,
                            -(1 as libc::c_int),
                            &mut pExplain,
                            0 as *mut *const libc::c_char,
                        );
                        if rc == 0 as libc::c_int {
                            (*pArg).cMode = 9 as libc::c_int;
                            explain_data_prepare(pArg, pExplain);
                            exec_prepared_stmt(pArg, pExplain);
                            explain_data_delete(pArg);
                        }
                        sqlite3_finalize(pExplain);
                        sqlite3_free(zEQP as *mut libc::c_void);
                    }
                    if (*pArg).autoEQP as libc::c_int >= 2 as libc::c_int
                        && triggerEQP == 0 as libc::c_int
                    {
                        sqlite3_db_config(
                            db,
                            1008 as libc::c_int,
                            0 as libc::c_int,
                            0 as libc::c_int,
                        );
                        /* Reprepare pStmt before reactiving trace modes */
                        sqlite3_finalize(pStmt);
                        sqlite3_prepare_v2(
                            db,
                            zSql,
                            -(1 as libc::c_int),
                            &mut pStmt,
                            0 as *mut *const libc::c_char,
                        );
                        if !pArg.is_null() {
                            (*pArg).pStmt = pStmt
                        }
                    }
                    restore_debug_trace_modes();
                }
                if !pArg.is_null() {
                    (*pArg).cMode = (*pArg).mode;
                    if (*pArg).autoExplain != 0 {
                        if sqlite3_stmt_isexplain(pStmt) == 1 as libc::c_int {
                            (*pArg).cMode = 9 as libc::c_int
                        }
                        if sqlite3_stmt_isexplain(pStmt) == 2 as libc::c_int {
                            (*pArg).cMode = 12 as libc::c_int
                        }
                    }
                    /* If the shell is currently in ".explain" mode, gather the extra
                     ** data required to add indents to the output.*/
                    if (*pArg).cMode == 9 as libc::c_int {
                        explain_data_prepare(pArg, pStmt);
                    }
                }
                bind_prepared_stmt(pArg, pStmt);
                exec_prepared_stmt(pArg, pStmt);
                explain_data_delete(pArg);
                eqp_render(pArg);
                /* print usage stats if stats on */
                if !pArg.is_null() && (*pArg).statsOn != 0 {
                    display_stats(db, pArg, 0 as libc::c_int);
                }
                /* print loop-counters if required */
                if !pArg.is_null() && (*pArg).scanstatsOn as libc::c_int != 0 {
                    display_scanstats(db, pArg);
                }
                /* Finalize the statement just executed. If this fails, save a
                 ** copy of the error message. Otherwise, set zSql to point to the
                 ** next statement to execute. */
                rc2 = sqlite3_finalize(pStmt);
                if rc != 7 as libc::c_int {
                    rc = rc2
                }
                if rc == 0 as libc::c_int {
                    zSql = zLeftover;
                    while *(*__ctype_b_loc())
                        .offset(*zSql.offset(0 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int as isize) as libc::c_int
                        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                        != 0
                    {
                        zSql = zSql.offset(1)
                    }
                } else if !pzErrMsg.is_null() {
                    *pzErrMsg = save_err_msg(db)
                }
                /* clear saved stmt handle */
                if pArg.is_null() {
                    continue;
                }
                (*pArg).pStmt = 0 as *mut sqlite3_stmt
            }
        }
        return rc;
    };
}
/*
** Release memory previously allocated by tableColumnList().
*/
unsafe extern "C" fn freeColumnList(mut azCol: *mut *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    i = 1 as libc::c_int;
    while !(*azCol.offset(i as isize)).is_null() {
        sqlite3_free(*azCol.offset(i as isize) as *mut libc::c_void);
        i += 1
    }
    /* azCol[0] is a static string */
    sqlite3_free(azCol as *mut libc::c_void);
}
/*
** Return a list of pointers to strings which are the names of all
** columns in table zTab.   The memory to hold the names is dynamically
** allocated and must be released by the caller using a subsequent call
** to freeColumnList().
**
** The azCol[0] entry is usually NULL.  However, if zTab contains a rowid
** value that needs to be preserved, then azCol[0] is filled in with the
** name of the rowid column.
**
** The first regular column in the table is azCol[1].  The list is terminated
** by an entry with azCol[i]==0.
*/
unsafe extern "C" fn tableColumnList(
    mut p: *mut ShellState,
    mut zTab: *const libc::c_char,
) -> *mut *mut libc::c_char {
    let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char; /* Number of PRIMARY KEY columns seen */
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* True if one PRIMARY KEY column of type INTEGER */
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut nCol: libc::c_int = 0 as libc::c_int;
    let mut nAlloc: libc::c_int = 0 as libc::c_int;
    let mut nPK: libc::c_int = 0 as libc::c_int;
    let mut isIPK: libc::c_int = 0 as libc::c_int;
    let mut preserveRowid: libc::c_int = ((*p).shellFlgs & 0x8 as libc::c_int as libc::c_uint
        != 0 as libc::c_int as libc::c_uint)
        as libc::c_int;
    let mut rc: libc::c_int = 0;
    zSql = sqlite3_mprintf(
        b"PRAGMA table_info=%Q\x00" as *const u8 as *const libc::c_char,
        zTab,
    );
    rc = sqlite3_prepare_v2(
        (*p).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    sqlite3_free(zSql as *mut libc::c_void);
    if rc != 0 {
        return 0 as *mut *mut libc::c_char;
    } else {
        while sqlite3_step(pStmt) == 100 as libc::c_int {
            if nCol >= nAlloc - 2 as libc::c_int {
                nAlloc = nAlloc * 2 as libc::c_int + nCol + 10 as libc::c_int;
                azCol = sqlite3_realloc(
                    azCol as *mut libc::c_void,
                    (nAlloc as libc::c_ulong)
                        .wrapping_mul(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        as libc::c_int,
                ) as *mut *mut libc::c_char;
                if azCol.is_null() {
                    shell_out_of_memory();
                }
            }
            nCol += 1;
            let ref mut fresh59 = *azCol.offset(nCol as isize);
            *fresh59 = sqlite3_mprintf(
                b"%s\x00" as *const u8 as *const libc::c_char,
                sqlite3_column_text(pStmt, 1 as libc::c_int),
            );
            if !(sqlite3_column_int(pStmt, 5 as libc::c_int) != 0) {
                continue;
            }
            nPK += 1;
            if nPK == 1 as libc::c_int
                && sqlite3_stricmp(
                    sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char,
                    b"INTEGER\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                isIPK = 1 as libc::c_int
            } else {
                isIPK = 0 as libc::c_int
            }
        }
        sqlite3_finalize(pStmt);
        if azCol.is_null() {
            return 0 as *mut *mut libc::c_char;
        } else {
            let ref mut fresh60 = *azCol.offset(0 as libc::c_int as isize);
            *fresh60 = 0 as *mut libc::c_char;
            let ref mut fresh61 = *azCol.offset((nCol + 1 as libc::c_int) as isize);
            *fresh61 = 0 as *mut libc::c_char;
            /* The decision of whether or not a rowid really needs to be preserved
             ** is tricky.  We never need to preserve a rowid for a WITHOUT ROWID table
             ** or a table with an INTEGER PRIMARY KEY.  We are unable to preserve
             ** rowids on tables where the rowid is inaccessible because there are other
             ** columns in the table named "rowid", "_rowid_", and "oid".
             */
            if preserveRowid != 0 && isIPK != 0 {
                /* If a single PRIMARY KEY column with type INTEGER was seen, then it
                 ** might be an alise for the ROWID.  But it might also be a WITHOUT ROWID
                 ** table or a INTEGER PRIMARY KEY DESC column, neither of which are
                 ** ROWID aliases.  To distinguish these cases, check to see if
                 ** there is a "pk" entry in "PRAGMA index_list".  There will be
                 ** no "pk" index if the PRIMARY KEY really is an alias for the ROWID.
                 */
                zSql = sqlite3_mprintf(
                    b"SELECT 1 FROM pragma_index_list(%Q) WHERE origin=\'pk\'\x00" as *const u8
                        as *const libc::c_char,
                    zTab,
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zSql,
                    -(1 as libc::c_int),
                    &mut pStmt,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql as *mut libc::c_void);
                if rc != 0 {
                    freeColumnList(azCol);
                    return 0 as *mut *mut libc::c_char;
                } else {
                    rc = sqlite3_step(pStmt);
                    sqlite3_finalize(pStmt);
                    preserveRowid = (rc == 100 as libc::c_int) as libc::c_int
                }
            }
            if preserveRowid != 0 {
                /* Only preserve the rowid if we can find a name to use for the
                 ** rowid */
                static mut azRowid: [*mut libc::c_char; 3] = [
                    b"rowid\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"_rowid_\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                    b"oid\x00" as *const u8 as *const libc::c_char as *mut libc::c_char,
                ];
                let mut i: libc::c_int = 0;
                let mut j: libc::c_int = 0;
                j = 0 as libc::c_int;
                while j < 3 as libc::c_int {
                    i = 1 as libc::c_int;
                    while i <= nCol {
                        if sqlite3_stricmp(azRowid[j as usize], *azCol.offset(i as isize))
                            == 0 as libc::c_int
                        {
                            break;
                        }
                        i += 1
                    }
                    if i > nCol {
                        /* At this point, we know that azRowid[j] is not the name of any
                         ** ordinary column in the table.  Verify that azRowid[j] is a valid
                         ** name for the rowid before adding it to azCol[0].  WITHOUT ROWID
                         ** tables will fail this last check */
                        rc = sqlite3_table_column_metadata(
                            (*p).db,
                            0 as *const libc::c_char,
                            zTab,
                            azRowid[j as usize],
                            0 as *mut *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                        );
                        if !(rc == 0 as libc::c_int) {
                            break;
                        }
                        let ref mut fresh62 = *azCol.offset(0 as libc::c_int as isize);
                        *fresh62 = azRowid[j as usize];
                        break;
                    } else {
                        j += 1
                    }
                }
            }
            return azCol;
        }
    };
}
/*
** Toggle the reverse_unordered_selects setting.
*/
unsafe extern "C" fn toggleSelectOrder(mut db: *mut sqlite3) {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut iSetting: libc::c_int = 0 as libc::c_int;
    let mut zStmt: [libc::c_char; 100] = [0; 100];
    sqlite3_prepare_v2(
        db,
        b"PRAGMA reverse_unordered_selects\x00" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        iSetting = sqlite3_column_int(pStmt, 0 as libc::c_int)
    }
    sqlite3_finalize(pStmt);
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
        zStmt.as_mut_ptr(),
        b"PRAGMA reverse_unordered_selects(%d)\x00" as *const u8 as *const libc::c_char,
        (iSetting == 0) as libc::c_int,
    );
    sqlite3_exec(
        db,
        zStmt.as_mut_ptr(),
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
}
/*
** This is a different callback routine used for dumping the database.
** Each row received by this callback consists of a table name,
** the table type ("index" or "table") and SQL to create the table.
** This routine should print text sufficient to recreate the table.
*/
unsafe extern "C" fn dump_callback(
    mut pArg: *mut libc::c_void,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut _azNotUsed: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zTable: *const libc::c_char = 0 as *const libc::c_char;
    let mut zType: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut dataOnly: libc::c_int = 0;
    let mut noSys: libc::c_int = 0;
    if nArg != 3 as libc::c_int || azArg.is_null() {
        return 0 as libc::c_int;
    } else {
        zTable = *azArg.offset(0 as libc::c_int as isize);
        zType = *azArg.offset(1 as libc::c_int as isize);
        zSql = *azArg.offset(2 as libc::c_int as isize);
        dataOnly = ((*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint) as libc::c_int;
        noSys = ((*p).shellFlgs & 0x200 as libc::c_int as libc::c_uint
            != 0 as libc::c_int as libc::c_uint) as libc::c_int;
        if strcmp(
            zTable,
            b"sqlite_sequence\x00" as *const u8 as *const libc::c_char,
        ) == 0 as libc::c_int
            && noSys == 0
        {
            if dataOnly == 0 {
                fprintf(
                    (*p).out,
                    b"DELETE FROM sqlite_sequence;\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        } else if sqlite3_strglob(
            b"sqlite_stat?\x00" as *const u8 as *const libc::c_char,
            zTable,
        ) == 0 as libc::c_int
            && noSys == 0
        {
            if dataOnly == 0 {
                fprintf(
                    (*p).out,
                    b"ANALYZE sqlite_schema;\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        } else if strncmp(
            zTable,
            b"sqlite_\x00" as *const u8 as *const libc::c_char,
            7 as libc::c_int as libc::c_ulong,
        ) == 0 as libc::c_int
        {
            return 0 as libc::c_int;
        } else if !(dataOnly != 0) {
            if strncmp(
                zSql,
                b"CREATE VIRTUAL TABLE\x00" as *const u8 as *const libc::c_char,
                20 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                let mut zIns: *mut libc::c_char = 0 as *mut libc::c_char;
                if (*p).writableSchema == 0 {
                    fprintf(
                        (*p).out,
                        b"PRAGMA writable_schema=ON;\n\x00" as *const u8 as *const libc::c_char,
                    );
                    (*p).writableSchema = 1 as libc::c_int
                }
                zIns =
                    sqlite3_mprintf(b"INSERT INTO sqlite_schema(type,name,tbl_name,rootpage,sql)VALUES(\'table\',\'%q\',\'%q\',0,\'%q\');\x00"
                                        as *const u8 as *const libc::c_char,
                                    zTable, zTable, zSql);
                fprintf(
                    (*p).out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    zIns,
                );
                sqlite3_free(zIns as *mut libc::c_void);
                return 0 as libc::c_int;
            } else {
                printSchemaLine(
                    (*p).out,
                    zSql,
                    b";\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        if strcmp(zType, b"table\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
            let mut sSelect: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            let mut sTable: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            let mut azCol: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
            let mut i: libc::c_int = 0;
            let mut savedDestTable: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut savedMode: libc::c_int = 0;
            azCol = tableColumnList(p, zTable);
            if azCol.is_null() {
                (*p).nErr += 1;
                return 0 as libc::c_int;
            } else {
                /* Always quote the table name, even if it appears to be pure ascii,
                 ** in case it is a keyword. Ex:  INSERT INTO "table" ... */
                initText(&mut sTable);
                appendText(&mut sTable, zTable, quoteChar(zTable));
                /* If preserving the rowid, add a column list after the table name.
                 ** In other words:  "INSERT INTO tab(rowid,a,b,c,...) VALUES(...)"
                 ** instead of the usual "INSERT INTO tab VALUES(...)".
                 */
                if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
                    appendText(
                        &mut sTable,
                        b"(\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    appendText(
                        &mut sTable,
                        *azCol.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_char,
                    );
                    i = 1 as libc::c_int;
                    while !(*azCol.offset(i as isize)).is_null() {
                        appendText(
                            &mut sTable,
                            b",\x00" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(
                            &mut sTable,
                            *azCol.offset(i as isize),
                            quoteChar(*azCol.offset(i as isize)),
                        );
                        i += 1
                    }
                    appendText(
                        &mut sTable,
                        b")\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                }
                /* Build an appropriate SELECT statement */
                initText(&mut sSelect);
                appendText(
                    &mut sSelect,
                    b"SELECT \x00" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                if !(*azCol.offset(0 as libc::c_int as isize)).is_null() {
                    appendText(
                        &mut sSelect,
                        *azCol.offset(0 as libc::c_int as isize),
                        0 as libc::c_int as libc::c_char,
                    );
                    appendText(
                        &mut sSelect,
                        b",\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                }
                i = 1 as libc::c_int;
                while !(*azCol.offset(i as isize)).is_null() {
                    appendText(
                        &mut sSelect,
                        *azCol.offset(i as isize),
                        quoteChar(*azCol.offset(i as isize)),
                    );
                    if !(*azCol.offset((i + 1 as libc::c_int) as isize)).is_null() {
                        appendText(
                            &mut sSelect,
                            b",\x00" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                    }
                    i += 1
                }
                freeColumnList(azCol);
                appendText(
                    &mut sSelect,
                    b" FROM \x00" as *const u8 as *const libc::c_char,
                    0 as libc::c_int as libc::c_char,
                );
                appendText(&mut sSelect, zTable, quoteChar(zTable));
                savedDestTable = (*p).zDestTable;
                savedMode = (*p).mode;
                (*p).zDestTable = sTable.z;
                (*p).cMode = 5 as libc::c_int;
                (*p).mode = (*p).cMode;
                rc = shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
                if rc & 0xff as libc::c_int == 11 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"/****** CORRUPTION ERROR *******/\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    toggleSelectOrder((*p).db);
                    shell_exec(p, sSelect.z, 0 as *mut *mut libc::c_char);
                    toggleSelectOrder((*p).db);
                }
                (*p).zDestTable = savedDestTable;
                (*p).mode = savedMode;
                freeText(&mut sTable);
                freeText(&mut sSelect);
                if rc != 0 {
                    (*p).nErr += 1
                }
            }
        }
        return 0 as libc::c_int;
        /* no-op */
    };
}
/*
** Run zQuery.  Use dump_callback() as the callback routine so that
** the contents of the query are output as SQL statements.
**
** If we get a SQLITE_CORRUPT error, rerun the query after appending
** "ORDER BY rowid DESC" to the end.
*/
unsafe extern "C" fn run_schema_dump_query(
    mut p: *mut ShellState,
    mut zQuery: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
    rc = sqlite3_exec(
        (*p).db,
        zQuery,
        Some(
            dump_callback
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: libc::c_int,
                    _: *mut *mut libc::c_char,
                    _: *mut *mut libc::c_char,
                ) -> libc::c_int,
        ),
        p as *mut libc::c_void,
        &mut zErr,
    );
    if rc == 11 as libc::c_int {
        let mut zQ2: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut len: libc::c_int = strlen30(zQuery);
        fprintf(
            (*p).out,
            b"/****** CORRUPTION ERROR *******/\n\x00" as *const u8 as *const libc::c_char,
        );
        if !zErr.is_null() {
            fprintf(
                (*p).out,
                b"/****** %s ******/\n\x00" as *const u8 as *const libc::c_char,
                zErr,
            );
            sqlite3_free(zErr as *mut libc::c_void);
            zErr = 0 as *mut libc::c_char
        }
        zQ2 = malloc((len + 100 as libc::c_int) as libc::c_ulong) as *mut libc::c_char;
        if zQ2.is_null() {
            return rc;
        } else {
            sqlite3_snprintf(
                len + 100 as libc::c_int,
                zQ2,
                b"%s ORDER BY rowid DESC\x00" as *const u8 as *const libc::c_char,
                zQuery,
            );
            rc = sqlite3_exec(
                (*p).db,
                zQ2,
                Some(
                    dump_callback
                        as unsafe extern "C" fn(
                            _: *mut libc::c_void,
                            _: libc::c_int,
                            _: *mut *mut libc::c_char,
                            _: *mut *mut libc::c_char,
                        ) -> libc::c_int,
                ),
                p as *mut libc::c_void,
                &mut zErr,
            );
            if rc != 0 {
                fprintf(
                    (*p).out,
                    b"/****** ERROR: %s ******/\n\x00" as *const u8 as *const libc::c_char,
                    zErr,
                );
            } else {
                rc = 11 as libc::c_int
            }
            sqlite3_free(zErr as *mut libc::c_void);
            free(zQ2 as *mut libc::c_void);
        }
    }
    return rc;
}
/*
** Text of help messages.
**
** The help text for each individual command begins with a line that starts
** with ".".  Subsequent lines are supplimental information.
**
** There must be two or more spaces between the end of the command and the
** start of the description of what that command does.
*/
static mut azHelp: [*const libc::c_char; 190] = [
    b".archive ...             Manage SQL archives\x00" as *const u8 as *const libc::c_char,
    b"   Each command must have exactly one of the following options:\x00" as *const u8
        as *const libc::c_char,
    b"     -c, --create               Create a new archive\x00" as *const u8 as *const libc::c_char,
    b"     -u, --update               Add or update files with changed mtime\x00" as *const u8
        as *const libc::c_char,
    b"     -i, --insert               Like -u but always add even if unchanged\x00" as *const u8
        as *const libc::c_char,
    b"     -t, --list                 List contents of archive\x00" as *const u8
        as *const libc::c_char,
    b"     -x, --extract              Extract files from archive\x00" as *const u8
        as *const libc::c_char,
    b"   Optional arguments:\x00" as *const u8 as *const libc::c_char,
    b"     -v, --verbose              Print each filename as it is processed\x00" as *const u8
        as *const libc::c_char,
    b"     -f FILE, --file FILE       Use archive FILE (default is current db)\x00" as *const u8
        as *const libc::c_char,
    b"     -a FILE, --append FILE     Open FILE using the apndvfs VFS\x00" as *const u8
        as *const libc::c_char,
    b"     -C DIR, --directory DIR    Read/extract files from directory DIR\x00" as *const u8
        as *const libc::c_char,
    b"     -n, --dryrun               Show the SQL that would have occurred\x00" as *const u8
        as *const libc::c_char,
    b"   Examples:\x00" as *const u8 as *const libc::c_char,
    b"     .ar -cf ARCHIVE foo bar  # Create ARCHIVE from files foo and bar\x00" as *const u8
        as *const libc::c_char,
    b"     .ar -tf ARCHIVE          # List members of ARCHIVE\x00" as *const u8
        as *const libc::c_char,
    b"     .ar -xvf ARCHIVE         # Verbosely extract files from ARCHIVE\x00" as *const u8
        as *const libc::c_char,
    b"   See also:\x00" as *const u8 as *const libc::c_char,
    b"      http://sqlite.org/cli.html#sqlite_archive_support\x00" as *const u8
        as *const libc::c_char,
    b".auth ON|OFF             Show authorizer callbacks\x00" as *const u8 as *const libc::c_char,
    b".backup ?DB? FILE        Backup DB (default \"main\") to FILE\x00" as *const u8
        as *const libc::c_char,
    b"       --append            Use the appendvfs\x00" as *const u8 as *const libc::c_char,
    b"       --async             Write to FILE without journal and fsync()\x00" as *const u8
        as *const libc::c_char,
    b".bail on|off             Stop after hitting an error.  Default OFF\x00" as *const u8
        as *const libc::c_char,
    b".binary on|off           Turn binary output on or off.  Default OFF\x00" as *const u8
        as *const libc::c_char,
    b".cd DIRECTORY            Change the working directory to DIRECTORY\x00" as *const u8
        as *const libc::c_char,
    b".changes on|off          Show number of rows changed by SQL\x00" as *const u8
        as *const libc::c_char,
    b".check GLOB              Fail if output since .testcase does not match\x00" as *const u8
        as *const libc::c_char,
    b".clone NEWDB             Clone data into NEWDB from the existing database\x00" as *const u8
        as *const libc::c_char,
    b".connection [close] [#]  Open or close an auxiliary database connection\x00" as *const u8
        as *const libc::c_char,
    b".databases               List names and files of attached databases\x00" as *const u8
        as *const libc::c_char,
    b".dbconfig ?op? ?val?     List or change sqlite3_db_config() options\x00" as *const u8
        as *const libc::c_char,
    b".dbinfo ?DB?             Show status information about the database\x00" as *const u8
        as *const libc::c_char,
    b".dump ?OBJECTS?          Render database content as SQL\x00" as *const u8
        as *const libc::c_char,
    b"   Options:\x00" as *const u8 as *const libc::c_char,
    b"     --data-only            Output only INSERT statements\x00" as *const u8
        as *const libc::c_char,
    b"     --newlines             Allow unescaped newline characters in output\x00" as *const u8
        as *const libc::c_char,
    b"     --nosys                Omit system tables (ex: \"sqlite_stat1\")\x00" as *const u8
        as *const libc::c_char,
    b"     --preserve-rowids      Include ROWID values in the output\x00" as *const u8
        as *const libc::c_char,
    b"   OBJECTS is a LIKE pattern for tables, indexes, triggers or views to dump\x00" as *const u8
        as *const libc::c_char,
    b"   Additional LIKE patterns can be given in subsequent arguments\x00" as *const u8
        as *const libc::c_char,
    b".echo on|off             Turn command echo on or off\x00" as *const u8 as *const libc::c_char,
    b".eqp on|off|full|...     Enable or disable automatic EXPLAIN QUERY PLAN\x00" as *const u8
        as *const libc::c_char,
    b"   Other Modes:\x00" as *const u8 as *const libc::c_char,
    b"      trigger               Like \"full\" but also show trigger bytecode\x00" as *const u8
        as *const libc::c_char,
    b".excel                   Display the output of next command in spreadsheet\x00" as *const u8
        as *const libc::c_char,
    b"   --bom                   Put a UTF8 byte-order mark on intermediate file\x00" as *const u8
        as *const libc::c_char,
    b".exit ?CODE?             Exit this program with return-code CODE\x00" as *const u8
        as *const libc::c_char,
    b".expert                  EXPERIMENTAL. Suggest indexes for queries\x00" as *const u8
        as *const libc::c_char,
    b".explain ?on|off|auto?   Change the EXPLAIN formatting mode.  Default: auto\x00" as *const u8
        as *const libc::c_char,
    b".filectrl CMD ...        Run various sqlite3_file_control() operations\x00" as *const u8
        as *const libc::c_char,
    b"   --schema SCHEMA         Use SCHEMA instead of \"main\"\x00" as *const u8
        as *const libc::c_char,
    b"   --help                  Show CMD details\x00" as *const u8 as *const libc::c_char,
    b".fullschema ?--indent?   Show schema and the content of sqlite_stat tables\x00" as *const u8
        as *const libc::c_char,
    b".headers on|off          Turn display of headers on or off\x00" as *const u8
        as *const libc::c_char,
    b".help ?-all? ?PATTERN?   Show help text for PATTERN\x00" as *const u8 as *const libc::c_char,
    b".import FILE TABLE       Import data from FILE into TABLE\x00" as *const u8
        as *const libc::c_char,
    b"   Options:\x00" as *const u8 as *const libc::c_char,
    b"     --ascii               Use \\037 and \\036 as column and row separators\x00" as *const u8
        as *const libc::c_char,
    b"     --csv                 Use , and \\n as column and row separators\x00" as *const u8
        as *const libc::c_char,
    b"     --skip N              Skip the first N rows of input\x00" as *const u8
        as *const libc::c_char,
    b"     -v                    \"Verbose\" - increase auxiliary output\x00" as *const u8
        as *const libc::c_char,
    b"   Notes:\x00" as *const u8 as *const libc::c_char,
    b"     *  If TABLE does not exist, it is created.  The first row of input\x00" as *const u8
        as *const libc::c_char,
    b"        determines the column names.\x00" as *const u8 as *const libc::c_char,
    b"     *  If neither --csv or --ascii are used, the input mode is derived\x00" as *const u8
        as *const libc::c_char,
    b"        from the \".mode\" output mode\x00" as *const u8 as *const libc::c_char,
    b"     *  If FILE begins with \"|\" then it is a command that generates the\x00" as *const u8
        as *const libc::c_char,
    b"        input text.\x00" as *const u8 as *const libc::c_char,
    b".imposter INDEX TABLE    Create imposter table TABLE on index INDEX\x00" as *const u8
        as *const libc::c_char,
    b".indexes ?TABLE?         Show names of indexes\x00" as *const u8 as *const libc::c_char,
    b"                           If TABLE is specified, only show indexes for\x00" as *const u8
        as *const libc::c_char,
    b"                           tables matching TABLE using the LIKE operator.\x00" as *const u8
        as *const libc::c_char,
    b".limit ?LIMIT? ?VAL?     Display or change the value of an SQLITE_LIMIT\x00" as *const u8
        as *const libc::c_char,
    b".lint OPTIONS            Report potential schema issues.\x00" as *const u8
        as *const libc::c_char,
    b"     Options:\x00" as *const u8 as *const libc::c_char,
    b"        fkey-indexes     Find missing foreign key indexes\x00" as *const u8
        as *const libc::c_char,
    b".load FILE ?ENTRY?       Load an extension library\x00" as *const u8 as *const libc::c_char,
    b".log FILE|off            Turn logging on or off.  FILE can be stderr/stdout\x00" as *const u8
        as *const libc::c_char,
    b".mode MODE ?TABLE?       Set output mode\x00" as *const u8 as *const libc::c_char,
    b"   MODE is one of:\x00" as *const u8 as *const libc::c_char,
    b"     ascii     Columns/rows delimited by 0x1F and 0x1E\x00" as *const u8
        as *const libc::c_char,
    b"     box       Tables using unicode box-drawing characters\x00" as *const u8
        as *const libc::c_char,
    b"     csv       Comma-separated values\x00" as *const u8 as *const libc::c_char,
    b"     column    Output in columns.  (See .width)\x00" as *const u8 as *const libc::c_char,
    b"     html      HTML <table> code\x00" as *const u8 as *const libc::c_char,
    b"     insert    SQL insert statements for TABLE\x00" as *const u8 as *const libc::c_char,
    b"     json      Results in a JSON array\x00" as *const u8 as *const libc::c_char,
    b"     line      One value per line\x00" as *const u8 as *const libc::c_char,
    b"     list      Values delimited by \"|\"\x00" as *const u8 as *const libc::c_char,
    b"     markdown  Markdown table format\x00" as *const u8 as *const libc::c_char,
    b"     quote     Escape answers as for SQL\x00" as *const u8 as *const libc::c_char,
    b"     table     ASCII-art table\x00" as *const u8 as *const libc::c_char,
    b"     tabs      Tab-separated values\x00" as *const u8 as *const libc::c_char,
    b"     tcl       TCL list elements\x00" as *const u8 as *const libc::c_char,
    b".nonce STRING            Disable safe mode for one command if the nonce matches\x00"
        as *const u8 as *const libc::c_char,
    b".nullvalue STRING        Use STRING in place of NULL values\x00" as *const u8
        as *const libc::c_char,
    b".once ?OPTIONS? ?FILE?   Output for the next SQL command only to FILE\x00" as *const u8
        as *const libc::c_char,
    b"     If FILE begins with \'|\' then open as a pipe\x00" as *const u8 as *const libc::c_char,
    b"       --bom  Put a UTF8 byte-order mark at the beginning\x00" as *const u8
        as *const libc::c_char,
    b"       -e     Send output to the system text editor\x00" as *const u8 as *const libc::c_char,
    b"       -x     Send output as CSV to a spreadsheet (same as \".excel\")\x00" as *const u8
        as *const libc::c_char,
    b".open ?OPTIONS? ?FILE?   Close existing database and reopen FILE\x00" as *const u8
        as *const libc::c_char,
    b"     Options:\x00" as *const u8 as *const libc::c_char,
    b"        --append        Use appendvfs to append database to the end of FILE\x00" as *const u8
        as *const libc::c_char,
    b"        --deserialize   Load into memory using sqlite3_deserialize()\x00" as *const u8
        as *const libc::c_char,
    b"        --hexdb         Load the output of \"dbtotxt\" as an in-memory db\x00" as *const u8
        as *const libc::c_char,
    b"        --maxsize N     Maximum size for --hexdb or --deserialized database\x00" as *const u8
        as *const libc::c_char,
    b"        --new           Initialize FILE to an empty database\x00" as *const u8
        as *const libc::c_char,
    b"        --nofollow      Do not follow symbolic links\x00" as *const u8 as *const libc::c_char,
    b"        --readonly      Open FILE readonly\x00" as *const u8 as *const libc::c_char,
    b"        --zip           FILE is a ZIP archive\x00" as *const u8 as *const libc::c_char,
    b".output ?FILE?           Send output to FILE or stdout if FILE is omitted\x00" as *const u8
        as *const libc::c_char,
    b"   If FILE begins with \'|\' then open it as a pipe.\x00" as *const u8 as *const libc::c_char,
    b"   Options:\x00" as *const u8 as *const libc::c_char,
    b"     --bom                 Prefix output with a UTF8 byte-order mark\x00" as *const u8
        as *const libc::c_char,
    b"     -e                    Send output to the system text editor\x00" as *const u8
        as *const libc::c_char,
    b"     -x                    Send output as CSV to a spreadsheet\x00" as *const u8
        as *const libc::c_char,
    b".parameter CMD ...       Manage SQL parameter bindings\x00" as *const u8
        as *const libc::c_char,
    b"   clear                   Erase all bindings\x00" as *const u8 as *const libc::c_char,
    b"   init                    Initialize the TEMP table that holds bindings\x00" as *const u8
        as *const libc::c_char,
    b"   list                    List the current parameter bindings\x00" as *const u8
        as *const libc::c_char,
    b"   set PARAMETER VALUE     Given SQL parameter PARAMETER a value of VALUE\x00" as *const u8
        as *const libc::c_char,
    b"                           PARAMETER should start with one of: $ : @ ?\x00" as *const u8
        as *const libc::c_char,
    b"   unset PARAMETER         Remove PARAMETER from the binding table\x00" as *const u8
        as *const libc::c_char,
    b".print STRING...         Print literal STRING\x00" as *const u8 as *const libc::c_char,
    b".progress N              Invoke progress handler after every N opcodes\x00" as *const u8
        as *const libc::c_char,
    b"   --limit N                 Interrupt after N progress callbacks\x00" as *const u8
        as *const libc::c_char,
    b"   --once                    Do no more than one progress interrupt\x00" as *const u8
        as *const libc::c_char,
    b"   --quiet|-q                No output except at interrupts\x00" as *const u8
        as *const libc::c_char,
    b"   --reset                   Reset the count for each input and interrupt\x00" as *const u8
        as *const libc::c_char,
    b".prompt MAIN CONTINUE    Replace the standard prompts\x00" as *const u8
        as *const libc::c_char,
    b".quit                    Exit this program\x00" as *const u8 as *const libc::c_char,
    b".read FILE               Read input from FILE\x00" as *const u8 as *const libc::c_char,
    b".recover                 Recover as much data as possible from corrupt db.\x00" as *const u8
        as *const libc::c_char,
    b"   --freelist-corrupt       Assume the freelist is corrupt\x00" as *const u8
        as *const libc::c_char,
    b"   --recovery-db NAME       Store recovery metadata in database file NAME\x00" as *const u8
        as *const libc::c_char,
    b"   --lost-and-found TABLE   Alternative name for the lost-and-found table\x00" as *const u8
        as *const libc::c_char,
    b"   --no-rowids              Do not attempt to recover rowid values\x00" as *const u8
        as *const libc::c_char,
    b"                            that are not also INTEGER PRIMARY KEYs\x00" as *const u8
        as *const libc::c_char,
    b".restore ?DB? FILE       Restore content of DB (default \"main\") from FILE\x00" as *const u8
        as *const libc::c_char,
    b".save FILE               Write in-memory database into FILE\x00" as *const u8
        as *const libc::c_char,
    b".scanstats on|off        Turn sqlite3_stmt_scanstatus() metrics on or off\x00" as *const u8
        as *const libc::c_char,
    b".schema ?PATTERN?        Show the CREATE statements matching PATTERN\x00" as *const u8
        as *const libc::c_char,
    b"   Options:\x00" as *const u8 as *const libc::c_char,
    b"      --indent             Try to pretty-print the schema\x00" as *const u8
        as *const libc::c_char,
    b"      --nosys              Omit objects whose names start with \"sqlite_\"\x00" as *const u8
        as *const libc::c_char,
    b".selftest ?OPTIONS?      Run tests defined in the SELFTEST table\x00" as *const u8
        as *const libc::c_char,
    b"    Options:\x00" as *const u8 as *const libc::c_char,
    b"       --init               Create a new SELFTEST table\x00" as *const u8
        as *const libc::c_char,
    b"       -v                   Verbose output\x00" as *const u8 as *const libc::c_char,
    b".separator COL ?ROW?     Change the column and row separators\x00" as *const u8
        as *const libc::c_char,
    b".sha3sum ...             Compute a SHA3 hash of database content\x00" as *const u8
        as *const libc::c_char,
    b"    Options:\x00" as *const u8 as *const libc::c_char,
    b"      --schema              Also hash the sqlite_schema table\x00" as *const u8
        as *const libc::c_char,
    b"      --sha3-224            Use the sha3-224 algorithm\x00" as *const u8
        as *const libc::c_char,
    b"      --sha3-256            Use the sha3-256 algorithm (default)\x00" as *const u8
        as *const libc::c_char,
    b"      --sha3-384            Use the sha3-384 algorithm\x00" as *const u8
        as *const libc::c_char,
    b"      --sha3-512            Use the sha3-512 algorithm\x00" as *const u8
        as *const libc::c_char,
    b"    Any other argument is a LIKE pattern for tables to hash\x00" as *const u8
        as *const libc::c_char,
    b".shell CMD ARGS...       Run CMD ARGS... in a system shell\x00" as *const u8
        as *const libc::c_char,
    b".show                    Show the current values for various settings\x00" as *const u8
        as *const libc::c_char,
    b".stats ?ARG?             Show stats or turn stats on or off\x00" as *const u8
        as *const libc::c_char,
    b"   off                      Turn off automatic stat display\x00" as *const u8
        as *const libc::c_char,
    b"   on                       Turn on automatic stat display\x00" as *const u8
        as *const libc::c_char,
    b"   stmt                     Show statement stats\x00" as *const u8 as *const libc::c_char,
    b"   vmstep                   Show the virtual machine step count only\x00" as *const u8
        as *const libc::c_char,
    b".system CMD ARGS...      Run CMD ARGS... in a system shell\x00" as *const u8
        as *const libc::c_char,
    b".tables ?TABLE?          List names of tables matching LIKE pattern TABLE\x00" as *const u8
        as *const libc::c_char,
    b".testcase NAME           Begin redirecting output to \'testcase-out.txt\'\x00" as *const u8
        as *const libc::c_char,
    b".testctrl CMD ...        Run various sqlite3_test_control() operations\x00" as *const u8
        as *const libc::c_char,
    b"                           Run \".testctrl\" with no arguments for details\x00" as *const u8
        as *const libc::c_char,
    b".timeout MS              Try opening locked tables for MS milliseconds\x00" as *const u8
        as *const libc::c_char,
    b".timer on|off            Turn SQL timer on or off\x00" as *const u8 as *const libc::c_char,
    b".trace ?OPTIONS?         Output each SQL statement as it is run\x00" as *const u8
        as *const libc::c_char,
    b"    FILE                    Send output to FILE\x00" as *const u8 as *const libc::c_char,
    b"    stdout                  Send output to stdout\x00" as *const u8 as *const libc::c_char,
    b"    stderr                  Send output to stderr\x00" as *const u8 as *const libc::c_char,
    b"    off                     Disable tracing\x00" as *const u8 as *const libc::c_char,
    b"    --expanded              Expand query parameters\x00" as *const u8 as *const libc::c_char,
    b"    --plain                 Show SQL as it is input\x00" as *const u8 as *const libc::c_char,
    b"    --stmt                  Trace statement execution (SQLITE_TRACE_STMT)\x00" as *const u8
        as *const libc::c_char,
    b"    --profile               Profile statements (SQLITE_TRACE_PROFILE)\x00" as *const u8
        as *const libc::c_char,
    b"    --row                   Trace each row (SQLITE_TRACE_ROW)\x00" as *const u8
        as *const libc::c_char,
    b"    --close                 Trace connection close (SQLITE_TRACE_CLOSE)\x00" as *const u8
        as *const libc::c_char,
    b".vfsinfo ?AUX?           Information about the top-level VFS\x00" as *const u8
        as *const libc::c_char,
    b".vfslist                 List all available VFSes\x00" as *const u8 as *const libc::c_char,
    b".vfsname ?AUX?           Print the name of the VFS stack\x00" as *const u8
        as *const libc::c_char,
    b".width NUM1 NUM2 ...     Set minimum column widths for columnar output\x00" as *const u8
        as *const libc::c_char,
    b"     Negative values right-justify\x00" as *const u8 as *const libc::c_char,
];
/*
** Output help text.
**
** zPattern describes the set of commands for which help text is provided.
** If zPattern is NULL, then show all commands, but only give a one-line
** description of each.
**
** Return the number of matches.
*/
unsafe extern "C" fn showHelp(
    mut out: *mut FILE,
    mut zPattern: *const libc::c_char,
) -> libc::c_int {
    let mut i: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut zPat: *mut libc::c_char = 0 as *mut libc::c_char;
    if zPattern.is_null()
        || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        || strcmp(zPattern, b"-a\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || strcmp(zPattern, b"-all\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
        || strcmp(zPattern, b"--all\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        /* Show all commands, but only one line per command */
        if zPattern.is_null() {
            zPattern = b"\x00" as *const u8 as *const libc::c_char
        }
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 190]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                as libc::c_int
        {
            if *azHelp[i as usize].offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                || *zPattern.offset(0 as libc::c_int as isize) as libc::c_int != 0
            {
                fprintf(
                    out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                n += 1
            }
            i += 1
        }
    } else {
        /* Look for commands that for which zPattern is an exact prefix */
        zPat = sqlite3_mprintf(b".%s*\x00" as *const u8 as *const libc::c_char, zPattern);
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[*const libc::c_char; 190]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                as libc::c_int
        {
            if sqlite3_strglob(zPat, azHelp[i as usize]) == 0 as libc::c_int {
                fprintf(
                    out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    azHelp[i as usize],
                );
                j = i + 1 as libc::c_int;
                n += 1
            }
            i += 1
        }
        sqlite3_free(zPat as *mut libc::c_void);
        if n != 0 {
            if n == 1 as libc::c_int {
                /* when zPattern is a prefix of exactly one command, then include the
                 ** details of that command, which should begin at offset j */
                while j
                    < (::std::mem::size_of::<[*const libc::c_char; 190]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int
                    && *azHelp[j as usize].offset(0 as libc::c_int as isize) as libc::c_int
                        != '.' as i32
                {
                    fprintf(
                        out,
                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    j += 1
                }
            }
            return n;
        } else {
            /* Look for commands that contain zPattern anywhere.  Show the complete
             ** text of all commands that match. */
            zPat = sqlite3_mprintf(b"%%%s%%\x00" as *const u8 as *const libc::c_char, zPattern);
            i = 0 as libc::c_int;
            while i
                < (::std::mem::size_of::<[*const libc::c_char; 190]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong)
                    as libc::c_int
            {
                if *azHelp[i as usize].offset(0 as libc::c_int as isize) as libc::c_int
                    == '.' as i32
                {
                    j = i
                }
                if sqlite3_strlike(zPat, azHelp[i as usize], 0 as libc::c_int as libc::c_uint)
                    == 0 as libc::c_int
                {
                    fprintf(
                        out,
                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                        azHelp[j as usize],
                    );
                    while j
                        < (::std::mem::size_of::<[*const libc::c_char; 190]>() as libc::c_ulong)
                            .wrapping_div(
                                ::std::mem::size_of::<*const libc::c_char>() as libc::c_ulong
                            ) as libc::c_int
                            - 1 as libc::c_int
                        && *azHelp[(j + 1 as libc::c_int) as usize]
                            .offset(0 as libc::c_int as isize)
                            as libc::c_int
                            != '.' as i32
                    {
                        j += 1;
                        fprintf(
                            out,
                            b"%s\n\x00" as *const u8 as *const libc::c_char,
                            azHelp[j as usize],
                        );
                    }
                    i = j;
                    n += 1
                }
                i += 1
            }
            sqlite3_free(zPat as *mut libc::c_void);
        }
    }
    return n;
}
/*
** Read the content of file zName into memory obtained from sqlite3_malloc64()
** and return a pointer to the buffer. The caller is responsible for freeing
** the memory.
**
** If parameter pnByte is not NULL, (*pnByte) is set to the number of bytes
** read.
**
** For convenience, a nul-terminator byte is always appended to the data read
** from the file before the buffer is returned. This byte is not included in
** the final value of (*pnByte), if applicable.
**
** NULL is returned if any error is encountered. The final value of *pnByte
** is undefined in this case.
*/
unsafe extern "C" fn readFile(
    mut zName: *const libc::c_char,
    mut pnByte: *mut libc::c_int,
) -> *mut libc::c_char {
    let mut in_0: *mut FILE = fopen(zName, b"rb\x00" as *const u8 as *const libc::c_char);
    let mut nIn: libc::c_long = 0;
    let mut nRead: size_t = 0;
    let mut pBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    if in_0.is_null() {
        return 0 as *mut libc::c_char;
    } else {
        fseek(in_0, 0 as libc::c_int as libc::c_long, 2 as libc::c_int);
        nIn = ftell(in_0);
        rewind(in_0);
        pBuf = sqlite3_malloc64((nIn + 1 as libc::c_int as libc::c_long) as sqlite3_uint64)
            as *mut libc::c_char;
        if pBuf.is_null() {
            fclose(in_0);
            return 0 as *mut libc::c_char;
        } else {
            nRead = fread(
                pBuf as *mut libc::c_void,
                nIn as libc::c_ulong,
                1 as libc::c_int as libc::c_ulong,
                in_0,
            );
            fclose(in_0);
            if nRead != 1 as libc::c_int as libc::c_ulong {
                sqlite3_free(pBuf as *mut libc::c_void);
                return 0 as *mut libc::c_char;
            } else {
                *pBuf.offset(nIn as isize) = 0 as libc::c_int as libc::c_char;
                if !pnByte.is_null() {
                    *pnByte = nIn as libc::c_int
                }
                return pBuf;
            }
        }
    };
}
/*
** Close all OpenSession objects and release all associated resources.
*/
/*
** Implementation of the xFilter function for an open session.  Omit
** any tables named by ".session filter" but let all other table through.
*/
/*
** Try to deduce the type of file for zName based on its content.  Return
** one of the SHELL_OPEN_* constants.
**
** If the file does not exist or is empty but its name looks like a ZIP
** archive and the dfltZip flag is true, then assume it is a ZIP archive.
** Otherwise, assume an ordinary database regardless of the filename if
** the type cannot be determined from content.
*/
pub unsafe extern "C" fn deduceDatabaseType(
    mut zName: *const libc::c_char,
    mut dfltZip: libc::c_int,
) -> libc::c_int {
    let mut f: *mut FILE = fopen(zName, b"rb\x00" as *const u8 as *const libc::c_char);
    let mut n: size_t = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zBuf: [libc::c_char; 100] = [0; 100];
    if f.is_null() {
        if dfltZip != 0
            && sqlite3_strlike(
                b"%.zip\x00" as *const u8 as *const libc::c_char,
                zName,
                0 as libc::c_int as libc::c_uint,
            ) == 0 as libc::c_int
        {
            return 3 as libc::c_int;
        } else {
            return 1 as libc::c_int;
        }
    } else {
        n = fread(
            zBuf.as_mut_ptr() as *mut libc::c_void,
            16 as libc::c_int as libc::c_ulong,
            1 as libc::c_int as libc::c_ulong,
            f,
        );
        if n == 1 as libc::c_int as libc::c_ulong
            && memcmp(
                zBuf.as_mut_ptr() as *const libc::c_void,
                b"SQLite format 3\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                16 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            fclose(f);
            return 1 as libc::c_int;
        } else {
            fseek(f, -(25 as libc::c_int) as libc::c_long, 2 as libc::c_int);
            n = fread(
                zBuf.as_mut_ptr() as *mut libc::c_void,
                25 as libc::c_int as libc::c_ulong,
                1 as libc::c_int as libc::c_ulong,
                f,
            );
            if n == 1 as libc::c_int as libc::c_ulong
                && memcmp(
                    zBuf.as_mut_ptr() as *const libc::c_void,
                    b"Start-Of-SQLite3-\x00" as *const u8 as *const libc::c_char
                        as *const libc::c_void,
                    17 as libc::c_int as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                rc = 2 as libc::c_int
            } else {
                fseek(f, -(22 as libc::c_int) as libc::c_long, 2 as libc::c_int);
                n = fread(
                    zBuf.as_mut_ptr() as *mut libc::c_void,
                    22 as libc::c_int as libc::c_ulong,
                    1 as libc::c_int as libc::c_ulong,
                    f,
                );
                if n == 1 as libc::c_int as libc::c_ulong
                    && zBuf[0 as libc::c_int as usize] as libc::c_int == 0x50 as libc::c_int
                    && zBuf[1 as libc::c_int as usize] as libc::c_int == 0x4b as libc::c_int
                    && zBuf[2 as libc::c_int as usize] as libc::c_int == 0x5 as libc::c_int
                    && zBuf[3 as libc::c_int as usize] as libc::c_int == 0x6 as libc::c_int
                {
                    rc = 3 as libc::c_int
                } else if n == 0 as libc::c_int as libc::c_ulong
                    && dfltZip != 0
                    && sqlite3_strlike(
                        b"%.zip\x00" as *const u8 as *const libc::c_char,
                        zName,
                        0 as libc::c_int as libc::c_uint,
                    ) == 0 as libc::c_int
                {
                    rc = 3 as libc::c_int
                }
            }
            fclose(f);
            return rc;
        }
    };
}
/*
** Reconstruct an in-memory database using the output from the "dbtotxt"
** program.  Read content from the file in p->aAuxDb[].zDbFilename.
** If p->aAuxDb[].zDbFilename is 0, then read from standard input.
*/
unsafe extern "C" fn readHexDb(
    mut p: *mut ShellState,
    mut pnData: *mut libc::c_int,
) -> *mut libc::c_uchar {
    let mut a: *mut libc::c_uchar = 0 as *mut libc::c_uchar; /* Round n up to the next multiple of pgsz */
    let mut nLine: libc::c_int = 0;
    let mut n: libc::c_int = 0 as libc::c_int;
    let mut pgsz: libc::c_int = 0 as libc::c_int;
    let mut iOffset: libc::c_int = 0 as libc::c_int;
    let mut j: libc::c_int = 0;
    let mut k: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut in_0: *mut FILE = 0 as *mut FILE;
    let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
    let mut x: [libc::c_uint; 16] = [0; 16];
    let mut zLine: [libc::c_char; 1000] = [0; 1000];
    if !zDbFilename.is_null() {
        in_0 = fopen(zDbFilename, b"r\x00" as *const u8 as *const libc::c_char);
        if in_0.is_null() {
            fprintf(
                stderr,
                b"cannot open \"%s\" for reading\n\x00" as *const u8 as *const libc::c_char,
                zDbFilename,
            );
            return 0 as *mut libc::c_uchar;
        } else {
            nLine = 0 as libc::c_int
        }
    } else {
        in_0 = (*p).in_0;
        nLine = (*p).lineno;
        if in_0.is_null() {
            in_0 = stdin
        }
    }
    *pnData = 0 as libc::c_int;
    nLine += 1;
    if !fgets(
        zLine.as_mut_ptr(),
        ::std::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong as libc::c_int,
        in_0,
    )
    .is_null()
    {
        rc = sscanf(
            zLine.as_mut_ptr(),
            b"| size %d pagesize %d\x00" as *const u8 as *const libc::c_char,
            &mut n as *mut libc::c_int,
            &mut pgsz as *mut libc::c_int,
        );
        if !(rc != 2 as libc::c_int) {
            if !(n < 0 as libc::c_int) {
                if !(pgsz < 512 as libc::c_int
                    || pgsz > 65536 as libc::c_int
                    || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int)
                {
                    n = n + pgsz - 1 as libc::c_int & !(pgsz - 1 as libc::c_int);
                    a = sqlite3_malloc(if n != 0 { n } else { 1 as libc::c_int })
                        as *mut libc::c_uchar;
                    if a.is_null() {
                        fprintf(
                            stderr,
                            b"Out of memory!\n\x00" as *const u8 as *const libc::c_char,
                        );
                    } else {
                        memset(a as *mut libc::c_void, 0 as libc::c_int, n as libc::c_ulong);
                        if pgsz < 512 as libc::c_int
                            || pgsz > 65536 as libc::c_int
                            || pgsz & pgsz - 1 as libc::c_int != 0 as libc::c_int
                        {
                            fprintf(
                                stderr,
                                b"invalid pagesize\n\x00" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            nLine += 1;
                            while !fgets(
                                zLine.as_mut_ptr(),
                                ::std::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong
                                    as libc::c_int,
                                in_0,
                            )
                            .is_null()
                            {
                                rc = sscanf(
                                    zLine.as_mut_ptr(),
                                    b"| page %d offset %d\x00" as *const u8 as *const libc::c_char,
                                    &mut j as *mut libc::c_int,
                                    &mut k as *mut libc::c_int,
                                );
                                if rc == 2 as libc::c_int {
                                    iOffset = k
                                } else {
                                    if strncmp(
                                        zLine.as_mut_ptr(),
                                        b"| end \x00" as *const u8 as *const libc::c_char,
                                        6 as libc::c_int as libc::c_ulong,
                                    ) == 0 as libc::c_int
                                    {
                                        break;
                                    }
                                    rc = sscanf(
                                        zLine.as_mut_ptr(),
                                        b"| %d: %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\x00"
                                            as *const u8
                                            as *const libc::c_char,
                                        &mut j as *mut libc::c_int,
                                        &mut *x.as_mut_ptr().offset(0 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(1 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(2 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(3 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(4 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(5 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(6 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(7 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(8 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(9 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(10 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(11 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(12 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(13 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(14 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                        &mut *x.as_mut_ptr().offset(15 as libc::c_int as isize)
                                            as *mut libc::c_uint,
                                    );
                                    if rc == 17 as libc::c_int {
                                        k = iOffset + j;
                                        if k + 16 as libc::c_int <= n && k >= 0 as libc::c_int {
                                            let mut ii: libc::c_int = 0;
                                            ii = 0 as libc::c_int;
                                            while ii < 16 as libc::c_int {
                                                *a.offset((k + ii) as isize) = (x[ii as usize]
                                                    & 0xff as libc::c_int as libc::c_uint)
                                                    as libc::c_uchar;
                                                ii += 1
                                            }
                                        }
                                    }
                                }
                                nLine += 1
                            }
                            *pnData = n;
                            if in_0 != (*p).in_0 {
                                fclose(in_0);
                            } else {
                                (*p).lineno = nLine
                            }
                            return a;
                        }
                    }
                }
            }
        }
    }
    if in_0 != (*p).in_0 {
        fclose(in_0);
    } else {
        while !fgets(
            zLine.as_mut_ptr(),
            ::std::mem::size_of::<[libc::c_char; 1000]>() as libc::c_ulong as libc::c_int,
            (*p).in_0,
        )
        .is_null()
        {
            nLine += 1;
            if strncmp(
                zLine.as_mut_ptr(),
                b"| end \x00" as *const u8 as *const libc::c_char,
                6 as libc::c_int as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                break;
            }
        }
        (*p).lineno = nLine
    }
    sqlite3_free(a as *mut libc::c_void);
    fprintf(
        stderr,
        b"Error on line %d of --hexdb input\n\x00" as *const u8 as *const libc::c_char,
        nLine,
    );
    return 0 as *mut libc::c_uchar;
}
/* SQLITE_OMIT_DESERIALIZE */
/*
** Scalar function "shell_int32". The first argument to this function
** must be a blob. The second a non-negative integer. This function
** reads and returns a 32-bit big-endian integer from byte
** offset (4*<arg2>) of the blob.
*/
unsafe extern "C" fn shellInt32(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut pBlob: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut nBlob: libc::c_int = 0;
    let mut iInt: libc::c_int = 0;
    nBlob = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
    pBlob = sqlite3_value_blob(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_uchar;
    iInt = sqlite3_value_int(*argv.offset(1 as libc::c_int as isize));
    if iInt >= 0 as libc::c_int && (iInt + 1 as libc::c_int) * 4 as libc::c_int <= nBlob {
        let mut a: *const libc::c_uchar =
            &*pBlob.offset((iInt * 4 as libc::c_int) as isize) as *const libc::c_uchar;
        let mut iVal: sqlite3_int64 = ((*a.offset(0 as libc::c_int as isize) as sqlite3_int64)
            << 24 as libc::c_int)
            + ((*a.offset(1 as libc::c_int as isize) as sqlite3_int64) << 16 as libc::c_int)
            + ((*a.offset(2 as libc::c_int as isize) as sqlite3_int64) << 8 as libc::c_int)
            + ((*a.offset(3 as libc::c_int as isize) as sqlite3_int64) << 0 as libc::c_int);
        sqlite3_result_int64(context, iVal);
    };
}
/*
** Scalar function "shell_idquote(X)" returns string X quoted as an identifier,
** using "..." with internal double-quote characters doubled.
*/
unsafe extern "C" fn shellIdQuote(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zName: *const libc::c_char =
        sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    if !zName.is_null() {
        let mut z: *mut libc::c_char =
            sqlite3_mprintf(b"\"%w\"\x00" as *const u8 as *const libc::c_char, zName);
        sqlite3_result_text(
            context,
            z,
            -(1 as libc::c_int),
            Some(sqlite3_free as unsafe extern "C" fn(_: *mut libc::c_void) -> ()),
        );
    };
}
/*
** Scalar function "usleep(X)" invokes sqlite3_sleep(X) and returns X.
*/
unsafe extern "C" fn shellUSleepFunc(
    mut context: *mut sqlite3_context,
    mut _argcUnused: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut sleep: libc::c_int = sqlite3_value_int(*argv.offset(0 as libc::c_int as isize));
    sqlite3_sleep(sleep / 1000 as libc::c_int);
    sqlite3_result_int(context, sleep);
}
/*
** Scalar function "shell_escape_crnl" used by the .recover command.
** The argument passed to this function is the output of built-in
** function quote(). If the first character of the input is "'",
** indicating that the value passed to quote() was a text value,
** then this function searches the input for "\n" and "\r" characters
** and adds a wrapper similar to the following:
**
**   replace(replace(<input>, '\n', char(10), '\r', char(13));
**
** Or, if the first character of the input is not "'", then a copy
** of the input is returned.
*/
unsafe extern "C" fn shellEscapeCrnl(
    mut context: *mut sqlite3_context,
    mut _argc: libc::c_int,
    mut argv: *mut *mut sqlite3_value,
) {
    let mut zText: *const libc::c_char =
        sqlite3_value_text(*argv.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    if *zText.offset(0 as libc::c_int as isize) as libc::c_int == '\'' as i32 {
        let mut nText: libc::c_int = sqlite3_value_bytes(*argv.offset(0 as libc::c_int as isize));
        let mut i: libc::c_int = 0;
        let mut zBuf1: [libc::c_char; 20] = [0; 20];
        let mut zBuf2: [libc::c_char; 20] = [0; 20];
        let mut zNL: *const libc::c_char = 0 as *const libc::c_char;
        let mut zCR: *const libc::c_char = 0 as *const libc::c_char;
        let mut nCR: libc::c_int = 0 as libc::c_int;
        let mut nNL: libc::c_int = 0 as libc::c_int;
        i = 0 as libc::c_int;
        while *zText.offset(i as isize) != 0 {
            if zNL.is_null() && *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                zNL = unused_string(
                    zText,
                    b"\\n\x00" as *const u8 as *const libc::c_char,
                    b"\\012\x00" as *const u8 as *const libc::c_char,
                    zBuf1.as_mut_ptr(),
                );
                nNL = strlen(zNL) as libc::c_int
            }
            if zCR.is_null() && *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                zCR = unused_string(
                    zText,
                    b"\\r\x00" as *const u8 as *const libc::c_char,
                    b"\\015\x00" as *const u8 as *const libc::c_char,
                    zBuf2.as_mut_ptr(),
                );
                nCR = strlen(zCR) as libc::c_int
            }
            i += 1
        }
        if !zNL.is_null() || !zCR.is_null() {
            let mut iOut: libc::c_int = 0 as libc::c_int;
            let mut nMax: i64_0 = if nNL > nCR { nNL } else { nCR } as i64_0;
            let mut nAlloc: i64_0 = nMax * nText as libc::c_longlong
                + (nMax + 64 as libc::c_int as libc::c_longlong)
                    * 2 as libc::c_int as libc::c_longlong;
            let mut zOut: *mut libc::c_char =
                sqlite3_malloc64(nAlloc as sqlite3_uint64) as *mut libc::c_char;
            if zOut.is_null() {
                sqlite3_result_error_nomem(context);
                return;
            } else {
                if !zNL.is_null() && !zCR.is_null() {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b"replace(replace(\x00" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        16 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 16 as libc::c_int
                } else {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b"replace(\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                        8 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 8 as libc::c_int
                }
                i = 0 as libc::c_int;
                while *zText.offset(i as isize) != 0 {
                    if *zText.offset(i as isize) as libc::c_int == '\n' as i32 {
                        memcpy(
                            &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                                as *mut libc::c_void,
                            zNL as *const libc::c_void,
                            nNL as libc::c_ulong,
                        );
                        iOut += nNL
                    } else if *zText.offset(i as isize) as libc::c_int == '\r' as i32 {
                        memcpy(
                            &mut *zOut.offset(iOut as isize) as *mut libc::c_char
                                as *mut libc::c_void,
                            zCR as *const libc::c_void,
                            nCR as libc::c_ulong,
                        );
                        iOut += nCR
                    } else {
                        *zOut.offset(iOut as isize) = *zText.offset(i as isize);
                        iOut += 1
                    }
                    i += 1
                }
                if !zNL.is_null() {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b",\'\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                        2 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 2 as libc::c_int;
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        zNL as *const libc::c_void,
                        nNL as libc::c_ulong,
                    );
                    iOut += nNL;
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b"\', char(10))\x00" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        12 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 12 as libc::c_int
                }
                if !zCR.is_null() {
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b",\'\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                        2 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 2 as libc::c_int;
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        zCR as *const libc::c_void,
                        nCR as libc::c_ulong,
                    );
                    iOut += nCR;
                    memcpy(
                        &mut *zOut.offset(iOut as isize) as *mut libc::c_char as *mut libc::c_void,
                        b"\', char(13))\x00" as *const u8 as *const libc::c_char
                            as *const libc::c_void,
                        12 as libc::c_int as libc::c_ulong,
                    );
                    iOut += 12 as libc::c_int
                }
                sqlite3_result_text(
                    context,
                    zOut,
                    iOut,
                    ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                        -(1 as libc::c_int) as libc::intptr_t,
                    ),
                );
                sqlite3_free(zOut as *mut libc::c_void);
                return;
            }
        }
    }
    sqlite3_result_value(context, *argv.offset(0 as libc::c_int as isize));
}
/* Open as ZIP if name matches *.zip */
/*
** Make sure the database is open.  If it is not, then open it.  If
** the database fails to open, print an error message and exit.
*/
unsafe extern "C" fn open_db(mut p: *mut ShellState, mut openFlags: libc::c_int) {
    if (*p).db.is_null() {
        let mut zDbFilename: *const libc::c_char = (*(*p).pAuxDb).zDbFilename;
        if (*p).openMode as libc::c_int == 0 as libc::c_int {
            if zDbFilename.is_null()
                || *zDbFilename.offset(0 as libc::c_int as isize) as libc::c_int == 0 as libc::c_int
            {
                (*p).openMode = 1 as libc::c_int as u8_0
            } else {
                (*p).openMode = deduceDatabaseType(
                    zDbFilename,
                    (openFlags & 0x2 as libc::c_int != 0 as libc::c_int) as libc::c_int,
                ) as u8_0
            }
        }
        match (*p).openMode as libc::c_int {
            2 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    b"apndvfs\x00" as *const u8 as *const libc::c_char,
                );
            }
            6 | 5 => {
                sqlite3_open(0 as *const libc::c_char, &mut (*p).db);
            }
            3 => {
                sqlite3_open(
                    b":memory:\x00" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
            }
            4 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x1 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            0 | 1 => {
                sqlite3_open_v2(
                    zDbFilename,
                    &mut (*p).db,
                    0x2 as libc::c_int | 0x4 as libc::c_int | (*p).openFlags,
                    0 as *const libc::c_char,
                );
            }
            _ => {}
        }
        globalDb = (*p).db;
        if (*p).db.is_null() || 0 as libc::c_int != sqlite3_errcode((*p).db) {
            fprintf(
                stderr,
                b"Error: unable to open database \"%s\": %s\n\x00" as *const u8
                    as *const libc::c_char,
                zDbFilename,
                sqlite3_errmsg((*p).db),
            );
            if openFlags & 0x1 as libc::c_int != 0 {
                sqlite3_open(
                    b":memory:\x00" as *const u8 as *const libc::c_char,
                    &mut (*p).db,
                );
                return;
            } else {
                exit(1 as libc::c_int);
            }
        } else {
            sqlite3_enable_load_extension((*p).db, 1 as libc::c_int);
            sqlite3_fileio_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_shathree_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_completion_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_uint_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_decimal_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_regexp_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_ieee_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_series_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_dbdata_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_zipfile_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_sqlar_init(
                (*p).db,
                0 as *mut *mut libc::c_char,
                0 as *const sqlite3_api_routines,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_add_schema\x00" as *const u8 as *const libc::c_char,
                3 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellAddSchemaName
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_module_schema\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellModuleSchema
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_putsnl\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                p as *mut libc::c_void,
                Some(
                    shellPutsFunc
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_escape_crnl\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellEscapeCrnl
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_int32\x00" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellInt32
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"shell_idquote\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellIdQuote
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"usleep\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellUSleepFunc
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"edit\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    editFunc
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            sqlite3_create_function(
                (*p).db,
                b"edit\x00" as *const u8 as *const libc::c_char,
                2 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    editFunc
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
            if (*p).openMode as libc::c_int == 3 as libc::c_int {
                let mut zSql: *mut libc::c_char = sqlite3_mprintf(
                    b"CREATE VIRTUAL TABLE zip USING zipfile(%Q);\x00" as *const u8
                        as *const libc::c_char,
                    zDbFilename,
                );
                sqlite3_exec(
                    (*p).db,
                    zSql,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_free(zSql as *mut libc::c_void);
            } else if (*p).openMode as libc::c_int == 5 as libc::c_int
                || (*p).openMode as libc::c_int == 6 as libc::c_int
            {
                let mut rc: libc::c_int = 0;
                let mut nData: libc::c_int = 0 as libc::c_int;
                let mut aData: *mut libc::c_uchar = 0 as *mut libc::c_uchar;
                if (*p).openMode as libc::c_int == 5 as libc::c_int {
                    aData = readFile(zDbFilename, &mut nData) as *mut libc::c_uchar
                } else {
                    aData = readHexDb(p, &mut nData);
                    if aData.is_null() {
                        return;
                    }
                }
                rc = sqlite3_deserialize(
                    (*p).db,
                    b"main\x00" as *const u8 as *const libc::c_char,
                    aData,
                    nData as sqlite3_int64,
                    nData as sqlite3_int64,
                    (2 as libc::c_int | 1 as libc::c_int) as libc::c_uint,
                );
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Error: sqlite3_deserialize() returns %d\n\x00" as *const u8
                            as *const libc::c_char,
                        rc,
                    );
                }
                if (*p).szMax > 0 as libc::c_int as libc::c_longlong {
                    sqlite3_file_control(
                        (*p).db,
                        b"main\x00" as *const u8 as *const libc::c_char,
                        36 as libc::c_int,
                        &mut (*p).szMax as *mut sqlite3_int64 as *mut libc::c_void,
                    );
                }
            }
        }
    }
    if (*p).bSafeModePersist as libc::c_int != 0 && !(*p).db.is_null() {
        sqlite3_set_authorizer(
            (*p).db,
            Some(
                safeModeAuth
                    as unsafe extern "C" fn(
                        _: *mut libc::c_void,
                        _: libc::c_int,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                        _: *const libc::c_char,
                    ) -> libc::c_int,
            ),
            p as *mut libc::c_void,
        );
    };
}
/*
** Attempt to close the databaes connection.  Report errors.
*/
pub unsafe extern "C" fn close_db(mut db: *mut sqlite3) {
    let mut rc: libc::c_int = sqlite3_close(db);
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: sqlite3_close() returns %d: %s\n\x00" as *const u8 as *const libc::c_char,
            rc,
            sqlite3_errmsg(db),
        );
    };
}
/*
** Readline completion callbacks
*/
unsafe extern "C" fn readline_completion_generator(
    mut text: *const libc::c_char,
    mut state: libc::c_int,
) -> *mut libc::c_char {
    static mut pStmt: *mut sqlite3_stmt = 0 as *const sqlite3_stmt as *mut sqlite3_stmt;
    let mut zRet: *mut libc::c_char = 0 as *mut libc::c_char;
    if state == 0 as libc::c_int {
        let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
        sqlite3_finalize(pStmt);
        zSql = sqlite3_mprintf(
            b"SELECT DISTINCT candidate COLLATE nocase  FROM completion(%Q) ORDER BY 1\x00"
                as *const u8 as *const libc::c_char,
            text,
        );
        sqlite3_prepare_v2(
            globalDb,
            zSql,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        sqlite3_free(zSql as *mut libc::c_void);
    }
    if sqlite3_step(pStmt) == 100 as libc::c_int {
        zRet = strdup(sqlite3_column_text(pStmt, 0 as libc::c_int) as *const libc::c_char)
    } else {
        sqlite3_finalize(pStmt);
        pStmt = 0 as *mut sqlite3_stmt;
        zRet = 0 as *mut libc::c_char
    }
    return zRet;
}
unsafe extern "C" fn readline_completion(
    mut zText: *const libc::c_char,
    mut _iStart: libc::c_int,
    mut _iEnd: libc::c_int,
) -> *mut *mut libc::c_char {
    rl_attempted_completion_over = 1 as libc::c_int;
    return rl_completion_matches(
        zText,
        Some(
            readline_completion_generator
                as unsafe extern "C" fn(
                    _: *const libc::c_char,
                    _: libc::c_int,
                ) -> *mut libc::c_char,
        ),
    );
}
/*
** Do C-language style dequoting.
**
**    \a    -> alarm
**    \b    -> backspace
**    \t    -> tab
**    \n    -> newline
**    \v    -> vertical tab
**    \f    -> form feed
**    \r    -> carriage return
**    \s    -> space
**    \"    -> "
**    \'    -> '
**    \\    -> backslash
**    \NNN  -> ascii character NNN in octal
*/
unsafe extern "C" fn resolve_backslashes(mut z: *mut libc::c_char) {
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut c: libc::c_char = 0;
    while *z as libc::c_int != 0 && *z as libc::c_int != '\\' as i32 {
        z = z.offset(1)
    }
    j = 0 as libc::c_int;
    i = j;
    loop {
        c = *z.offset(i as isize);
        if !(c as libc::c_int != 0 as libc::c_int) {
            break;
        }
        if c as libc::c_int == '\\' as i32
            && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int != 0 as libc::c_int
        {
            i += 1;
            c = *z.offset(i as isize);
            if c as libc::c_int == 'a' as i32 {
                c = '\u{7}' as i32 as libc::c_char
            } else if c as libc::c_int == 'b' as i32 {
                c = '\u{8}' as i32 as libc::c_char
            } else if c as libc::c_int == 't' as i32 {
                c = '\t' as i32 as libc::c_char
            } else if c as libc::c_int == 'n' as i32 {
                c = '\n' as i32 as libc::c_char
            } else if c as libc::c_int == 'v' as i32 {
                c = '\u{b}' as i32 as libc::c_char
            } else if c as libc::c_int == 'f' as i32 {
                c = '\u{c}' as i32 as libc::c_char
            } else if c as libc::c_int == 'r' as i32 {
                c = '\r' as i32 as libc::c_char
            } else if c as libc::c_int == '\"' as i32 {
                c = '\"' as i32 as libc::c_char
            } else if c as libc::c_int == '\'' as i32 {
                c = '\'' as i32 as libc::c_char
            } else if c as libc::c_int == '\\' as i32 {
                c = '\\' as i32 as libc::c_char
            } else if c as libc::c_int >= '0' as i32 && c as libc::c_int <= '7' as i32 {
                c = (c as libc::c_int - '0' as i32) as libc::c_char;
                if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int >= '0' as i32
                    && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int <= '7' as i32
                {
                    i += 1;
                    c = (((c as libc::c_int) << 3 as libc::c_int)
                        + *z.offset(i as isize) as libc::c_int
                        - '0' as i32) as libc::c_char;
                    if *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int >= '0' as i32
                        && *z.offset((i + 1 as libc::c_int) as isize) as libc::c_int <= '7' as i32
                    {
                        i += 1;
                        c = (((c as libc::c_int) << 3 as libc::c_int)
                            + *z.offset(i as isize) as libc::c_int
                            - '0' as i32) as libc::c_char
                    }
                }
            }
        }
        *z.offset(j as isize) = c;
        i += 1;
        j += 1
    }
    if j < i {
        *z.offset(j as isize) = 0 as libc::c_int as libc::c_char
    };
}
/*
** Interpret zArg as either an integer or a boolean value.  Return 1 or 0
** for TRUE and FALSE.  Return the integer value if appropriate.
*/
unsafe extern "C" fn booleanValue(mut zArg: *const libc::c_char) -> libc::c_int {
    let mut i: libc::c_int = 0;
    if *zArg.offset(0 as libc::c_int as isize) as libc::c_int == '0' as i32
        && *zArg.offset(1 as libc::c_int as isize) as libc::c_int == 'x' as i32
    {
        i = 2 as libc::c_int;
        while hexDigitValue(*zArg.offset(i as isize)) >= 0 as libc::c_int {
            i += 1
        }
    } else {
        i = 0 as libc::c_int;
        while *zArg.offset(i as isize) as libc::c_int >= '0' as i32
            && *zArg.offset(i as isize) as libc::c_int <= '9' as i32
        {
            i += 1
        }
    }
    if i > 0 as libc::c_int && *zArg.offset(i as isize) as libc::c_int == 0 as libc::c_int {
        return (integerValue(zArg) & 0xffffffff as libc::c_uint as libc::c_longlong)
            as libc::c_int;
    } else if sqlite3_stricmp(zArg, b"on\x00" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"yes\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        return 1 as libc::c_int;
    } else if sqlite3_stricmp(zArg, b"off\x00" as *const u8 as *const libc::c_char)
        == 0 as libc::c_int
        || sqlite3_stricmp(zArg, b"no\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
    {
        return 0 as libc::c_int;
    } else {
        fprintf(
            stderr,
            b"ERROR: Not a boolean value: \"%s\". Assuming \"no\".\n\x00" as *const u8
                as *const libc::c_char,
            zArg,
        );
        return 0 as libc::c_int;
    };
}
/*
** Set or clear a shell flag according to a boolean value.
*/
unsafe extern "C" fn setOrClearFlag(
    mut p: *mut ShellState,
    mut mFlag: libc::c_uint,
    mut zArg: *const libc::c_char,
) {
    if booleanValue(zArg) != 0 {
        (*p).shellFlgs |= mFlag
    } else {
        (*p).shellFlgs &= !mFlag
    };
}
/*
** Close an output file, assuming it is not stderr or stdout
*/
unsafe extern "C" fn output_file_close(mut f: *mut FILE) {
    if !f.is_null() && f != stdout && f != stderr {
        fclose(f);
    };
}
/*
** Try to open an output file.   The names "stdout" and "stderr" are
** recognized and do the right thing.  NULL is returned if the output
** filename is "off".
*/
unsafe extern "C" fn output_file_open(
    mut zFile: *const libc::c_char,
    mut bTextMode: libc::c_int,
) -> *mut FILE {
    let mut f: *mut FILE = 0 as *mut FILE;
    if strcmp(zFile, b"stdout\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
        f = stdout
    } else if strcmp(zFile, b"stderr\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
        f = stderr
    } else if strcmp(zFile, b"off\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
        f = 0 as *mut FILE
    } else {
        f = fopen(
            zFile,
            if bTextMode != 0 {
                b"w\x00" as *const u8 as *const libc::c_char
            } else {
                b"wb\x00" as *const u8 as *const libc::c_char
            },
        );
        if f.is_null() {
            fprintf(
                stderr,
                b"Error: cannot open \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                zFile,
            );
        }
    }
    return f;
}
/*
** A routine for handling output from sqlite3_trace().
*/
unsafe extern "C" fn sql_trace_callback(
    mut mType: libc::c_uint,
    mut pArg: *mut libc::c_void,
    mut pP: *mut libc::c_void,
    mut pX: *mut libc::c_void,
) -> libc::c_int
/* Auxiliary output */ {
    let mut p: *mut ShellState = pArg as *mut ShellState;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut nSql: libc::c_int = 0;
    if (*p).traceOut.is_null() {
        return 0 as libc::c_int;
    } else if mType == 0x8 as libc::c_int as libc::c_uint {
        fprintf(
            (*p).traceOut,
            b"-- closing database connection\n\x00" as *const u8 as *const libc::c_char,
        );
        return 0 as libc::c_int;
    } else {
        if mType != 0x4 as libc::c_int as libc::c_uint
            && *(pX as *const libc::c_char).offset(0 as libc::c_int as isize) as libc::c_int
                == '-' as i32
        {
            zSql = pX as *const libc::c_char
        } else {
            pStmt = pP as *mut sqlite3_stmt;
            match (*p).eTraceType as libc::c_int {
                1 => zSql = sqlite3_expanded_sql(pStmt),
                _ => zSql = sqlite3_sql(pStmt),
            }
        }
        if zSql.is_null() {
            return 0 as libc::c_int;
        } else {
            nSql = strlen30(zSql);
            while nSql > 0 as libc::c_int
                && *zSql.offset((nSql - 1 as libc::c_int) as isize) as libc::c_int == ';' as i32
            {
                nSql -= 1
            }
            match mType {
                4 | 1 => {
                    fprintf(
                        (*p).traceOut,
                        b"%.*s;\n\x00" as *const u8 as *const libc::c_char,
                        nSql,
                        zSql,
                    );
                }
                2 => {
                    let mut nNanosec: sqlite3_int64 = *(pX as *mut sqlite3_int64);
                    fprintf(
                        (*p).traceOut,
                        b"%.*s; -- %lld ns\n\x00" as *const u8 as *const libc::c_char,
                        nSql,
                        zSql,
                        nNanosec,
                    );
                }
                _ => {}
            }
            return 0 as libc::c_int;
        }
    };
}
/*
** A no-op routine that runs with the ".breakpoint" doc-command.  This is
** a useful spot to set a debugger breakpoint.
*/
unsafe extern "C" fn test_breakpoint() {
    static mut nCall: libc::c_int = 0 as libc::c_int;
    nCall += 1;
}
/* The row separator character.  (Usually "\n") */
/* Clean up resourced used by an ImportCtx */
unsafe extern "C" fn import_cleanup(mut p: *mut ImportCtx) {
    if !(*p).in_0.is_null() && (*p).xCloser.is_some() {
        (*p).xCloser.expect("non-null function pointer")((*p).in_0);
        (*p).in_0 = 0 as *mut FILE
    }
    sqlite3_free((*p).z as *mut libc::c_void);
    (*p).z = 0 as *mut libc::c_char;
}
/* Append a single byte to z[] */
unsafe extern "C" fn import_append_char(mut p: *mut ImportCtx, mut c: libc::c_int) {
    if (*p).n + 1 as libc::c_int >= (*p).nAlloc {
        (*p).nAlloc += (*p).nAlloc + 100 as libc::c_int;
        (*p).z = sqlite3_realloc64((*p).z as *mut libc::c_void, (*p).nAlloc as sqlite3_uint64)
            as *mut libc::c_char;
        if (*p).z.is_null() {
            shell_out_of_memory();
        }
    }
    let fresh63 = (*p).n;
    (*p).n = (*p).n + 1;
    *(*p).z.offset(fresh63 as isize) = c as libc::c_char;
}
/* Read a single field of CSV text.  Compatible with rfc4180 and extended
** with the option of having a separator other than ",".
**
**   +  Input comes from p->in.
**   +  Store results in p->z of length p->n.  Space to hold p->z comes
**      from sqlite3_malloc64().
**   +  Use p->cSep as the column separator.  The default is ",".
**   +  Use p->rSep as the row separator.  The default is "\n".
**   +  Keep track of the line number in p->nLine.
**   +  Store the character that terminates the field in p->cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/
unsafe extern "C" fn csv_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    } else {
        if c == '\"' as i32 {
            let mut pc: libc::c_int = 0;
            let mut ppc: libc::c_int = 0;
            let mut startLine: libc::c_int = (*p).nLine;
            let mut cQuote: libc::c_int = c;
            ppc = 0 as libc::c_int;
            pc = ppc;
            loop {
                c = fgetc((*p).in_0);
                if c == rSep {
                    (*p).nLine += 1
                }
                if c == cQuote {
                    if pc == cQuote {
                        pc = 0 as libc::c_int;
                        continue;
                    }
                }
                if c == cSep && pc == cQuote
                    || c == rSep && pc == cQuote
                    || c == rSep && pc == '\r' as i32 && ppc == cQuote
                    || c == -(1 as libc::c_int) && pc == cQuote
                {
                    loop {
                        (*p).n -= 1;
                        if !(*(*p).z.offset((*p).n as isize) as libc::c_int != cQuote) {
                            break;
                        }
                    }
                    (*p).cTerm = c;
                    break;
                } else {
                    if pc == cQuote && c != '\r' as i32 {
                        fprintf(
                            stderr,
                            b"%s:%d: unescaped %c character\n\x00" as *const u8
                                as *const libc::c_char,
                            (*p).zFile,
                            (*p).nLine,
                            cQuote,
                        );
                    }
                    if c == -(1 as libc::c_int) {
                        fprintf(
                            stderr,
                            b"%s:%d: unterminated %c-quoted field\n\x00" as *const u8
                                as *const libc::c_char,
                            (*p).zFile,
                            startLine,
                            cQuote,
                        );
                        (*p).cTerm = c;
                        break;
                    } else {
                        import_append_char(p, c);
                        ppc = pc;
                        pc = c
                    }
                }
            }
        } else {
            /* If this is the first field being parsed and it begins with the
             ** UTF-8 BOM  (0xEF BB BF) then skip the BOM */
            if c & 0xff as libc::c_int == 0xef as libc::c_int && (*p).bNotFirst == 0 as libc::c_int
            {
                import_append_char(p, c);
                c = fgetc((*p).in_0);
                if c & 0xff as libc::c_int == 0xbb as libc::c_int {
                    import_append_char(p, c);
                    c = fgetc((*p).in_0);
                    if c & 0xff as libc::c_int == 0xbf as libc::c_int {
                        (*p).bNotFirst = 1 as libc::c_int;
                        (*p).n = 0 as libc::c_int;
                        return csv_read_one_field(p);
                    }
                }
            }
            while c != -(1 as libc::c_int) && c != cSep && c != rSep {
                import_append_char(p, c);
                c = fgetc((*p).in_0)
            }
            if c == rSep {
                (*p).nLine += 1;
                if (*p).n > 0 as libc::c_int
                    && *(*p).z.offset(((*p).n - 1 as libc::c_int) as isize) as libc::c_int
                        == '\r' as i32
                {
                    (*p).n -= 1
                }
            }
            (*p).cTerm = c
        }
        if !(*p).z.is_null() {
            *(*p).z.offset((*p).n as isize) = 0 as libc::c_int as libc::c_char
        }
        (*p).bNotFirst = 1 as libc::c_int;
        return (*p).z;
    };
}
/* Read a single field of ASCII delimited text.
**
**   +  Input comes from p->in.
**   +  Store results in p->z of length p->n.  Space to hold p->z comes
**      from sqlite3_malloc64().
**   +  Use p->cSep as the column separator.  The default is "\x1F".
**   +  Use p->rSep as the row separator.  The default is "\x1E".
**   +  Keep track of the row number in p->nLine.
**   +  Store the character that terminates the field in p->cTerm.  Store
**      EOF on end-of-file.
**   +  Report syntax errors on stderr
*/
unsafe extern "C" fn ascii_read_one_field(mut p: *mut ImportCtx) -> *mut libc::c_char {
    let mut c: libc::c_int = 0;
    let mut cSep: libc::c_int = (*p).cColSep;
    let mut rSep: libc::c_int = (*p).cRowSep;
    (*p).n = 0 as libc::c_int;
    c = fgetc((*p).in_0);
    if c == -(1 as libc::c_int) || seenInterrupt != 0 {
        (*p).cTerm = -(1 as libc::c_int);
        return 0 as *mut libc::c_char;
    } else {
        while c != -(1 as libc::c_int) && c != cSep && c != rSep {
            import_append_char(p, c);
            c = fgetc((*p).in_0)
        }
        if c == rSep {
            (*p).nLine += 1
        }
        (*p).cTerm = c;
        if !(*p).z.is_null() {
            *(*p).z.offset((*p).n as isize) = 0 as libc::c_int as libc::c_char
        }
        return (*p).z;
    };
}
/*
** Try to transfer data for table zTable.  If an error is seen while
** moving forward, try to go backwards.  The backwards movement won't
** work for WITHOUT ROWID tables.
*/
unsafe extern "C" fn tryToCloneData(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zTable: *const libc::c_char,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* End for(k=0...) */
    let mut pInsert: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* End while */
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char; /* End for */
    let mut zInsert: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    let mut n: libc::c_int = 0;
    let mut nTable: libc::c_int = strlen30(zTable);
    let mut k: libc::c_int = 0 as libc::c_int;
    let mut cnt: libc::c_int = 0 as libc::c_int;
    let spinRate: libc::c_int = 10000 as libc::c_int;
    zQuery = sqlite3_mprintf(
        b"SELECT * FROM \"%w\"\x00" as *const u8 as *const libc::c_char,
        zTable,
    );
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error %d: %s on [%s]\n\x00" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        n = sqlite3_column_count(pQuery);
        zInsert = sqlite3_malloc64(
            (200 as libc::c_int + nTable + n * 3 as libc::c_int) as sqlite3_uint64,
        ) as *mut libc::c_char;
        if zInsert.is_null() {
            shell_out_of_memory();
        }
        sqlite3_snprintf(
            200 as libc::c_int + nTable,
            zInsert,
            b"INSERT OR IGNORE INTO \"%s\" VALUES(?\x00" as *const u8 as *const libc::c_char,
            zTable,
        );
        i = strlen30(zInsert);
        j = 1 as libc::c_int;
        while j < n {
            memcpy(
                zInsert.offset(i as isize) as *mut libc::c_void,
                b",?\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                2 as libc::c_int as libc::c_ulong,
            );
            i += 2 as libc::c_int;
            j += 1
        }
        memcpy(
            zInsert.offset(i as isize) as *mut libc::c_void,
            b");\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
            3 as libc::c_int as libc::c_ulong,
        );
        rc = sqlite3_prepare_v2(
            newDb,
            zInsert,
            -(1 as libc::c_int),
            &mut pInsert,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"Error %d: %s on [%s]\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_extended_errcode(newDb),
                sqlite3_errmsg(newDb),
                zQuery,
            );
        } else {
            k = 0 as libc::c_int;
            while k < 2 as libc::c_int {
                loop {
                    rc = sqlite3_step(pQuery);
                    if !(rc == 100 as libc::c_int) {
                        break;
                    }
                    i = 0 as libc::c_int;
                    while i < n {
                        match sqlite3_column_type(pQuery, i) {
                            5 => {
                                sqlite3_bind_null(pInsert, i + 1 as libc::c_int);
                            }
                            1 => {
                                sqlite3_bind_int64(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_int64(pQuery, i),
                                );
                            }
                            2 => {
                                sqlite3_bind_double(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_double(pQuery, i),
                                );
                            }
                            3 => {
                                sqlite3_bind_text(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_text(pQuery, i) as *const libc::c_char,
                                    -(1 as libc::c_int),
                                    None,
                                );
                            }
                            4 => {
                                sqlite3_bind_blob(
                                    pInsert,
                                    i + 1 as libc::c_int,
                                    sqlite3_column_blob(pQuery, i),
                                    sqlite3_column_bytes(pQuery, i),
                                    None,
                                );
                            }
                            _ => {}
                        }
                        i += 1
                    }
                    rc = sqlite3_step(pInsert);
                    if rc != 0 as libc::c_int
                        && rc != 100 as libc::c_int
                        && rc != 101 as libc::c_int
                    {
                        fprintf(
                            stderr,
                            b"Error %d: %s\n\x00" as *const u8 as *const libc::c_char,
                            sqlite3_extended_errcode(newDb),
                            sqlite3_errmsg(newDb),
                        );
                    }
                    sqlite3_reset(pInsert);
                    cnt += 1;
                    if !(cnt % spinRate == 0 as libc::c_int) {
                        continue;
                    }
                    printf(
                        b"%c\x08\x00" as *const u8 as *const libc::c_char,
                        (*::std::mem::transmute::<&[u8; 5], &[libc::c_char; 5]>(b"|/-\\\x00"))
                            [(cnt / spinRate % 4 as libc::c_int) as usize]
                            as libc::c_int,
                    );
                    fflush(stdout);
                }
                if rc == 101 as libc::c_int {
                    break;
                }
                sqlite3_finalize(pQuery);
                sqlite3_free(zQuery as *mut libc::c_void);
                zQuery = sqlite3_mprintf(
                    b"SELECT * FROM \"%w\" ORDER BY rowid DESC;\x00" as *const u8
                        as *const libc::c_char,
                    zTable,
                );
                rc = sqlite3_prepare_v2(
                    (*p).db,
                    zQuery,
                    -(1 as libc::c_int),
                    &mut pQuery,
                    0 as *mut *const libc::c_char,
                );
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Warning: cannot step \"%s\" backwards\x00" as *const u8
                            as *const libc::c_char,
                        zTable,
                    );
                    break;
                } else {
                    k += 1
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_finalize(pInsert);
    sqlite3_free(zQuery as *mut libc::c_void);
    sqlite3_free(zInsert as *mut libc::c_void);
}
/*
** Try to transfer all rows of the schema that match zWhere.  For
** each row, invoke xForEach() on the object defined by that row.
** If an error is encountered while moving forward through the
** sqlite_schema table, try again moving backwards.
*/
unsafe extern "C" fn tryToCloneSchema(
    mut p: *mut ShellState,
    mut newDb: *mut sqlite3,
    mut zWhere: *const libc::c_char,
    mut xForEach: Option<
        unsafe extern "C" fn(_: *mut ShellState, _: *mut sqlite3, _: *const libc::c_char) -> (),
    >,
) {
    let mut pQuery: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut zQuery: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut rc: libc::c_int = 0;
    let mut zName: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zSql: *const libc::c_uchar = 0 as *const libc::c_uchar;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    zQuery = sqlite3_mprintf(
        b"SELECT name, sql FROM sqlite_schema WHERE %s\x00" as *const u8 as *const libc::c_char,
        zWhere,
    );
    rc = sqlite3_prepare_v2(
        (*p).db,
        zQuery,
        -(1 as libc::c_int),
        &mut pQuery,
        0 as *mut *const libc::c_char,
    );
    if rc != 0 {
        fprintf(
            stderr,
            b"Error: (%d) %s on [%s]\n\x00" as *const u8 as *const libc::c_char,
            sqlite3_extended_errcode((*p).db),
            sqlite3_errmsg((*p).db),
            zQuery,
        );
    } else {
        loop {
            rc = sqlite3_step(pQuery);
            if !(rc == 100 as libc::c_int) {
                break;
            }
            zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
            zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
            printf(b"%s... \x00" as *const u8 as *const libc::c_char, zName);
            fflush(stdout);
            sqlite3_exec(
                newDb,
                zSql as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                &mut zErrMsg,
            );
            if !zErrMsg.is_null() {
                fprintf(
                    stderr,
                    b"Error: %s\nSQL: [%s]\n\x00" as *const u8 as *const libc::c_char,
                    zErrMsg,
                    zSql,
                );
                sqlite3_free(zErrMsg as *mut libc::c_void);
                zErrMsg = 0 as *mut libc::c_char
            }
            if xForEach.is_some() {
                xForEach.expect("non-null function pointer")(
                    p,
                    newDb,
                    zName as *const libc::c_char,
                );
            }
            printf(b"done\n\x00" as *const u8 as *const libc::c_char);
        }
        if rc != 101 as libc::c_int {
            sqlite3_finalize(pQuery);
            sqlite3_free(zQuery as *mut libc::c_void);
            zQuery = sqlite3_mprintf(
                b"SELECT name, sql FROM sqlite_schema WHERE %s ORDER BY rowid DESC\x00" as *const u8
                    as *const libc::c_char,
                zWhere,
            );
            rc = sqlite3_prepare_v2(
                (*p).db,
                zQuery,
                -(1 as libc::c_int),
                &mut pQuery,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: (%d) %s on [%s]\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_extended_errcode((*p).db),
                    sqlite3_errmsg((*p).db),
                    zQuery,
                );
            } else {
                while sqlite3_step(pQuery) == 100 as libc::c_int {
                    zName = sqlite3_column_text(pQuery, 0 as libc::c_int);
                    zSql = sqlite3_column_text(pQuery, 1 as libc::c_int);
                    printf(b"%s... \x00" as *const u8 as *const libc::c_char, zName);
                    fflush(stdout);
                    sqlite3_exec(
                        newDb,
                        zSql as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        &mut zErrMsg,
                    );
                    if !zErrMsg.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\nSQL: [%s]\n\x00" as *const u8 as *const libc::c_char,
                            zErrMsg,
                            zSql,
                        );
                        sqlite3_free(zErrMsg as *mut libc::c_void);
                        zErrMsg = 0 as *mut libc::c_char
                    }
                    if xForEach.is_some() {
                        xForEach.expect("non-null function pointer")(
                            p,
                            newDb,
                            zName as *const libc::c_char,
                        );
                    }
                    printf(b"done\n\x00" as *const u8 as *const libc::c_char);
                }
            }
        }
    }
    sqlite3_finalize(pQuery);
    sqlite3_free(zQuery as *mut libc::c_void);
}
/*
** Open a new database file named "zNewDb".  Try to recover as much information
** as possible out of the main database (which might be corrupt) and write it
** into zNewDb.
*/
unsafe extern "C" fn tryToClone(mut p: *mut ShellState, mut zNewDb: *const libc::c_char) {
    let mut rc: libc::c_int = 0;
    let mut newDb: *mut sqlite3 = 0 as *mut sqlite3;
    if access(zNewDb, 0 as libc::c_int) == 0 as libc::c_int {
        fprintf(
            stderr,
            b"File \"%s\" already exists.\n\x00" as *const u8 as *const libc::c_char,
            zNewDb,
        );
        return;
    } else {
        rc = sqlite3_open(zNewDb, &mut newDb);
        if rc != 0 {
            fprintf(
                stderr,
                b"Cannot create output database: %s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(newDb),
            );
        } else {
            sqlite3_exec(
                (*p).db,
                b"PRAGMA writable_schema=ON;\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_exec(
                newDb,
                b"BEGIN EXCLUSIVE;\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            tryToCloneSchema(
                p,
                newDb,
                b"type=\'table\'\x00" as *const u8 as *const libc::c_char,
                Some(
                    tryToCloneData
                        as unsafe extern "C" fn(
                            _: *mut ShellState,
                            _: *mut sqlite3,
                            _: *const libc::c_char,
                        ) -> (),
                ),
            );
            tryToCloneSchema(
                p,
                newDb,
                b"type!=\'table\'\x00" as *const u8 as *const libc::c_char,
                None,
            );
            sqlite3_exec(
                newDb,
                b"COMMIT;\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            sqlite3_exec(
                (*p).db,
                b"PRAGMA writable_schema=OFF;\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
        }
        close_db(newDb);
        return;
    };
}
/*
** Change the output file back to stdout.
**
** If the p->doXdgOpen flag is set, that means the output was being
** redirected to a temporary file named by p->zTempFile.  In that case,
** launch start/open/xdg-open on that temporary file.
*/
unsafe extern "C" fn output_reset(mut p: *mut ShellState) {
    if (*p).outfile[0 as libc::c_int as usize] as libc::c_int == '|' as i32 {
        pclose((*p).out);
    } else {
        output_file_close((*p).out);
        if (*p).doXdgOpen != 0 {
            let mut zXdgOpenCmd: *const libc::c_char =
                b"xdg-open\x00" as *const u8 as *const libc::c_char;
            let mut zCmd: *mut libc::c_char = 0 as *mut libc::c_char;
            zCmd = sqlite3_mprintf(
                b"%s %s\x00" as *const u8 as *const libc::c_char,
                zXdgOpenCmd,
                (*p).zTempFile,
            );
            if system(zCmd) != 0 {
                fprintf(
                    stderr,
                    b"Failed: [%s]\n\x00" as *const u8 as *const libc::c_char,
                    zCmd,
                );
            } else {
                /* !defined(SQLITE_NOHAVE_SYSTEM) */
                /* Give the start/open/xdg-open command some time to get
                 ** going before we continue, and potential delete the
                 ** p->zTempFile data file out from under it */
                sqlite3_sleep(2000 as libc::c_int);
            }
            sqlite3_free(zCmd as *mut libc::c_void);
            outputModePop(p);
            (*p).doXdgOpen = 0 as libc::c_int as u8_0
        }
    }
    (*p).outfile[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
    (*p).out = stdout;
}
/*
** Run an SQL command and return the single integer result.
*/
unsafe extern "C" fn db_int(mut p: *mut ShellState, mut zSql: *const libc::c_char) -> libc::c_int {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut res: libc::c_int = 0 as libc::c_int;
    sqlite3_prepare_v2(
        (*p).db,
        zSql,
        -(1 as libc::c_int),
        &mut pStmt,
        0 as *mut *const libc::c_char,
    );
    if !pStmt.is_null() && sqlite3_step(pStmt) == 100 as libc::c_int {
        res = sqlite3_column_int(pStmt, 0 as libc::c_int)
    }
    sqlite3_finalize(pStmt);
    return res;
}
/*
** Convert a 2-byte or 4-byte big-endian integer into a native integer
*/
unsafe extern "C" fn get2byteInt(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(1 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
unsafe extern "C" fn get4byteInt(mut a: *mut libc::c_uchar) -> libc::c_uint {
    return (((*a.offset(0 as libc::c_int as isize) as libc::c_int) << 24 as libc::c_int)
        + ((*a.offset(1 as libc::c_int as isize) as libc::c_int) << 16 as libc::c_int)
        + ((*a.offset(2 as libc::c_int as isize) as libc::c_int) << 8 as libc::c_int)
        + *a.offset(3 as libc::c_int as isize) as libc::c_int) as libc::c_uint;
}
/*
** Implementation of the ".dbinfo" command.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/
unsafe extern "C" fn shell_dbinfo_command(
    mut p: *mut ShellState,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    static mut aField: [C2RustUnnamed_23; 12] = [
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"file change counter:\x00" as *const u8 as *const libc::c_char,
                ofst: 24 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"database page count:\x00" as *const u8 as *const libc::c_char,
                ofst: 28 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"freelist page count:\x00" as *const u8 as *const libc::c_char,
                ofst: 36 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"schema cookie:\x00" as *const u8 as *const libc::c_char,
                ofst: 40 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"schema format:\x00" as *const u8 as *const libc::c_char,
                ofst: 44 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"default cache size:\x00" as *const u8 as *const libc::c_char,
                ofst: 48 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"autovacuum top root:\x00" as *const u8 as *const libc::c_char,
                ofst: 52 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"incremental vacuum:\x00" as *const u8 as *const libc::c_char,
                ofst: 64 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"text encoding:\x00" as *const u8 as *const libc::c_char,
                ofst: 56 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"user version:\x00" as *const u8 as *const libc::c_char,
                ofst: 60 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"application id:\x00" as *const u8 as *const libc::c_char,
                ofst: 68 as libc::c_int,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_23 {
                zName: b"software version:\x00" as *const u8 as *const libc::c_char,
                ofst: 96 as libc::c_int,
            };
            init
        },
    ];
    static mut aQuery: [C2RustUnnamed_22; 5] = [
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of tables:\x00" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type=\'table\'\x00" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of indexes:\x00" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type=\'index\'\x00" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of triggers:\x00" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type=\'trigger\'\x00" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"number of views:\x00" as *const u8 as *const libc::c_char,
                zSql: b"SELECT count(*) FROM %s WHERE type=\'view\'\x00" as *const u8
                    as *const libc::c_char,
            };
            init
        },
        {
            let mut init = C2RustUnnamed_22 {
                zName: b"schema size:\x00" as *const u8 as *const libc::c_char,
                zSql: b"SELECT total(length(sql)) FROM %s\x00" as *const u8 as *const libc::c_char,
            };
            init
        },
    ];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut iDataVersion: libc::c_uint = 0;
    let mut zSchemaTab: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zDb: *mut libc::c_char = if nArg >= 2 as libc::c_int {
        *azArg.offset(1 as libc::c_int as isize) as *const libc::c_char
    } else {
        b"main\x00" as *const u8 as *const libc::c_char
    } as *mut libc::c_char;
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut aHdr: [libc::c_uchar; 100] = [0; 100];
    open_db(p, 0 as libc::c_int);
    if (*p).db.is_null() {
        return 1 as libc::c_int;
    } else {
        rc = sqlite3_prepare_v2(
            (*p).db,
            b"SELECT data FROM sqlite_dbpage(?1) WHERE pgno=1\x00" as *const u8
                as *const libc::c_char,
            -(1 as libc::c_int),
            &mut pStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 {
            fprintf(
                stderr,
                b"error: %s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg((*p).db),
            );
            sqlite3_finalize(pStmt);
            return 1 as libc::c_int;
        } else {
            sqlite3_bind_text(pStmt, 1 as libc::c_int, zDb, -(1 as libc::c_int), None);
            if sqlite3_step(pStmt) == 100 as libc::c_int
                && sqlite3_column_bytes(pStmt, 0 as libc::c_int) > 100 as libc::c_int
            {
                memcpy(
                    aHdr.as_mut_ptr() as *mut libc::c_void,
                    sqlite3_column_blob(pStmt, 0 as libc::c_int),
                    100 as libc::c_int as libc::c_ulong,
                );
                sqlite3_finalize(pStmt);
                i = get2byteInt(aHdr.as_mut_ptr().offset(16 as libc::c_int as isize))
                    as libc::c_int;
                if i == 1 as libc::c_int {
                    i = 65536 as libc::c_int
                }
                fprintf(
                    (*p).out,
                    b"%-20s %d\n\x00" as *const u8 as *const libc::c_char,
                    b"database page size:\x00" as *const u8 as *const libc::c_char,
                    i,
                );
                fprintf(
                    (*p).out,
                    b"%-20s %d\n\x00" as *const u8 as *const libc::c_char,
                    b"write format:\x00" as *const u8 as *const libc::c_char,
                    aHdr[18 as libc::c_int as usize] as libc::c_int,
                );
                fprintf(
                    (*p).out,
                    b"%-20s %d\n\x00" as *const u8 as *const libc::c_char,
                    b"read format:\x00" as *const u8 as *const libc::c_char,
                    aHdr[19 as libc::c_int as usize] as libc::c_int,
                );
                fprintf(
                    (*p).out,
                    b"%-20s %d\n\x00" as *const u8 as *const libc::c_char,
                    b"reserved bytes:\x00" as *const u8 as *const libc::c_char,
                    aHdr[20 as libc::c_int as usize] as libc::c_int,
                );
                i = 0 as libc::c_int;
                while i
                    < (::std::mem::size_of::<[C2RustUnnamed_23; 12]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_23>() as libc::c_ulong)
                        as libc::c_int
                {
                    let mut ofst: libc::c_int = aField[i as usize].ofst;
                    let mut val: libc::c_uint =
                        get4byteInt(aHdr.as_mut_ptr().offset(ofst as isize));
                    fprintf(
                        (*p).out,
                        b"%-20s %u\x00" as *const u8 as *const libc::c_char,
                        aField[i as usize].zName,
                        val,
                    );
                    match ofst {
                        56 => {
                            if val == 1 as libc::c_int as libc::c_uint {
                                fprintf(
                                    (*p).out,
                                    b" (utf8)\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                            if val == 2 as libc::c_int as libc::c_uint {
                                fprintf(
                                    (*p).out,
                                    b" (utf16le)\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                            if val == 3 as libc::c_int as libc::c_uint {
                                fprintf(
                                    (*p).out,
                                    b" (utf16be)\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                        }
                        _ => {}
                    }
                    fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                    i += 1
                }
                if zDb.is_null() {
                    zSchemaTab = sqlite3_mprintf(
                        b"main.sqlite_schema\x00" as *const u8 as *const libc::c_char,
                    )
                } else if strcmp(zDb, b"temp\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    zSchemaTab = sqlite3_mprintf(
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        b"sqlite_temp_schema\x00" as *const u8 as *const libc::c_char,
                    )
                } else {
                    zSchemaTab = sqlite3_mprintf(
                        b"\"%w\".sqlite_schema\x00" as *const u8 as *const libc::c_char,
                        zDb,
                    )
                }
                i = 0 as libc::c_int;
                while i
                    < (::std::mem::size_of::<[C2RustUnnamed_22; 5]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_22>() as libc::c_ulong)
                        as libc::c_int
                {
                    let mut zSql: *mut libc::c_char =
                        sqlite3_mprintf(aQuery[i as usize].zSql, zSchemaTab);
                    let mut val_0: libc::c_int = db_int(p, zSql);
                    sqlite3_free(zSql as *mut libc::c_void);
                    fprintf(
                        (*p).out,
                        b"%-20s %d\n\x00" as *const u8 as *const libc::c_char,
                        aQuery[i as usize].zName,
                        val_0,
                    );
                    i += 1
                }
                sqlite3_free(zSchemaTab as *mut libc::c_void);
                sqlite3_file_control(
                    (*p).db,
                    zDb,
                    35 as libc::c_int,
                    &mut iDataVersion as *mut libc::c_uint as *mut libc::c_void,
                );
                fprintf(
                    (*p).out,
                    b"%-20s %u\n\x00" as *const u8 as *const libc::c_char,
                    b"data version\x00" as *const u8 as *const libc::c_char,
                    iDataVersion,
                );
                return 0 as libc::c_int;
            } else {
                fprintf(
                    stderr,
                    b"unable to read database header\n\x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_finalize(pStmt);
                return 1 as libc::c_int;
            }
        }
    };
}
/*
** Print the current sqlite3_errmsg() value to stderr and return 1.
*/
unsafe extern "C" fn shellDatabaseError(mut db: *mut sqlite3) -> libc::c_int {
    let mut zErr: *const libc::c_char = sqlite3_errmsg(db);
    fprintf(
        stderr,
        b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
        zErr,
    );
    return 1 as libc::c_int;
}
/*
** Compare the pattern in zGlob[] against the text in z[].  Return TRUE
** if they match and FALSE (0) if they do not match.
**
** Globbing rules:
**
**      '*'       Matches any sequence of zero or more characters.
**
**      '?'       Matches exactly one character.
**
**     [...]      Matches one character from the enclosed list of
**                characters.
**
**     [^...]     Matches one character not in the enclosed list.
**
**      '#'       Matches any sequence of one or more digits with an
**                optional + or - sign in front
**
**      ' '       Any span of whitespace matches any other span of
**                whitespace.
**
** Extra whitespace at the end of z[] is ignored.
*/
unsafe extern "C" fn testcase_glob(
    mut zGlob: *const libc::c_char,
    mut z: *const libc::c_char,
) -> libc::c_int {
    let mut c: libc::c_int = 0;
    let mut c2: libc::c_int = 0;
    let mut invert: libc::c_int = 0;
    let mut seen: libc::c_int = 0;
    loop {
        let fresh64 = zGlob;
        zGlob = zGlob.offset(1);
        c = *fresh64 as libc::c_int;
        if !(c != 0 as libc::c_int) {
            break;
        }
        if *(*__ctype_b_loc()).offset(c as libc::c_uchar as libc::c_int as isize) as libc::c_int
            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            if *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                as libc::c_int
                & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            } else {
                while *(*__ctype_b_loc()).offset(*zGlob as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    zGlob = zGlob.offset(1)
                }
                while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    z = z.offset(1)
                }
            }
        } else if c == '*' as i32 {
            loop {
                let fresh65 = zGlob;
                zGlob = zGlob.offset(1);
                c = *fresh65 as libc::c_int;
                if !(c == '*' as i32 || c == '?' as i32) {
                    break;
                }
                if !(c == '?' as i32 && {
                    let fresh66 = z;
                    z = z.offset(1);
                    (*fresh66 as libc::c_int) == 0 as libc::c_int
                }) {
                    continue;
                }
                return 0 as libc::c_int;
            }
            if c == 0 as libc::c_int {
                return 1 as libc::c_int;
            } else if c == '[' as i32 {
                while *z as libc::c_int != 0
                    && testcase_glob(zGlob.offset(-(1 as libc::c_int as isize)), z)
                        == 0 as libc::c_int
                {
                    z = z.offset(1)
                }
                return (*z as libc::c_int != 0 as libc::c_int) as libc::c_int;
            } else {
                loop {
                    let fresh67 = z;
                    z = z.offset(1);
                    c2 = *fresh67 as libc::c_int;
                    if !(c2 != 0 as libc::c_int) {
                        break;
                    }
                    while c2 != c {
                        let fresh68 = z;
                        z = z.offset(1);
                        c2 = *fresh68 as libc::c_int;
                        if !(c2 == 0 as libc::c_int) {
                            continue;
                        }
                        return 0 as libc::c_int;
                    }
                    if !(testcase_glob(zGlob, z) != 0) {
                        continue;
                    }
                    return 1 as libc::c_int;
                }
                return 0 as libc::c_int;
            }
        } else if c == '?' as i32 {
            let fresh69 = z;
            z = z.offset(1);
            if !(*fresh69 as libc::c_int == 0 as libc::c_int) {
                continue;
            }
            return 0 as libc::c_int;
        } else if c == '[' as i32 {
            let mut prior_c: libc::c_int = 0 as libc::c_int;
            seen = 0 as libc::c_int;
            invert = 0 as libc::c_int;
            let fresh70 = z;
            z = z.offset(1);
            c = *fresh70 as libc::c_int;
            if c == 0 as libc::c_int {
                return 0 as libc::c_int;
            } else {
                let fresh71 = zGlob;
                zGlob = zGlob.offset(1);
                c2 = *fresh71 as libc::c_int;
                if c2 == '^' as i32 {
                    invert = 1 as libc::c_int;
                    let fresh72 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh72 as libc::c_int
                }
                if c2 == ']' as i32 {
                    if c == ']' as i32 {
                        seen = 1 as libc::c_int
                    }
                    let fresh73 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh73 as libc::c_int
                }
                while c2 != 0 && c2 != ']' as i32 {
                    if c2 == '-' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int != ']' as i32
                        && *zGlob.offset(0 as libc::c_int as isize) as libc::c_int
                            != 0 as libc::c_int
                        && prior_c > 0 as libc::c_int
                    {
                        let fresh74 = zGlob;
                        zGlob = zGlob.offset(1);
                        c2 = *fresh74 as libc::c_int;
                        if c >= prior_c && c <= c2 {
                            seen = 1 as libc::c_int
                        }
                        prior_c = 0 as libc::c_int
                    } else {
                        if c == c2 {
                            seen = 1 as libc::c_int
                        }
                        prior_c = c2
                    }
                    let fresh75 = zGlob;
                    zGlob = zGlob.offset(1);
                    c2 = *fresh75 as libc::c_int
                }
                if !(c2 == 0 as libc::c_int || seen ^ invert == 0 as libc::c_int) {
                    continue;
                }
                return 0 as libc::c_int;
            }
        } else if c == '#' as i32 {
            if (*z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                || *z.offset(0 as libc::c_int as isize) as libc::c_int == '+' as i32)
                && *(*__ctype_b_loc()).offset(
                    *z.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int as isize
                ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
            {
                z = z.offset(1)
            }
            if *(*__ctype_b_loc()).offset(
                *z.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int as isize
            ) as libc::c_int
                & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                == 0
            {
                return 0 as libc::c_int;
            } else {
                z = z.offset(1);
                while *(*__ctype_b_loc()).offset(*z.offset(0 as libc::c_int as isize)
                    as libc::c_uchar as libc::c_int
                    as isize) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    z = z.offset(1)
                }
            }
        } else {
            let fresh76 = z;
            z = z.offset(1);
            if !(c != *fresh76 as libc::c_int) {
                continue;
            }
            return 0 as libc::c_int;
        }
    }
    while *(*__ctype_b_loc()).offset(*z as libc::c_uchar as libc::c_int as isize) as libc::c_int
        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
        != 0
    {
        z = z.offset(1)
    }
    return (*z as libc::c_int == 0 as libc::c_int) as libc::c_int;
}
/*
** Compare the string as a command-line option with either one or two
** initial "-" characters.
*/
unsafe extern "C" fn optionMatch(
    mut zStr: *const libc::c_char,
    mut zOpt: *const libc::c_char,
) -> libc::c_int {
    if *zStr.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
        return 0 as libc::c_int;
    } else {
        zStr = zStr.offset(1);
        if *zStr.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
            zStr = zStr.offset(1)
        }
        return (strcmp(zStr, zOpt) == 0 as libc::c_int) as libc::c_int;
    };
}
/*
** Delete a file.
*/
pub unsafe extern "C" fn shellDeleteFile(mut zFilename: *const libc::c_char) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    rc = unlink(zFilename);
    return rc;
}
/*
** Try to delete the temporary file (if there is one) and free the
** memory used to hold the name of the temp file.
*/
unsafe extern "C" fn clearTempFile(mut p: *mut ShellState) {
    if (*p).zTempFile.is_null() {
        return;
    } else if (*p).doXdgOpen != 0 {
        return;
    } else if shellDeleteFile((*p).zTempFile) != 0 {
        return;
    } else {
        sqlite3_free((*p).zTempFile as *mut libc::c_void);
        (*p).zTempFile = 0 as *mut libc::c_char;
        return;
    };
}
/*
** Create a new temp file name with the given suffix.
*/
unsafe extern "C" fn newTempFile(mut p: *mut ShellState, mut zSuffix: *const libc::c_char) {
    clearTempFile(p);
    sqlite3_free((*p).zTempFile as *mut libc::c_void);
    (*p).zTempFile = 0 as *mut libc::c_char;
    if !(*p).db.is_null() {
        sqlite3_file_control(
            (*p).db,
            0 as *const libc::c_char,
            16 as libc::c_int,
            &mut (*p).zTempFile as *mut *mut libc::c_char as *mut libc::c_void,
        );
    }
    if (*p).zTempFile.is_null() {
        /* If p->db is an in-memory database then the TEMPFILENAME file-control
         ** will not work and we will need to fallback to guessing */
        let mut zTemp: *mut libc::c_char = 0 as *mut libc::c_char;
        let mut r: sqlite3_uint64 = 0;
        sqlite3_randomness(
            ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
            &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
        );
        zTemp = getenv(b"TEMP\x00" as *const u8 as *const libc::c_char);
        if zTemp.is_null() {
            zTemp = getenv(b"TMP\x00" as *const u8 as *const libc::c_char)
        }
        if zTemp.is_null() {
            zTemp = b"/tmp\x00" as *const u8 as *const libc::c_char as *mut libc::c_char
        }
        (*p).zTempFile = sqlite3_mprintf(
            b"%s/temp%llx.%s\x00" as *const u8 as *const libc::c_char,
            zTemp,
            r,
            zSuffix,
        )
    } else {
        (*p).zTempFile = sqlite3_mprintf(
            b"%z.%s\x00" as *const u8 as *const libc::c_char,
            (*p).zTempFile,
            zSuffix,
        )
    }
    if (*p).zTempFile.is_null() {
        shell_out_of_memory();
    };
}
/*
** The implementation of SQL scalar function fkey_collate_clause(), used
** by the ".lint fkey-indexes" command. This scalar function is always
** called with four arguments - the parent table name, the parent column name,
** the child table name and the child column name.
**
**   fkey_collate_clause('parent-tab', 'parent-col', 'child-tab', 'child-col')
**
** If either of the named tables or columns do not exist, this function
** returns an empty string. An empty string is also returned if both tables
** and columns exist but have the same default collation sequence. Or,
** if both exist but the default collation sequences are different, this
** function returns the string " COLLATE <parent-collation>", where
** <parent-collation> is the default collation sequence of the parent column.
*/
unsafe extern "C" fn shellFkeyCollateClause(
    mut pCtx: *mut sqlite3_context,
    mut _nVal: libc::c_int,
    mut apVal: *mut *mut sqlite3_value,
) {
    let mut db: *mut sqlite3 = sqlite3_context_db_handle(pCtx); /* Initialize to avoid false-positive warning */
    let mut zParent: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zParentSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChild: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildCol: *const libc::c_char = 0 as *const libc::c_char;
    let mut zChildSeq: *const libc::c_char = 0 as *const libc::c_char;
    let mut rc: libc::c_int = 0;
    zParent = sqlite3_value_text(*apVal.offset(0 as libc::c_int as isize)) as *const libc::c_char;
    zParentCol =
        sqlite3_value_text(*apVal.offset(1 as libc::c_int as isize)) as *const libc::c_char;
    zChild = sqlite3_value_text(*apVal.offset(2 as libc::c_int as isize)) as *const libc::c_char;
    zChildCol = sqlite3_value_text(*apVal.offset(3 as libc::c_int as isize)) as *const libc::c_char;
    sqlite3_result_text(
        pCtx,
        b"\x00" as *const u8 as *const libc::c_char,
        -(1 as libc::c_int),
        None,
    );
    rc = sqlite3_table_column_metadata(
        db,
        b"main\x00" as *const u8 as *const libc::c_char,
        zParent,
        zParentCol,
        0 as *mut *const libc::c_char,
        &mut zParentSeq,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
        0 as *mut libc::c_int,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_table_column_metadata(
            db,
            b"main\x00" as *const u8 as *const libc::c_char,
            zChild,
            zChildCol,
            0 as *mut *const libc::c_char,
            &mut zChildSeq,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
            0 as *mut libc::c_int,
        )
    }
    if rc == 0 as libc::c_int && sqlite3_stricmp(zParentSeq, zChildSeq) != 0 {
        let mut z: *mut libc::c_char = sqlite3_mprintf(
            b" COLLATE %s\x00" as *const u8 as *const libc::c_char,
            zParentSeq,
        );
        sqlite3_result_text(
            pCtx,
            z,
            -(1 as libc::c_int),
            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                -(1 as libc::c_int) as libc::intptr_t,
            ),
        );
        sqlite3_free(z as *mut libc::c_void);
    };
}
/*
** The implementation of dot-command ".lint fkey-indexes".
*/
unsafe extern "C" fn lintFkeyIndexes(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int
/* Number of entries in azArg[] */ {
    let mut db: *mut sqlite3 = (*pState).db; /* Database handle to query "main" db of */
    let mut out: *mut FILE = (*pState).out; /* Stream to write non-error output to */
    let mut bVerbose: libc::c_int = 0 as libc::c_int; /* If -verbose is present */
    let mut bGroupByParent: libc::c_int = 0 as libc::c_int; /* If -groupbyparent is present */
    let mut i: libc::c_int = 0; /* To iterate through azArg[] */
    let mut zIndent: *const libc::c_char = b"\x00" as *const u8 as *const libc::c_char; /* How much to indent CREATE INDEX by */
    let mut rc: libc::c_int = 0; /* Return code */
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* Compiled version of SQL statement below */
    /*
     ** This SELECT statement returns one row for each foreign key constraint
     ** in the schema of the main database. The column values are:
     **
     ** 0. The text of an SQL statement similar to:
     **
     **      "EXPLAIN QUERY PLAN SELECT 1 FROM child_table WHERE child_key=?"
     **
     **    This SELECT is similar to the one that the foreign keys implementation
     **    needs to run internally on child tables. If there is an index that can
     **    be used to optimize this query, then it can also be used by the FK
     **    implementation to optimize DELETE or UPDATE statements on the parent
     **    table.
     **
     ** 1. A GLOB pattern suitable for sqlite3_strglob(). If the plan output by
     **    the EXPLAIN QUERY PLAN command matches this pattern, then the schema
     **    contains an index that can be used to optimize the query.
     **
     ** 2. Human readable text that describes the child table and columns. e.g.
     **
     **       "child_table(child_key1, child_key2)"
     **
     ** 3. Human readable text that describes the parent table and columns. e.g.
     **
     **       "parent_table(parent_key1, parent_key2)"
     **
     ** 4. A full CREATE INDEX statement for an index that could be used to
     **    optimize DELETE or UPDATE statements on the parent table. e.g.
     **
     **       "CREATE INDEX child_table_child_key ON child_table(child_key)"
     **
     ** 5. The name of the parent table.
     **
     ** These six values are used by the C logic below to generate the report.
     */
    let mut zSql: *const libc::c_char =
        b"SELECT      \'EXPLAIN QUERY PLAN SELECT 1 FROM \' || quote(s.name) || \' WHERE \'  || group_concat(quote(s.name) || \'.\' || quote(f.[from]) || \'=?\'   || fkey_collate_clause(       f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]),\' AND \'),      \'SEARCH \' || s.name || \' USING COVERING INDEX*(\'  || group_concat(\'*=?\', \' AND \') || \')\',      s.name  || \'(\' || group_concat(f.[from],  \', \') || \')\',      f.[table] || \'(\' || group_concat(COALESCE(f.[to], p.[name])) || \')\',      \'CREATE INDEX \' || quote(s.name ||\'_\'|| group_concat(f.[from], \'_\'))  || \' ON \' || quote(s.name) || \'(\'  || group_concat(quote(f.[from]) ||        fkey_collate_clause(          f.[table], COALESCE(f.[to], p.[name]), s.name, f.[from]), \', \')  || \');\',      f.[table] FROM sqlite_schema AS s, pragma_foreign_key_list(s.name) AS f LEFT JOIN pragma_table_info AS p ON (pk-1=seq AND p.arg=f.[table]) GROUP BY s.name, f.id ORDER BY (CASE WHEN ? THEN f.[table] ELSE s.name END)\x00"
            as *const u8 as *const libc::c_char;
    let mut zGlobIPK: *const libc::c_char =
        b"SEARCH * USING INTEGER PRIMARY KEY (rowid=?)\x00" as *const u8 as *const libc::c_char;
    i = 2 as libc::c_int;
    while i < nArg {
        let mut n: libc::c_int = strlen30(*azArg.offset(i as isize));
        if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-verbose\x00" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bVerbose = 1 as libc::c_int
        } else if n > 1 as libc::c_int
            && sqlite3_strnicmp(
                b"-groupbyparent\x00" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
                n,
            ) == 0 as libc::c_int
        {
            bGroupByParent = 1 as libc::c_int;
            zIndent = b"    \x00" as *const u8 as *const libc::c_char
        } else {
            fprintf(
                stderr,
                b"Usage: %s %s ?-verbose? ?-groupbyparent?\n\x00" as *const u8
                    as *const libc::c_char,
                *azArg.offset(0 as libc::c_int as isize),
                *azArg.offset(1 as libc::c_int as isize),
            );
            return 1 as libc::c_int;
        }
        i += 1
    }
    /* Register the fkey_collate_clause() SQL function */
    rc = sqlite3_create_function(
        db,
        b"fkey_collate_clause\x00" as *const u8 as *const libc::c_char,
        4 as libc::c_int,
        1 as libc::c_int,
        0 as *mut libc::c_void,
        Some(
            shellFkeyCollateClause
                as unsafe extern "C" fn(
                    _: *mut sqlite3_context,
                    _: libc::c_int,
                    _: *mut *mut sqlite3_value,
                ) -> (),
        ),
        None,
        None,
    );
    if rc == 0 as libc::c_int {
        rc = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            &mut pSql,
            0 as *mut *const libc::c_char,
        )
    }
    if rc == 0 as libc::c_int {
        sqlite3_bind_int(pSql, 1 as libc::c_int, bGroupByParent);
    }
    if rc == 0 as libc::c_int {
        let mut rc2: libc::c_int = 0;
        let mut zPrev: *mut libc::c_char = 0 as *mut libc::c_char;
        while 100 as libc::c_int == sqlite3_step(pSql) {
            let mut res: libc::c_int = -(1 as libc::c_int);
            let mut pExplain: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zEQP: *const libc::c_char =
                sqlite3_column_text(pSql, 0 as libc::c_int) as *const libc::c_char;
            let mut zGlob: *const libc::c_char =
                sqlite3_column_text(pSql, 1 as libc::c_int) as *const libc::c_char;
            let mut zFrom: *const libc::c_char =
                sqlite3_column_text(pSql, 2 as libc::c_int) as *const libc::c_char;
            let mut zTarget: *const libc::c_char =
                sqlite3_column_text(pSql, 3 as libc::c_int) as *const libc::c_char;
            let mut zCI: *const libc::c_char =
                sqlite3_column_text(pSql, 4 as libc::c_int) as *const libc::c_char;
            let mut zParent: *const libc::c_char =
                sqlite3_column_text(pSql, 5 as libc::c_int) as *const libc::c_char;
            rc = sqlite3_prepare_v2(
                db,
                zEQP,
                -(1 as libc::c_int),
                &mut pExplain,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 as libc::c_int {
                break;
            }
            if 100 as libc::c_int == sqlite3_step(pExplain) {
                let mut zPlan: *const libc::c_char =
                    sqlite3_column_text(pExplain, 3 as libc::c_int) as *const libc::c_char;
                res = (0 as libc::c_int == sqlite3_strglob(zGlob, zPlan)
                    || 0 as libc::c_int == sqlite3_strglob(zGlobIPK, zPlan))
                    as libc::c_int
            }
            rc = sqlite3_finalize(pExplain);
            if rc != 0 as libc::c_int {
                break;
            }
            if res < 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"Error: internal error\x00" as *const u8 as *const libc::c_char,
                );
                break;
            } else {
                if bGroupByParent != 0
                    && (bVerbose != 0 || res == 0 as libc::c_int)
                    && (zPrev.is_null() || sqlite3_stricmp(zParent, zPrev) != 0)
                {
                    fprintf(
                        out,
                        b"-- Parent table %s\n\x00" as *const u8 as *const libc::c_char,
                        zParent,
                    );
                    sqlite3_free(zPrev as *mut libc::c_void);
                    zPrev = sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, zParent)
                }
                if res == 0 as libc::c_int {
                    fprintf(
                        out,
                        b"%s%s --> %s\n\x00" as *const u8 as *const libc::c_char,
                        zIndent,
                        zCI,
                        zTarget,
                    );
                } else {
                    if !(bVerbose != 0) {
                        continue;
                    }
                    fprintf(
                        out,
                        b"%s/* no extra indexes required for %s -> %s */\n\x00" as *const u8
                            as *const libc::c_char,
                        zIndent,
                        zFrom,
                        zTarget,
                    );
                }
            }
        }
        sqlite3_free(zPrev as *mut libc::c_void);
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"%s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        rc2 = sqlite3_finalize(pSql);
        if rc == 0 as libc::c_int && rc2 != 0 as libc::c_int {
            rc = rc2;
            fprintf(
                stderr,
                b"%s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
    } else {
        fprintf(
            stderr,
            b"%s\n\x00" as *const u8 as *const libc::c_char,
            sqlite3_errmsg(db),
        );
    }
    return rc;
}
/*
** Implementation of ".lint" dot command.
*/
unsafe extern "C" fn lintDotCommand(
    mut pState: *mut ShellState,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int
/* Number of entries in azArg[] */ {
    let mut n: libc::c_int = 0;
    n = if nArg >= 2 as libc::c_int {
        strlen30(*azArg.offset(1 as libc::c_int as isize))
    } else {
        0 as libc::c_int
    };
    if n < 1 as libc::c_int
        || sqlite3_strnicmp(
            *azArg.offset(1 as libc::c_int as isize),
            b"fkey-indexes\x00" as *const u8 as *const libc::c_char,
            n,
        ) != 0
    {
        fprintf(
            stderr,
            b"Usage %s sub-command ?switches...?\n\x00" as *const u8 as *const libc::c_char,
            *azArg.offset(0 as libc::c_int as isize),
        );
        fprintf(
            stderr,
            b"Where sub-commands are:\n\x00" as *const u8 as *const libc::c_char,
        );
        fprintf(
            stderr,
            b"    fkey-indexes\n\x00" as *const u8 as *const libc::c_char,
        );
        return 1 as libc::c_int;
    } else {
        return lintFkeyIndexes(pState, azArg, nArg);
    };
}
unsafe extern "C" fn shellPrepare(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut zSql: *const libc::c_char,
    mut ppStmt: *mut *mut sqlite3_stmt,
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut rc: libc::c_int = sqlite3_prepare_v2(
            db,
            zSql,
            -(1 as libc::c_int),
            ppStmt,
            0 as *mut *const libc::c_char,
        );
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"sql error: %s (%d)\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
                sqlite3_errcode(db),
            );
            *pRc = rc
        }
    };
}
/*
** Create a prepared statement using printf-style arguments for the SQL.
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/
pub unsafe extern "C" fn shellPreparePrintf(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut ppStmt: *mut *mut sqlite3_stmt,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    *ppStmt = 0 as *mut sqlite3_stmt;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::std::ffi::VaListImpl;
        let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int
        } else {
            shellPrepare(db, pRc, z, ppStmt);
            sqlite3_free(z as *mut libc::c_void);
        }
    };
}
/* Finalize the prepared statement created using shellPreparePrintf().
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/
pub unsafe extern "C" fn shellFinalize(mut pRc: *mut libc::c_int, mut pStmt: *mut sqlite3_stmt) {
    if !pStmt.is_null() {
        let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
        let mut rc: libc::c_int = sqlite3_finalize(pStmt);
        if *pRc == 0 as libc::c_int {
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"SQL error: %s\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_errmsg(db),
                );
            }
            *pRc = rc
        }
    };
}
/* Reset the prepared statement created using shellPreparePrintf().
**
** This routine is could be marked "static".  But it is not always used,
** depending on compile-time options.  By omitting the "static", we avoid
** nuisance compiler warnings about "defined but not used".
*/
pub unsafe extern "C" fn shellReset(mut pRc: *mut libc::c_int, mut pStmt: *mut sqlite3_stmt) {
    let mut rc: libc::c_int = sqlite3_reset(pStmt);
    if *pRc == 0 as libc::c_int {
        if rc != 0 as libc::c_int {
            let mut db: *mut sqlite3 = sqlite3_db_handle(pStmt);
            fprintf(
                stderr,
                b"SQL error: %s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_errmsg(db),
            );
        }
        *pRc = rc
    };
}
/* Database containing the archive */
/*
** Print a usage message for the .ar command to stderr and return SQLITE_ERROR.
*/
unsafe extern "C" fn arUsage(mut f: *mut FILE) -> libc::c_int {
    showHelp(f, b"archive\x00" as *const u8 as *const libc::c_char);
    return 1 as libc::c_int;
}
/*
** Print an error message for the .ar command to stderr and return
** SQLITE_ERROR.
*/
unsafe extern "C" fn arErrorMsg(
    mut pAr: *mut ArCommand,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> libc::c_int {
    let mut ap: ::std::ffi::VaListImpl;
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    ap = args.clone();
    z = sqlite3_vmprintf(zFmt, ap.as_va_list());
    fprintf(
        stderr,
        b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
        z,
    );
    if (*pAr).fromCmdLine != 0 {
        fprintf(
            stderr,
            b"Use \"-A\" for more help\n\x00" as *const u8 as *const libc::c_char,
        );
    } else {
        fprintf(
            stderr,
            b"Use \".archive --help\" for more help\n\x00" as *const u8 as *const libc::c_char,
        );
    }
    sqlite3_free(z as *mut libc::c_void);
    return 1 as libc::c_int;
}
unsafe extern "C" fn arProcessSwitch(
    mut pAr: *mut ArCommand,
    mut eSwitch: libc::c_int,
    mut zArg: *const libc::c_char,
) -> libc::c_int {
    let mut current_block: u64;
    match eSwitch {
        1 | 4 | 5 | 2 | 3 | 6 => {
            if (*pAr).eCmd != 0 {
                return arErrorMsg(
                    pAr,
                    b"multiple command options\x00" as *const u8 as *const libc::c_char,
                );
            } else {
                (*pAr).eCmd = eSwitch as u8_0
            }
            current_block = 11050875288958768710;
        }
        11 => {
            (*pAr).bDryRun = 1 as libc::c_int as u8_0;
            current_block = 11050875288958768710;
        }
        7 => {
            (*pAr).bVerbose = 1 as libc::c_int as u8_0;
            current_block = 11050875288958768710;
        }
        10 => {
            (*pAr).bAppend = 1 as libc::c_int as u8_0;
            current_block = 7834661514799068942;
        }
        8 => {
            current_block = 7834661514799068942;
        }
        9 => {
            (*pAr).zDir = zArg;
            current_block = 11050875288958768710;
        }
        _ => {
            current_block = 11050875288958768710;
        }
    }
    match current_block {
        7834661514799068942 =>
        /* Fall thru into --file */
        {
            (*pAr).zFile = zArg
        }
        _ => {}
    }
    return 0 as libc::c_int;
}
/*
** Parse the command line for an ".ar" command. The results are written into
** structure (*pAr). SQLITE_OK is returned if the command line is parsed
** successfully, otherwise an error message is written to stderr and
** SQLITE_ERROR returned.
*/
unsafe extern "C" fn arParseCommand(
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
    mut pAr: *mut ArCommand,
) -> libc::c_int
/* Populate this object */ {
    let mut aSwitch: [ArSwitch; 11] = [
        {
            let mut init = ArSwitch {
                zLong: b"create\x00" as *const u8 as *const libc::c_char,
                cShort: 'c' as i32 as libc::c_char,
                eSwitch: 1 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"extract\x00" as *const u8 as *const libc::c_char,
                cShort: 'x' as i32 as libc::c_char,
                eSwitch: 4 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"insert\x00" as *const u8 as *const libc::c_char,
                cShort: 'i' as i32 as libc::c_char,
                eSwitch: 3 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"list\x00" as *const u8 as *const libc::c_char,
                cShort: 't' as i32 as libc::c_char,
                eSwitch: 5 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"update\x00" as *const u8 as *const libc::c_char,
                cShort: 'u' as i32 as libc::c_char,
                eSwitch: 2 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"help\x00" as *const u8 as *const libc::c_char,
                cShort: 'h' as i32 as libc::c_char,
                eSwitch: 6 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"verbose\x00" as *const u8 as *const libc::c_char,
                cShort: 'v' as i32 as libc::c_char,
                eSwitch: 7 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"file\x00" as *const u8 as *const libc::c_char,
                cShort: 'f' as i32 as libc::c_char,
                eSwitch: 8 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"append\x00" as *const u8 as *const libc::c_char,
                cShort: 'a' as i32 as libc::c_char,
                eSwitch: 10 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"directory\x00" as *const u8 as *const libc::c_char,
                cShort: 'C' as i32 as libc::c_char,
                eSwitch: 9 as libc::c_int as u8_0,
                bArg: 1 as libc::c_int as u8_0,
            };
            init
        },
        {
            let mut init = ArSwitch {
                zLong: b"dryrun\x00" as *const u8 as *const libc::c_char,
                cShort: 'n' as i32 as libc::c_char,
                eSwitch: 11 as libc::c_int as u8_0,
                bArg: 0 as libc::c_int as u8_0,
            };
            init
        },
    ];
    let mut nSwitch: libc::c_int = (::std::mem::size_of::<[ArSwitch; 11]>() as libc::c_ulong)
        .wrapping_div(::std::mem::size_of::<ArSwitch>() as libc::c_ulong)
        as libc::c_int;
    let mut pEnd: *mut ArSwitch =
        &mut *aSwitch.as_mut_ptr().offset(nSwitch as isize) as *mut ArSwitch;
    if nArg <= 1 as libc::c_int {
        fprintf(
            stderr,
            b"Wrong number of arguments.  Usage:\n\x00" as *const u8 as *const libc::c_char,
        );
        return arUsage(stderr);
    } else {
        let mut z: *mut libc::c_char = *azArg.offset(1 as libc::c_int as isize);
        if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
            /* Traditional style [tar] invocation */
            let mut i: libc::c_int = 0;
            let mut iArg: libc::c_int = 2 as libc::c_int;
            i = 0 as libc::c_int;
            while *z.offset(i as isize) != 0 {
                let mut zArg: *const libc::c_char = 0 as *const libc::c_char;
                let mut pOpt: *mut ArSwitch = 0 as *mut ArSwitch;
                pOpt =
                    &mut *aSwitch.as_mut_ptr().offset(0 as libc::c_int as isize) as *mut ArSwitch;
                while pOpt < pEnd {
                    if *z.offset(i as isize) as libc::c_int == (*pOpt).cShort as libc::c_int {
                        break;
                    }
                    pOpt = pOpt.offset(1)
                }
                if pOpt == pEnd {
                    return arErrorMsg(
                        pAr,
                        b"unrecognized option: %c\x00" as *const u8 as *const libc::c_char,
                        *z.offset(i as isize) as libc::c_int,
                    );
                } else {
                    if (*pOpt).bArg != 0 {
                        if iArg >= nArg {
                            return arErrorMsg(
                                pAr,
                                b"option requires an argument: %c\x00" as *const u8
                                    as *const libc::c_char,
                                *z.offset(i as isize) as libc::c_int,
                            );
                        } else {
                            let fresh77 = iArg;
                            iArg = iArg + 1;
                            zArg = *azArg.offset(fresh77 as isize)
                        }
                    }
                    if arProcessSwitch(pAr, (*pOpt).eSwitch as libc::c_int, zArg) != 0 {
                        return 1 as libc::c_int;
                    } else {
                        i += 1
                    }
                }
            }
            (*pAr).nArg = nArg - iArg;
            if (*pAr).nArg > 0 as libc::c_int {
                (*pAr).azArg = &mut *azArg.offset(iArg as isize) as *mut *mut libc::c_char
            }
        } else {
            /* Non-traditional invocation */
            let mut iArg_0: libc::c_int = 0;
            iArg_0 = 1 as libc::c_int;
            while iArg_0 < nArg {
                let mut n: libc::c_int = 0;
                z = *azArg.offset(iArg_0 as isize);
                if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                    /* All remaining command line words are command arguments. */
                    (*pAr).azArg = &mut *azArg.offset(iArg_0 as isize) as *mut *mut libc::c_char;
                    (*pAr).nArg = nArg - iArg_0;
                    break;
                } else {
                    n = strlen30(z);
                    if *z.offset(1 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                        let mut i_0: libc::c_int = 0;
                        /* One or more short options */
                        i_0 = 1 as libc::c_int;
                        while i_0 < n {
                            let mut zArg_0: *const libc::c_char = 0 as *const libc::c_char;
                            let mut pOpt_0: *mut ArSwitch = 0 as *mut ArSwitch;
                            pOpt_0 = &mut *aSwitch.as_mut_ptr().offset(0 as libc::c_int as isize)
                                as *mut ArSwitch;
                            while pOpt_0 < pEnd {
                                if *z.offset(i_0 as isize) as libc::c_int
                                    == (*pOpt_0).cShort as libc::c_int
                                {
                                    break;
                                }
                                pOpt_0 = pOpt_0.offset(1)
                            }
                            if pOpt_0 == pEnd {
                                return arErrorMsg(
                                    pAr,
                                    b"unrecognized option: %c\x00" as *const u8
                                        as *const libc::c_char,
                                    *z.offset(i_0 as isize) as libc::c_int,
                                );
                            } else {
                                if (*pOpt_0).bArg != 0 {
                                    if i_0 < n - 1 as libc::c_int {
                                        zArg_0 = &mut *z.offset((i_0 + 1 as libc::c_int) as isize)
                                            as *mut libc::c_char;
                                        i_0 = n
                                    } else if iArg_0 >= nArg - 1 as libc::c_int {
                                        return arErrorMsg(
                                            pAr,
                                            b"option requires an argument: %c\x00" as *const u8
                                                as *const libc::c_char,
                                            *z.offset(i_0 as isize) as libc::c_int,
                                        );
                                    } else {
                                        iArg_0 += 1;
                                        zArg_0 = *azArg.offset(iArg_0 as isize)
                                    }
                                }
                                if arProcessSwitch(pAr, (*pOpt_0).eSwitch as libc::c_int, zArg_0)
                                    != 0
                                {
                                    return 1 as libc::c_int;
                                } else {
                                    i_0 += 1
                                }
                            }
                        }
                    } else if *z.offset(2 as libc::c_int as isize) as libc::c_int == '\u{0}' as i32
                    {
                        /* A -- option, indicating that all remaining command line words
                         ** are command arguments.  */
                        (*pAr).azArg = &mut *azArg.offset((iArg_0 + 1 as libc::c_int) as isize)
                            as *mut *mut libc::c_char;
                        (*pAr).nArg = nArg - iArg_0 - 1 as libc::c_int;
                        break;
                    } else {
                        /* A long option */
                        let mut zArg_1: *const libc::c_char = 0 as *const libc::c_char; /* Argument for option, if any */
                        let mut pMatch: *mut ArSwitch = 0 as *mut ArSwitch; /* Matching option */
                        let mut pOpt_1: *mut ArSwitch = 0 as *mut ArSwitch; /* Iterator */
                        pOpt_1 = &mut *aSwitch.as_mut_ptr().offset(0 as libc::c_int as isize)
                            as *mut ArSwitch;
                        while pOpt_1 < pEnd {
                            let mut zLong: *const libc::c_char = (*pOpt_1).zLong;
                            if n - 2 as libc::c_int <= strlen30(zLong)
                                && 0 as libc::c_int
                                    == memcmp(
                                        &mut *z.offset(2 as libc::c_int as isize)
                                            as *mut libc::c_char
                                            as *const libc::c_void,
                                        zLong as *const libc::c_void,
                                        (n - 2 as libc::c_int) as libc::c_ulong,
                                    )
                            {
                                if !pMatch.is_null() {
                                    return arErrorMsg(
                                        pAr,
                                        b"ambiguous option: %s\x00" as *const u8
                                            as *const libc::c_char,
                                        z,
                                    );
                                } else {
                                    pMatch = pOpt_1
                                }
                            }
                            pOpt_1 = pOpt_1.offset(1)
                        }
                        if pMatch.is_null() {
                            return arErrorMsg(
                                pAr,
                                b"unrecognized option: %s\x00" as *const u8 as *const libc::c_char,
                                z,
                            );
                        } else {
                            if (*pMatch).bArg != 0 {
                                if iArg_0 >= nArg - 1 as libc::c_int {
                                    return arErrorMsg(
                                        pAr,
                                        b"option requires an argument: %s\x00" as *const u8
                                            as *const libc::c_char,
                                        z,
                                    );
                                } else {
                                    iArg_0 += 1;
                                    zArg_1 = *azArg.offset(iArg_0 as isize)
                                }
                            }
                            if arProcessSwitch(pAr, (*pMatch).eSwitch as libc::c_int, zArg_1) != 0 {
                                return 1 as libc::c_int;
                            }
                        }
                    }
                    iArg_0 += 1
                }
            }
        }
        return 0 as libc::c_int;
    };
}
/*
** This function assumes that all arguments within the ArCommand.azArg[]
** array refer to archive members, as for the --extract or --list commands.
** It checks that each of them are present. If any specified file is not
** present in the archive, an error is printed to stderr and an error
** code returned. Otherwise, if all specified arguments are present in
** the archive, SQLITE_OK is returned.
**
** This function strips any trailing '/' characters from each argument.
** This is consistent with the way the [tar] command seems to work on
** Linux.
*/
unsafe extern "C" fn arCheckEntries(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int;
    if (*pAr).nArg != 0 {
        let mut i: libc::c_int = 0;
        let mut j: libc::c_int = 0;
        let mut pTest: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        shellPreparePrintf(
            (*pAr).db,
            &mut rc as *mut libc::c_int,
            &mut pTest as *mut *mut sqlite3_stmt,
            b"SELECT name FROM %s WHERE name=$name\x00" as *const u8 as *const libc::c_char,
            (*pAr).zSrcTable,
        );
        j = sqlite3_bind_parameter_index(pTest, b"$name\x00" as *const u8 as *const libc::c_char);
        i = 0 as libc::c_int;
        while i < (*pAr).nArg && rc == 0 as libc::c_int {
            let mut z: *mut libc::c_char = *(*pAr).azArg.offset(i as isize);
            let mut n: libc::c_int = strlen30(z);
            let mut bOk: libc::c_int = 0 as libc::c_int;
            while n > 0 as libc::c_int
                && *z.offset((n - 1 as libc::c_int) as isize) as libc::c_int == '/' as i32
            {
                n -= 1
            }
            *z.offset(n as isize) = '\u{0}' as i32 as libc::c_char;
            sqlite3_bind_text(pTest, j, z, -(1 as libc::c_int), None);
            if 100 as libc::c_int == sqlite3_step(pTest) {
                bOk = 1 as libc::c_int
            }
            shellReset(&mut rc, pTest);
            if rc == 0 as libc::c_int && bOk == 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"not found in archive: %s\n\x00" as *const u8 as *const libc::c_char,
                    z,
                );
                rc = 1 as libc::c_int
            }
            i += 1
        }
        shellFinalize(&mut rc, pTest);
    }
    return rc;
}
/*
** Format a WHERE clause that can be used against the "sqlar" table to
** identify all archive members that match the command arguments held
** in (*pAr). Leave this WHERE clause in (*pzWhere) before returning.
** The caller is responsible for eventually calling sqlite3_free() on
** any non-NULL (*pzWhere) value.
*/
unsafe extern "C" fn arWhereClause(
    mut pRc: *mut libc::c_int,
    mut pAr: *mut ArCommand,
    mut pzWhere: *mut *mut libc::c_char,
)
/* OUT: New WHERE clause */
{
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    if *pRc == 0 as libc::c_int {
        if (*pAr).nArg == 0 as libc::c_int {
            zWhere = sqlite3_mprintf(b"1\x00" as *const u8 as *const libc::c_char)
        } else {
            let mut i: libc::c_int = 0;
            let mut zSep: *const libc::c_char = b"\x00" as *const u8 as *const libc::c_char;
            i = 0 as libc::c_int;
            while i < (*pAr).nArg {
                let mut z: *const libc::c_char = *(*pAr).azArg.offset(i as isize);
                zWhere = sqlite3_mprintf(
                    b"%z%s name = \'%q\' OR substr(name,1,%d) = \'%q/\'\x00" as *const u8
                        as *const libc::c_char,
                    zWhere,
                    zSep,
                    z,
                    strlen30(z) + 1 as libc::c_int,
                    z,
                );
                if zWhere.is_null() {
                    *pRc = 7 as libc::c_int;
                    break;
                } else {
                    zSep = b" OR \x00" as *const u8 as *const libc::c_char;
                    i += 1
                }
            }
        }
    }
    *pzWhere = zWhere;
}
/*
** Implementation of .ar "lisT" command.
*/
unsafe extern "C" fn arListCommand(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut zSql: *const libc::c_char =
        b"SELECT %s FROM %s WHERE %s\x00" as *const u8 as *const libc::c_char;
    let mut azCols: [*const libc::c_char; 2] = [
        b"name\x00" as *const u8 as *const libc::c_char,
        b"lsmode(mode), sz, datetime(mtime, \'unixepoch\'), name\x00" as *const u8
            as *const libc::c_char,
    ];
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0;
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql,
        azCols[(*pAr).bVerbose as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if (*pAr).bDryRun != 0 {
        fprintf(
            (*(*pAr).p).out,
            b"%s\n\x00" as *const u8 as *const libc::c_char,
            sqlite3_sql(pSql),
        );
    } else {
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
            if (*pAr).bVerbose != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s % 10d  %s  %s\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                    sqlite3_column_int(pSql, 1 as libc::c_int),
                    sqlite3_column_text(pSql, 2 as libc::c_int),
                    sqlite3_column_text(pSql, 3 as libc::c_int),
                );
            } else {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_column_text(pSql, 0 as libc::c_int),
                );
            }
        }
    }
    shellFinalize(&mut rc, pSql);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
/*
** Implementation of .ar "eXtract" command.
*/
unsafe extern "C" fn arExtractCommand(mut pAr: *mut ArCommand) -> libc::c_int {
    let mut zSql1: *const libc::c_char =
        b"SELECT  ($dir || name), writefile(($dir || name), %s, mode, mtime) FROM %s WHERE (%s) AND (data IS NULL OR $dirOnly = 0) AND name NOT GLOB \'*..[/\\]*\'\x00"
            as *const u8 as *const libc::c_char;
    let mut azExtraArg: [*const libc::c_char; 2] = [
        b"sqlar_uncompress(data, sz)\x00" as *const u8 as *const libc::c_char,
        b"data\x00" as *const u8 as *const libc::c_char,
    ];
    let mut pSql: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut zDir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zWhere: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut i: libc::c_int = 0;
    let mut j: libc::c_int = 0;
    /* If arguments are specified, check that they actually exist within
     ** the archive before proceeding. And formulate a WHERE clause to
     ** match them.  */
    rc = arCheckEntries(pAr);
    arWhereClause(&mut rc, pAr, &mut zWhere);
    if rc == 0 as libc::c_int {
        if !(*pAr).zDir.is_null() {
            zDir = sqlite3_mprintf(b"%s/\x00" as *const u8 as *const libc::c_char, (*pAr).zDir)
        } else {
            zDir = sqlite3_mprintf(b"\x00" as *const u8 as *const libc::c_char)
        }
        if zDir.is_null() {
            rc = 7 as libc::c_int
        }
    }
    shellPreparePrintf(
        (*pAr).db,
        &mut rc as *mut libc::c_int,
        &mut pSql as *mut *mut sqlite3_stmt,
        zSql1,
        azExtraArg[(*pAr).bZip as usize],
        (*pAr).zSrcTable,
        zWhere,
    );
    if rc == 0 as libc::c_int {
        j = sqlite3_bind_parameter_index(pSql, b"$dir\x00" as *const u8 as *const libc::c_char);
        sqlite3_bind_text(pSql, j, zDir, -(1 as libc::c_int), None);
        /* Run the SELECT statement twice. The first time, writefile() is called
         ** for all archive members that should be extracted. The second time,
         ** only for the directories. This is because the timestamps for
         ** extracted directories must be reset after they are populated (as
         ** populating them changes the timestamp).  */
        i = 0 as libc::c_int;
        while i < 2 as libc::c_int {
            j = sqlite3_bind_parameter_index(
                pSql,
                b"$dirOnly\x00" as *const u8 as *const libc::c_char,
            );
            sqlite3_bind_int(pSql, j, i);
            if (*pAr).bDryRun != 0 {
                fprintf(
                    (*(*pAr).p).out,
                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_sql(pSql),
                );
            } else {
                while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pSql) {
                    if !(i == 0 as libc::c_int && (*pAr).bVerbose as libc::c_int != 0) {
                        continue;
                    }
                    fprintf(
                        (*(*pAr).p).out,
                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                        sqlite3_column_text(pSql, 0 as libc::c_int),
                    );
                }
            }
            shellReset(&mut rc, pSql);
            i += 1
        }
        shellFinalize(&mut rc, pSql);
    }
    sqlite3_free(zDir as *mut libc::c_void);
    sqlite3_free(zWhere as *mut libc::c_void);
    return rc;
}
/*
** Run the SQL statement in zSql.  Or if doing a --dryrun, merely print it out.
*/
unsafe extern "C" fn arExecSql(
    mut pAr: *mut ArCommand,
    mut zSql: *const libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if (*pAr).bDryRun != 0 {
        fprintf(
            (*(*pAr).p).out,
            b"%s\n\x00" as *const u8 as *const libc::c_char,
            zSql,
        );
        rc = 0 as libc::c_int
    } else {
        let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
        rc = sqlite3_exec((*pAr).db, zSql, None, 0 as *mut libc::c_void, &mut zErr);
        if !zErr.is_null() {
            fprintf(
                stdout,
                b"ERROR: %s\n\x00" as *const u8 as *const libc::c_char,
                zErr,
            );
            sqlite3_free(zErr as *mut libc::c_void);
        }
    }
    return rc;
}
/*
** Implementation of .ar "create", "insert", and "update" commands.
**
**     create    ->     Create a new SQL archive
**     insert    ->     Insert or reinsert all files listed
**     update    ->     Insert files that have changed or that were not
**                      previously in the archive
**
** Create the "sqlar" table in the database if it does not already exist.
** Then add each file in the azFile[] array to the archive. Directories
** are added recursively. If argument bVerbose is non-zero, a message is
** printed on stdout for each file archived.
**
** The create command is the same as update, except that it drops
** any existing "sqlar" table before beginning.  The "insert" command
** always overwrites every file named on the command-line, where as
** "update" only overwrites if the size or mtime or mode has changed.
*/
unsafe extern "C" fn arCreateOrUpdateCommand(
    mut pAr: *mut ArCommand,
    mut bUpdate: libc::c_int,
    mut bOnlyIfChanged: libc::c_int,
) -> libc::c_int
/* Only update if file has changed */ {
    let mut current_block: u64; /* For iterating through azFile[] */
    let mut zCreate: *const libc::c_char =
        b"CREATE TABLE IF NOT EXISTS sqlar(\n  name TEXT PRIMARY KEY,  -- name of the file\n  mode INT,               -- access permissions\n  mtime INT,              -- last modification time\n  sz INT,                 -- original file size\n  data BLOB               -- compressed content\n)\x00"
            as *const u8 as *const libc::c_char; /* Return code */
    let mut zDrop: *const libc::c_char =
        b"DROP TABLE IF EXISTS sqlar\x00" as *const u8 as *const libc::c_char; /* SQL table into which to insert */
    let mut zInsertFmt: [*const libc::c_char; 2] =
        [b"REPLACE INTO %s(name,mode,mtime,sz,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    CASE substr(lsmode(mode),1,1)\n      WHEN \'-\' THEN length(data)\n      WHEN \'d\' THEN 0\n      ELSE -1 END,\n    sqlar_compress(data)\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE \'?%%\'%s;\x00"
             as *const u8 as *const libc::c_char,
         b"REPLACE INTO %s(name,mode,mtime,data)\n  SELECT\n    %s,\n    mode,\n    mtime,\n    data\n  FROM fsdir(%Q,%Q) AS disk\n  WHERE lsmode(mode) NOT LIKE \'?%%\'%s;\x00"
             as *const u8 as *const libc::c_char];
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0;
    let mut zTab: *const libc::c_char = 0 as *const libc::c_char;
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut zTemp: [libc::c_char; 50] = [0; 50];
    let mut zExists: *mut libc::c_char = 0 as *mut libc::c_char;
    arExecSql(
        pAr,
        b"PRAGMA page_size=512\x00" as *const u8 as *const libc::c_char,
    );
    rc = arExecSql(
        pAr,
        b"SAVEPOINT ar;\x00" as *const u8 as *const libc::c_char,
    );
    if rc != 0 as libc::c_int {
        return rc;
    } else {
        zTemp[0 as libc::c_int as usize] = 0 as libc::c_int as libc::c_char;
        if (*pAr).bZip != 0 {
            /* Initialize the zipfile virtual table, if necessary */
            if !(*pAr).zFile.is_null() {
                let mut r: sqlite3_uint64 = 0;
                sqlite3_randomness(
                    ::std::mem::size_of::<sqlite3_uint64>() as libc::c_ulong as libc::c_int,
                    &mut r as *mut sqlite3_uint64 as *mut libc::c_void,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 50]>() as libc::c_ulong as libc::c_int,
                    zTemp.as_mut_ptr(),
                    b"zip%016llx\x00" as *const u8 as *const libc::c_char,
                    r,
                );
                zTab = zTemp.as_mut_ptr();
                zSql = sqlite3_mprintf(
                    b"CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)\x00" as *const u8
                        as *const libc::c_char,
                    zTab,
                    (*pAr).zFile,
                );
                rc = arExecSql(pAr, zSql);
                sqlite3_free(zSql as *mut libc::c_void);
            } else {
                zTab = b"zip\x00" as *const u8 as *const libc::c_char
            }
            current_block = 18317007320854588510;
        } else {
            /* Initialize the table for an SQLAR */
            zTab = b"sqlar\x00" as *const u8 as *const libc::c_char;
            if bUpdate == 0 as libc::c_int {
                rc = arExecSql(pAr, zDrop);
                if rc != 0 as libc::c_int {
                    current_block = 7718183590879281928;
                } else {
                    current_block = 224731115979188411;
                }
            } else {
                current_block = 224731115979188411;
            }
            match current_block {
                7718183590879281928 => {}
                _ => {
                    rc = arExecSql(pAr, zCreate);
                    current_block = 18317007320854588510;
                }
            }
        }
        match current_block {
            18317007320854588510 => {
                if bOnlyIfChanged != 0 {
                    zExists =
                        sqlite3_mprintf(b" AND NOT EXISTS(SELECT 1 FROM %s AS mem WHERE mem.name=disk.name AND mem.mtime=disk.mtime AND mem.mode=disk.mode)\x00"
                                            as *const u8 as
                                            *const libc::c_char, zTab)
                } else {
                    zExists = sqlite3_mprintf(b"\x00" as *const u8 as *const libc::c_char)
                }
                if zExists.is_null() {
                    rc = 7 as libc::c_int
                }
                i = 0 as libc::c_int;
                while i < (*pAr).nArg && rc == 0 as libc::c_int {
                    let mut zSql2: *mut libc::c_char = sqlite3_mprintf(
                        zInsertFmt[(*pAr).bZip as usize],
                        zTab,
                        if (*pAr).bVerbose as libc::c_int != 0 {
                            b"shell_putsnl(name)\x00" as *const u8 as *const libc::c_char
                        } else {
                            b"name\x00" as *const u8 as *const libc::c_char
                        },
                        *(*pAr).azArg.offset(i as isize),
                        (*pAr).zDir,
                        zExists,
                    );
                    rc = arExecSql(pAr, zSql2);
                    sqlite3_free(zSql2 as *mut libc::c_void);
                    i += 1
                }
            }
            _ => {}
        }
        if rc != 0 as libc::c_int {
            sqlite3_exec(
                (*pAr).db,
                b"ROLLBACK TO ar; RELEASE ar;\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
        } else {
            rc = arExecSql(pAr, b"RELEASE ar;\x00" as *const u8 as *const libc::c_char);
            if (*pAr).bZip as libc::c_int != 0 && !(*pAr).zFile.is_null() {
                zSql = sqlite3_mprintf(
                    b"DROP TABLE %s\x00" as *const u8 as *const libc::c_char,
                    zTemp.as_mut_ptr(),
                );
                arExecSql(pAr, zSql);
                sqlite3_free(zSql as *mut libc::c_void);
            }
        }
        sqlite3_free(zExists as *mut libc::c_void);
        return rc;
    };
}
/*
** Implementation of ".ar" dot command.
*/
unsafe extern "C" fn arDotCommand(
    mut pState: *mut ShellState,
    mut fromCmdLine: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
    mut nArg: libc::c_int,
) -> libc::c_int
/* Number of entries in azArg[] */ {
    let mut current_block: u64;
    let mut cmd: ArCommand = ArCommand {
        eCmd: 0,
        bVerbose: 0,
        bZip: 0,
        bDryRun: 0,
        bAppend: 0,
        fromCmdLine: 0,
        nArg: 0,
        zSrcTable: 0 as *mut libc::c_char,
        zFile: 0 as *const libc::c_char,
        zDir: 0 as *const libc::c_char,
        azArg: 0 as *mut *mut libc::c_char,
        p: 0 as *mut ShellState,
        db: 0 as *mut sqlite3,
    };
    let mut rc: libc::c_int = 0;
    memset(
        &mut cmd as *mut ArCommand as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ArCommand>() as libc::c_ulong,
    );
    cmd.fromCmdLine = fromCmdLine as u8_0;
    rc = arParseCommand(azArg, nArg, &mut cmd);
    if rc == 0 as libc::c_int {
        let mut eDbType: libc::c_int = 0 as libc::c_int;
        cmd.p = pState;
        cmd.db = (*pState).db;
        if !cmd.zFile.is_null() {
            eDbType = deduceDatabaseType(cmd.zFile, 1 as libc::c_int)
        } else {
            eDbType = (*pState).openMode as libc::c_int
        }
        if eDbType == 3 as libc::c_int {
            if cmd.eCmd as libc::c_int == 4 as libc::c_int
                || cmd.eCmd as libc::c_int == 5 as libc::c_int
            {
                if cmd.zFile.is_null() {
                    cmd.zSrcTable = sqlite3_mprintf(b"zip\x00" as *const u8 as *const libc::c_char)
                } else {
                    cmd.zSrcTable = sqlite3_mprintf(
                        b"zipfile(%Q)\x00" as *const u8 as *const libc::c_char,
                        cmd.zFile,
                    )
                }
            }
            cmd.bZip = 1 as libc::c_int as u8_0;
            current_block = 2569451025026770673;
        } else if !cmd.zFile.is_null() {
            let mut flags: libc::c_int = 0;
            if cmd.bAppend != 0 {
                eDbType = 2 as libc::c_int
            }
            if cmd.eCmd as libc::c_int == 1 as libc::c_int
                || cmd.eCmd as libc::c_int == 3 as libc::c_int
                || cmd.eCmd as libc::c_int == 2 as libc::c_int
            {
                flags = 0x2 as libc::c_int | 0x4 as libc::c_int
            } else {
                flags = 0x1 as libc::c_int
            }
            cmd.db = 0 as *mut sqlite3;
            if cmd.bDryRun != 0 {
                fprintf(
                    (*pState).out,
                    b"-- open database \'%s\'%s\n\x00" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    if eDbType == 2 as libc::c_int {
                        b" using \'apndvfs\'\x00" as *const u8 as *const libc::c_char
                    } else {
                        b"\x00" as *const u8 as *const libc::c_char
                    },
                );
            }
            rc = sqlite3_open_v2(
                cmd.zFile,
                &mut cmd.db,
                flags,
                if eDbType == 2 as libc::c_int {
                    b"apndvfs\x00" as *const u8 as *const libc::c_char
                } else {
                    0 as *const libc::c_char
                },
            );
            if rc != 0 as libc::c_int {
                fprintf(
                    stderr,
                    b"cannot open file: %s (%s)\n\x00" as *const u8 as *const libc::c_char,
                    cmd.zFile,
                    sqlite3_errmsg(cmd.db),
                );
                current_block = 14467174130012904307;
            } else {
                sqlite3_fileio_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_sqlar_init(
                    cmd.db,
                    0 as *mut *mut libc::c_char,
                    0 as *const sqlite3_api_routines,
                );
                sqlite3_create_function(
                    cmd.db,
                    b"shell_putsnl\x00" as *const u8 as *const libc::c_char,
                    1 as libc::c_int,
                    1 as libc::c_int,
                    cmd.p as *mut libc::c_void,
                    Some(
                        shellPutsFunc
                            as unsafe extern "C" fn(
                                _: *mut sqlite3_context,
                                _: libc::c_int,
                                _: *mut *mut sqlite3_value,
                            ) -> (),
                    ),
                    None,
                    None,
                );
                current_block = 2569451025026770673;
            }
        } else {
            current_block = 2569451025026770673;
        }
        match current_block {
            14467174130012904307 => {}
            _ => {
                if cmd.zSrcTable.is_null()
                    && cmd.bZip as libc::c_int == 0 as libc::c_int
                    && cmd.eCmd as libc::c_int != 6 as libc::c_int
                {
                    if cmd.eCmd as libc::c_int != 1 as libc::c_int
                        && sqlite3_table_column_metadata(
                            cmd.db,
                            0 as *const libc::c_char,
                            b"sqlar\x00" as *const u8 as *const libc::c_char,
                            b"name\x00" as *const u8 as *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut *const libc::c_char,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                            0 as *mut libc::c_int,
                        ) != 0
                    {
                        fprintf(
                            stderr,
                            b"database does not contain an \'sqlar\' table\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 14467174130012904307;
                    } else {
                        cmd.zSrcTable =
                            sqlite3_mprintf(b"sqlar\x00" as *const u8 as *const libc::c_char);
                        current_block = 1836292691772056875;
                    }
                } else {
                    current_block = 1836292691772056875;
                }
                match current_block {
                    14467174130012904307 => {}
                    _ => match cmd.eCmd as libc::c_int {
                        1 => {
                            rc = arCreateOrUpdateCommand(
                                &mut cmd,
                                0 as libc::c_int,
                                0 as libc::c_int,
                            )
                        }
                        4 => rc = arExtractCommand(&mut cmd),
                        5 => rc = arListCommand(&mut cmd),
                        6 => {
                            arUsage((*pState).out);
                        }
                        3 => {
                            rc = arCreateOrUpdateCommand(
                                &mut cmd,
                                1 as libc::c_int,
                                0 as libc::c_int,
                            )
                        }
                        _ => {
                            rc = arCreateOrUpdateCommand(
                                &mut cmd,
                                1 as libc::c_int,
                                1 as libc::c_int,
                            )
                        }
                    },
                }
            }
        }
    }
    if cmd.db != (*pState).db {
        close_db(cmd.db);
    }
    sqlite3_free(cmd.zSrcTable as *mut libc::c_void);
    return rc;
}
/* End of the ".archive" or ".ar" command logic
*******************************************************************************/
/* !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB) */
/*
** If (*pRc) is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, the SQL statement or statements in zSql are executed using
** database connection db and the error code written to *pRc before
** this function returns.
*/
unsafe extern "C" fn shellExec(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut zSql: *const libc::c_char,
) {
    let mut rc: libc::c_int = *pRc;
    if rc == 0 as libc::c_int {
        let mut zErr: *mut libc::c_char = 0 as *mut libc::c_char;
        rc = sqlite3_exec(db, zSql, None, 0 as *mut libc::c_void, &mut zErr);
        if rc != 0 as libc::c_int {
            fprintf(
                stderr,
                b"SQL error: %s\n\x00" as *const u8 as *const libc::c_char,
                zErr,
            );
        }
        sqlite3_free(zErr as *mut libc::c_void);
        *pRc = rc
    };
}
/*
** Like shellExec(), except that zFmt is a printf() style format string.
*/
unsafe extern "C" fn shellExecPrintf(
    mut db: *mut sqlite3,
    mut pRc: *mut libc::c_int,
    mut zFmt: *const libc::c_char,
    mut args: ...
) {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::std::ffi::VaListImpl;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int
        } else {
            shellExec(db, pRc, z);
        }
        sqlite3_free(z as *mut libc::c_void);
    };
}
/*
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, an attempt is made to allocate, zero and return a pointer
** to a buffer nByte bytes in size. If an OOM error occurs, *pRc is set
** to SQLITE_NOMEM and NULL returned.
*/
unsafe extern "C" fn shellMalloc(
    mut pRc: *mut libc::c_int,
    mut nByte: sqlite3_int64,
) -> *mut libc::c_void {
    let mut pRet: *mut libc::c_void = 0 as *mut libc::c_void;
    if *pRc == 0 as libc::c_int {
        pRet = sqlite3_malloc64(nByte as sqlite3_uint64);
        if pRet.is_null() {
            *pRc = 7 as libc::c_int
        } else {
            memset(pRet, 0 as libc::c_int, nByte as libc::c_ulong);
        }
    }
    return pRet;
}
/*
** If *pRc is not SQLITE_OK when this function is called, it is a no-op.
** Otherwise, zFmt is treated as a printf() style string. The result of
** formatting it along with any trailing arguments is written into a
** buffer obtained from sqlite3_malloc(), and pointer to which is returned.
** It is the responsibility of the caller to eventually free this buffer
** using a call to sqlite3_free().
**
** If an OOM error occurs, (*pRc) is set to SQLITE_NOMEM and a NULL
** pointer returned.
*/
unsafe extern "C" fn shellMPrintf(
    mut pRc: *mut libc::c_int,
    mut zFmt: *const libc::c_char,
    mut args: ...
) -> *mut libc::c_char {
    let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
    if *pRc == 0 as libc::c_int {
        let mut ap: ::std::ffi::VaListImpl;
        ap = args.clone();
        z = sqlite3_vmprintf(zFmt, ap.as_va_list());
        if z.is_null() {
            *pRc = 7 as libc::c_int
        }
    }
    return z;
}
/* Index of IPK column */
/*
** Free a RecoverTable object allocated by recoverFindTable() or
** recoverOrphanTable().
*/
unsafe extern "C" fn recoverFreeTable(mut pTab: *mut RecoverTable) {
    if !pTab.is_null() {
        sqlite3_free((*pTab).zQuoted as *mut libc::c_void);
        if !(*pTab).azlCol.is_null() {
            let mut i: libc::c_int = 0;
            i = 0 as libc::c_int;
            while i <= (*pTab).nCol {
                sqlite3_free(*(*pTab).azlCol.offset(i as isize) as *mut libc::c_void);
                i += 1
            }
            sqlite3_free((*pTab).azlCol as *mut libc::c_void);
        }
        sqlite3_free(pTab as *mut libc::c_void);
    };
}
/*
** This function is a no-op if (*pRc) is not SQLITE_OK when it is called.
** Otherwise, it allocates and returns a RecoverTable object based on the
** final four arguments passed to this function. It is the responsibility
** of the caller to eventually free the returned object using
** recoverFreeTable().
*/
unsafe extern "C" fn recoverNewTable(
    mut pRc: *mut libc::c_int,
    mut zName: *const libc::c_char,
    mut zSql: *const libc::c_char,
    mut bIntkey: libc::c_int,
    mut nCol: libc::c_int,
) -> *mut RecoverTable {
    let mut current_block: u64; /* sqlite3 handle for testing CREATE TABLE */
    let mut dbtmp: *mut sqlite3 = 0 as *mut sqlite3;
    let mut rc: libc::c_int = *pRc;
    let mut pTab: *mut RecoverTable = 0 as *mut RecoverTable;
    pTab = shellMalloc(
        &mut rc,
        ::std::mem::size_of::<RecoverTable>() as libc::c_ulong as sqlite3_int64,
    ) as *mut RecoverTable;
    if rc == 0 as libc::c_int {
        let mut nSqlCol: libc::c_int = 0 as libc::c_int;
        let mut bSqlIntkey: libc::c_int = 0 as libc::c_int;
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        rc = sqlite3_open(b"\x00" as *const u8 as *const libc::c_char, &mut dbtmp);
        if rc == 0 as libc::c_int {
            sqlite3_create_function(
                dbtmp,
                b"shell_idquote\x00" as *const u8 as *const libc::c_char,
                1 as libc::c_int,
                1 as libc::c_int,
                0 as *mut libc::c_void,
                Some(
                    shellIdQuote
                        as unsafe extern "C" fn(
                            _: *mut sqlite3_context,
                            _: libc::c_int,
                            _: *mut *mut sqlite3_value,
                        ) -> (),
                ),
                None,
                None,
            );
        }
        if rc == 0 as libc::c_int {
            rc = sqlite3_exec(
                dbtmp,
                b"PRAGMA writable_schema = on\x00" as *const u8 as *const libc::c_char,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            )
        }
        if rc == 0 as libc::c_int {
            rc = sqlite3_exec(
                dbtmp,
                zSql,
                None,
                0 as *mut libc::c_void,
                0 as *mut *mut libc::c_char,
            );
            if rc == 1 as libc::c_int {
                rc = 0 as libc::c_int;
                current_block = 2620289773430115229;
            } else {
                current_block = 12349973810996921269;
            }
        } else {
            current_block = 12349973810996921269;
        }
        match current_block {
            2620289773430115229 => {}
            _ => {
                shellPreparePrintf(
                    dbtmp,
                    &mut rc as *mut libc::c_int,
                    &mut pStmt as *mut *mut sqlite3_stmt,
                    b"SELECT count(*) FROM pragma_table_info(%Q)\x00" as *const u8
                        as *const libc::c_char,
                    zName,
                );
                if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt) {
                    nSqlCol = sqlite3_column_int(pStmt, 0 as libc::c_int)
                }
                shellFinalize(&mut rc, pStmt);
                if !(rc != 0 as libc::c_int || nSqlCol < nCol) {
                    shellPreparePrintf(dbtmp, &mut rc as *mut libc::c_int,
                                       &mut pStmt as *mut *mut sqlite3_stmt,
                                       b"SELECT (  SELECT substr(data,1,1)==X\'0D\' FROM sqlite_dbpage WHERE pgno=rootpage) FROM sqlite_schema WHERE name = %Q\x00"
                                           as *const u8 as
                                           *const libc::c_char, zName);
                    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt) {
                        bSqlIntkey = sqlite3_column_int(pStmt, 0 as libc::c_int)
                    }
                    shellFinalize(&mut rc, pStmt);
                    if bIntkey == bSqlIntkey {
                        let mut i: libc::c_int = 0;
                        let mut zPk: *const libc::c_char =
                            b"_rowid_\x00" as *const u8 as *const libc::c_char;
                        let mut pPkFinder: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                        /* If this is an intkey table and there is an INTEGER PRIMARY KEY,
                         ** set zPk to the name of the PK column, and pTab->iPk to the index
                         ** of the column, where columns are 0-numbered from left to right.
                         ** Or, if this is a WITHOUT ROWID table or if there is no IPK column,
                         ** leave zPk as "_rowid_" and pTab->iPk at -2.  */
                        (*pTab).iPk = -(2 as libc::c_int);
                        if bIntkey != 0 {
                            shellPreparePrintf(dbtmp,
                                               &mut rc as *mut libc::c_int,
                                               &mut pPkFinder as
                                                   *mut *mut sqlite3_stmt,
                                               b"SELECT cid, name FROM pragma_table_info(%Q)   WHERE pk=1 AND type=\'integer\' COLLATE nocase  AND NOT EXISTS (SELECT cid FROM pragma_table_info(%Q) WHERE pk=2)\x00"
                                                   as *const u8 as
                                                   *const libc::c_char, zName,
                                               zName);
                            if rc == 0 as libc::c_int
                                && 100 as libc::c_int == sqlite3_step(pPkFinder)
                            {
                                (*pTab).iPk = sqlite3_column_int(pPkFinder, 0 as libc::c_int);
                                zPk = sqlite3_column_text(pPkFinder, 1 as libc::c_int)
                                    as *const libc::c_char
                            }
                        }
                        (*pTab).zQuoted = shellMPrintf(
                            &mut rc as *mut libc::c_int,
                            b"\"%w\"\x00" as *const u8 as *const libc::c_char,
                            zName,
                        );
                        (*pTab).azlCol = shellMalloc(
                            &mut rc,
                            (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                                .wrapping_mul((nSqlCol + 1 as libc::c_int) as libc::c_ulong)
                                as sqlite3_int64,
                        ) as *mut *mut libc::c_char;
                        (*pTab).nCol = nSqlCol;
                        if bIntkey != 0 {
                            let ref mut fresh78 = *(*pTab).azlCol.offset(0 as libc::c_int as isize);
                            *fresh78 = shellMPrintf(
                                &mut rc as *mut libc::c_int,
                                b"\"%w\"\x00" as *const u8 as *const libc::c_char,
                                zPk,
                            )
                        } else {
                            let ref mut fresh79 = *(*pTab).azlCol.offset(0 as libc::c_int as isize);
                            *fresh79 = shellMPrintf(
                                &mut rc as *mut libc::c_int,
                                b"\x00" as *const u8 as *const libc::c_char,
                            )
                        }
                        i = 1 as libc::c_int;
                        shellPreparePrintf(dbtmp, &mut rc as *mut libc::c_int,
                                           &mut pStmt as
                                               *mut *mut sqlite3_stmt,
                                           b"SELECT %Q || group_concat(shell_idquote(name), \', \')   FILTER (WHERE cid!=%d) OVER (ORDER BY %s cid) FROM pragma_table_info(%Q)\x00"
                                               as *const u8 as
                                               *const libc::c_char,
                                           if bIntkey != 0 {
                                               b", \x00" as *const u8 as
                                                   *const libc::c_char
                                           } else {
                                               b"\x00" as *const u8 as
                                                   *const libc::c_char
                                           }, (*pTab).iPk,
                                           if bIntkey != 0 {
                                               b"\x00" as *const u8 as
                                                   *const libc::c_char
                                           } else {
                                               b"(CASE WHEN pk=0 THEN 1000000 ELSE pk END), \x00"
                                                   as *const u8 as
                                                   *const libc::c_char
                                           }, zName);
                        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt) {
                            let mut zText: *const libc::c_char =
                                sqlite3_column_text(pStmt, 0 as libc::c_int) as *const libc::c_char;
                            let ref mut fresh80 = *(*pTab).azlCol.offset(i as isize);
                            *fresh80 = shellMPrintf(
                                &mut rc as *mut libc::c_int,
                                b"%s%s\x00" as *const u8 as *const libc::c_char,
                                *(*pTab).azlCol.offset(0 as libc::c_int as isize),
                                zText,
                            );
                            i += 1
                        }
                        shellFinalize(&mut rc, pStmt);
                        shellFinalize(&mut rc, pPkFinder);
                    }
                }
            }
        }
    }
    sqlite3_close(dbtmp);
    *pRc = rc;
    if rc != 0 as libc::c_int || !pTab.is_null() && (*pTab).zQuoted.is_null() {
        recoverFreeTable(pTab);
        pTab = 0 as *mut RecoverTable
    }
    return pTab;
}
/*
** This function is called to search the schema recovered from the
** sqlite_schema table of the (possibly) corrupt database as part
** of a ".recover" command. Specifically, for a table with root page
** iRoot and at least nCol columns. Additionally, if bIntkey is 0, the
** table must be a WITHOUT ROWID table, or if non-zero, not one of
** those.
**
** If a table is found, a (RecoverTable*) object is returned. Or, if
** no such table is found, but bIntkey is false and iRoot is the
** root page of an index in the recovered schema, then (*pbNoop) is
** set to true and NULL returned. Or, if there is no such table or
** index, NULL is returned and (*pbNoop) set to 0, indicating that
** the caller should write data to the orphans table.
*/
unsafe extern "C" fn recoverFindTable(
    mut pState: *mut ShellState,
    mut pRc: *mut libc::c_int,
    mut iRoot: libc::c_int,
    mut bIntkey: libc::c_int,
    mut nCol: libc::c_int,
    mut pbNoop: *mut libc::c_int,
) -> *mut RecoverTable
/* OUT: True if iRoot is root of index */ {
    let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
    let mut pRet: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut bNoop: libc::c_int = 0 as libc::c_int;
    let mut zSql: *const libc::c_char = 0 as *const libc::c_char;
    let mut zName: *const libc::c_char = 0 as *const libc::c_char;
    /* Search the recovered schema for an object with root page iRoot. */
    shellPreparePrintf(
        (*pState).db,
        pRc,
        &mut pStmt as *mut *mut sqlite3_stmt,
        b"SELECT type, name, sql FROM recovery.schema WHERE rootpage=%d\x00" as *const u8
            as *const libc::c_char,
        iRoot,
    );
    while *pRc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt) {
        let mut zType: *const libc::c_char =
            sqlite3_column_text(pStmt, 0 as libc::c_int) as *const libc::c_char;
        if bIntkey == 0 as libc::c_int
            && sqlite3_stricmp(zType, b"index\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
        {
            bNoop = 1 as libc::c_int;
            break;
        } else {
            if !(sqlite3_stricmp(zType, b"table\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int)
            {
                continue;
            }
            zName = sqlite3_column_text(pStmt, 1 as libc::c_int) as *const libc::c_char;
            zSql = sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char;
            pRet = recoverNewTable(pRc, zName, zSql, bIntkey, nCol);
            break;
        }
    }
    shellFinalize(pRc, pStmt);
    *pbNoop = bNoop;
    return pRet;
}
/*
** Return a RecoverTable object representing the orphans table.
*/
unsafe extern "C" fn recoverOrphanTable(
    mut pState: *mut ShellState,
    mut pRc: *mut libc::c_int,
    mut zLostAndFound: *const libc::c_char,
    mut nCol: libc::c_int,
) -> *mut RecoverTable
/* Number of user data columns */ {
    let mut pTab: *mut RecoverTable = 0 as *mut RecoverTable;
    if nCol >= 0 as libc::c_int && *pRc == 0 as libc::c_int {
        let mut i: libc::c_int = 0;
        /* This block determines the name of the orphan table. The prefered
         ** name is zLostAndFound. But if that clashes with another name
         ** in the recovered schema, try zLostAndFound_0, zLostAndFound_1
         ** and so on until a non-clashing name is found.  */
        let mut iTab: libc::c_int = 0 as libc::c_int;
        let mut zTab: *mut libc::c_char = shellMPrintf(
            pRc,
            b"%s\x00" as *const u8 as *const libc::c_char,
            zLostAndFound,
        );
        let mut pTest: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        shellPrepare(
            (*pState).db,
            pRc,
            b"SELECT 1 FROM recovery.schema WHERE name=?\x00" as *const u8 as *const libc::c_char,
            &mut pTest,
        );
        if !pTest.is_null() {
            sqlite3_bind_text(
                pTest,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        while *pRc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pTest) {
            shellReset(pRc, pTest);
            sqlite3_free(zTab as *mut libc::c_void);
            let fresh81 = iTab;
            iTab = iTab + 1;
            zTab = shellMPrintf(
                pRc,
                b"%s_%d\x00" as *const u8 as *const libc::c_char,
                zLostAndFound,
                fresh81,
            );
            sqlite3_bind_text(
                pTest,
                1 as libc::c_int,
                zTab,
                -(1 as libc::c_int),
                ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                    -(1 as libc::c_int) as libc::intptr_t,
                ),
            );
        }
        shellFinalize(pRc, pTest);
        pTab = shellMalloc(
            pRc,
            ::std::mem::size_of::<RecoverTable>() as libc::c_ulong as sqlite3_int64,
        ) as *mut RecoverTable;
        if !pTab.is_null() {
            (*pTab).zQuoted =
                shellMPrintf(pRc, b"\"%w\"\x00" as *const u8 as *const libc::c_char, zTab);
            (*pTab).nCol = nCol;
            (*pTab).iPk = -(2 as libc::c_int);
            if nCol > 0 as libc::c_int {
                (*pTab).azlCol = shellMalloc(
                    pRc,
                    (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                        .wrapping_mul((nCol + 1 as libc::c_int) as libc::c_ulong)
                        as sqlite3_int64,
                ) as *mut *mut libc::c_char;
                if !(*pTab).azlCol.is_null() {
                    let ref mut fresh82 = *(*pTab).azlCol.offset(nCol as isize);
                    *fresh82 = shellMPrintf(pRc, b"\x00" as *const u8 as *const libc::c_char);
                    i = nCol - 1 as libc::c_int;
                    while i >= 0 as libc::c_int {
                        let ref mut fresh83 = *(*pTab).azlCol.offset(i as isize);
                        *fresh83 = shellMPrintf(
                            pRc,
                            b"%s, NULL\x00" as *const u8 as *const libc::c_char,
                            *(*pTab).azlCol.offset((i + 1 as libc::c_int) as isize),
                        );
                        i -= 1
                    }
                }
            }
            if *pRc != 0 as libc::c_int {
                recoverFreeTable(pTab);
                pTab = 0 as *mut RecoverTable
            } else {
                fprintf((*pState).out,
                        b"CREATE TABLE %s(rootpgno INTEGER, pgno INTEGER, nfield INTEGER, id INTEGER\x00"
                            as *const u8 as *const libc::c_char,
                        (*pTab).zQuoted);
                i = 0 as libc::c_int;
                while i < nCol {
                    fprintf(
                        (*pState).out,
                        b", c%d\x00" as *const u8 as *const libc::c_char,
                        i,
                    );
                    i += 1
                }
                fprintf(
                    (*pState).out,
                    b");\n\x00" as *const u8 as *const libc::c_char,
                );
            }
        }
        sqlite3_free(zTab as *mut libc::c_void);
    }
    return pTab;
}
/*
** This function is called to recover data from the database. A script
** to construct a new database containing all recovered data is output
** on stream pState->out.
*/
unsafe extern "C" fn recoverDatabaseCmd(
    mut pState: *mut ShellState,
    mut nArg: libc::c_int,
    mut azArg: *mut *mut libc::c_char,
) -> libc::c_int {
    let mut rc: libc::c_int = 0 as libc::c_int; /* Loop through all root pages */
    let mut pLoop: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* Loop through all pages in a group */
    let mut pPages: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* Loop through all cells in a page */
    let mut pCells: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* Name of "recovery" database */
    let mut zRecoveryDb: *const libc::c_char = b"\x00" as *const u8 as *const libc::c_char; /* 0 if --freelist-corrupt is specified */
    let mut zLostAndFound: *const libc::c_char =
        b"lost_and_found\x00" as *const u8 as *const libc::c_char; /* 0 if --no-rowids */
    let mut i: libc::c_int = 0;
    let mut nOrphan: libc::c_int = -(1 as libc::c_int);
    let mut pOrphan: *mut RecoverTable = 0 as *mut RecoverTable;
    let mut bFreelist: libc::c_int = 1 as libc::c_int;
    let mut bRowids: libc::c_int = 1 as libc::c_int;
    i = 1 as libc::c_int;
    while i < nArg {
        let mut z: *mut libc::c_char = *azArg.offset(i as isize);
        let mut n: libc::c_int = 0;
        if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
            && *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
        {
            z = z.offset(1)
        }
        n = strlen30(z);
        if n <= 17 as libc::c_int
            && memcmp(
                b"-freelist-corrupt\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bFreelist = 0 as libc::c_int
        } else if n <= 12 as libc::c_int
            && memcmp(
                b"-recovery-db\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            && i < nArg - 1 as libc::c_int
        {
            i += 1;
            zRecoveryDb = *azArg.offset(i as isize)
        } else if n <= 15 as libc::c_int
            && memcmp(
                b"-lost-and-found\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            && i < nArg - 1 as libc::c_int
        {
            i += 1;
            zLostAndFound = *azArg.offset(i as isize)
        } else if n <= 10 as libc::c_int
            && memcmp(
                b"-no-rowids\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                z as *const libc::c_void,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            bRowids = 0 as libc::c_int
        } else {
            fprintf(
                stderr,
                b"unexpected option: %s\n\x00" as *const u8 as *const libc::c_char,
                *azArg.offset(i as isize),
            );
            showHelp((*pState).out, *azArg.offset(0 as libc::c_int as isize));
            return 1 as libc::c_int;
        }
        i += 1
    }
    shellExecPrintf((*pState).db, &mut rc as *mut libc::c_int,
                    b"PRAGMA writable_schema = on;ATTACH %Q AS recovery;DROP TABLE IF EXISTS recovery.dbptr;DROP TABLE IF EXISTS recovery.freelist;DROP TABLE IF EXISTS recovery.map;DROP TABLE IF EXISTS recovery.schema;CREATE TABLE recovery.freelist(pgno INTEGER PRIMARY KEY);\x00"
                        as *const u8 as *const libc::c_char, zRecoveryDb);
    if bFreelist != 0 {
        shellExec((*pState).db, &mut rc,
                  b"WITH trunk(pgno) AS (  SELECT shell_int32(      (SELECT data FROM sqlite_dbpage WHERE pgno=1), 8) AS x       WHERE x>0    UNION  SELECT shell_int32(      (SELECT data FROM sqlite_dbpage WHERE pgno=trunk.pgno), 0) AS x       FROM trunk WHERE x>0),freelist(data, n, freepgno) AS (  SELECT data, min(16384, shell_int32(data, 1)-1), t.pgno       FROM trunk t, sqlite_dbpage s WHERE s.pgno=t.pgno    UNION ALL  SELECT data, n-1, shell_int32(data, 2+n)       FROM freelist WHERE n>=0)REPLACE INTO recovery.freelist SELECT freepgno FROM freelist;\x00"
                      as *const u8 as *const libc::c_char);
    }
    /* If this is an auto-vacuum database, add all pointer-map pages to
     ** the freelist table. Do this regardless of whether or not
     ** --freelist-corrupt was specified.  */
    shellExec((*pState).db, &mut rc,
              b"WITH ptrmap(pgno) AS (  SELECT 2 WHERE shell_int32(    (SELECT data FROM sqlite_dbpage WHERE pgno=1), 13  )    UNION ALL   SELECT pgno+1+(SELECT page_size FROM pragma_page_size)/5 AS pp   FROM ptrmap WHERE pp<=(SELECT page_count FROM pragma_page_count))REPLACE INTO recovery.freelist SELECT pgno FROM ptrmap\x00"
                  as *const u8 as *const libc::c_char);
    shellExec((*pState).db, &mut rc,
              b"CREATE TABLE recovery.dbptr(      pgno, child, PRIMARY KEY(child, pgno)) WITHOUT ROWID;INSERT OR IGNORE INTO recovery.dbptr(pgno, child)     SELECT * FROM sqlite_dbptr      WHERE pgno NOT IN freelist AND child NOT IN freelist;DELETE FROM recovery.dbptr WHERE child = 1;DELETE FROM recovery.dbptr WHERE child IN (  SELECT child FROM recovery.dbptr GROUP BY child HAVING count(*)>1);CREATE TABLE recovery.map(pgno INTEGER PRIMARY KEY, maxlen INT, intkey, root INT);WITH pages(i, maxlen) AS (  SELECT page_count, (    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=page_count  ) FROM pragma_page_count WHERE page_count>0    UNION ALL  SELECT i-1, (    SELECT max(field+1) FROM sqlite_dbdata WHERE pgno=i-1  ) FROM pages WHERE i>=2)INSERT INTO recovery.map(pgno, maxlen, intkey, root)   SELECT i, maxlen, NULL, (    WITH p(orig, pgno, parent) AS (      SELECT 0, i, (SELECT pgno FROM recovery.dbptr WHERE child=i)        UNION       SELECT i, p.parent,         (SELECT pgno FROM recovery.dbptr WHERE child=p.parent) FROM p    )    SELECT pgno FROM p WHERE (parent IS NULL OR pgno = orig)) FROM pages WHERE maxlen IS NOT NULL AND i NOT IN freelist;UPDATE recovery.map AS o SET intkey = (  SELECT substr(data, 1, 1)==X\'0D\' FROM sqlite_dbpage WHERE pgno=o.pgno);CREATE TABLE recovery.schema(type, name, tbl_name, rootpage, sql);INSERT INTO recovery.schema SELECT   max(CASE WHEN field=0 THEN value ELSE NULL END),  max(CASE WHEN field=1 THEN value ELSE NULL END),  max(CASE WHEN field=2 THEN value ELSE NULL END),  max(CASE WHEN field=3 THEN value ELSE NULL END),  max(CASE WHEN field=4 THEN value ELSE NULL END)FROM sqlite_dbdata WHERE pgno IN (  SELECT pgno FROM recovery.map WHERE root=1)GROUP BY pgno, cell;CREATE INDEX recovery.schema_rootpage ON schema(rootpage);\x00"
                  as *const u8 as *const libc::c_char);
    /* Open a transaction, then print out all non-virtual, non-"sqlite_%"
     ** CREATE TABLE statements that extracted from the existing schema.  */
    if rc == 0 as libc::c_int {
        let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        /* ".recover" might output content in an order which causes immediate
         ** foreign key constraints to be violated. So disable foreign-key
         ** constraint enforcement to prevent problems when running the output
         ** script. */
        fprintf(
            (*pState).out,
            b"PRAGMA foreign_keys=OFF;\n\x00" as *const u8 as *const libc::c_char,
        );
        fprintf(
            (*pState).out,
            b"BEGIN;\n\x00" as *const u8 as *const libc::c_char,
        );
        fprintf(
            (*pState).out,
            b"PRAGMA writable_schema = on;\n\x00" as *const u8 as *const libc::c_char,
        );
        shellPrepare((*pState).db, &mut rc,
                     b"SELECT sql FROM recovery.schema WHERE type=\'table\' AND sql LIKE \'create table%\'\x00"
                         as *const u8 as *const libc::c_char, &mut pStmt);
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt) {
            let mut zCreateTable: *const libc::c_char =
                sqlite3_column_text(pStmt, 0 as libc::c_int) as *const libc::c_char;
            fprintf(
                (*pState).out,
                b"CREATE TABLE IF NOT EXISTS %s;\n\x00" as *const u8 as *const libc::c_char,
                &*zCreateTable.offset(12 as libc::c_int as isize) as *const libc::c_char,
            );
        }
        shellFinalize(&mut rc, pStmt);
    }
    /* Figure out if an orphan table will be required. And if so, how many
     ** user columns it should contain */
    shellPrepare(
        (*pState).db,
        &mut rc,
        b"SELECT coalesce(max(maxlen), -2) FROM recovery.map WHERE root>1\x00" as *const u8
            as *const libc::c_char,
        &mut pLoop,
    );
    if rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pLoop) {
        nOrphan = sqlite3_column_int(pLoop, 0 as libc::c_int)
    }
    shellFinalize(&mut rc, pLoop);
    pLoop = 0 as *mut sqlite3_stmt;
    shellPrepare(
        (*pState).db,
        &mut rc,
        b"SELECT pgno FROM recovery.map WHERE root=?\x00" as *const u8 as *const libc::c_char,
        &mut pPages,
    );
    shellPrepare((*pState).db, &mut rc,
                 b"SELECT max(field), group_concat(shell_escape_crnl(quote(case when (? AND field<0) then NULL else value end)), \', \'), min(field) FROM sqlite_dbdata WHERE pgno = ? AND field != ?GROUP BY cell\x00"
                     as *const u8 as *const libc::c_char, &mut pCells);
    /* Loop through each root page. */
    shellPrepare((*pState).db, &mut rc,
                 b"SELECT root, intkey, max(maxlen) FROM recovery.map WHERE root>1 GROUP BY root, intkey ORDER BY root=(  SELECT rootpage FROM recovery.schema WHERE name=\'sqlite_sequence\')\x00"
                     as *const u8 as *const libc::c_char, &mut pLoop);
    while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pLoop) {
        let mut iRoot: libc::c_int = sqlite3_column_int(pLoop, 0 as libc::c_int);
        let mut bIntkey: libc::c_int = sqlite3_column_int(pLoop, 1 as libc::c_int);
        let mut nCol: libc::c_int = sqlite3_column_int(pLoop, 2 as libc::c_int);
        let mut bNoop: libc::c_int = 0 as libc::c_int;
        let mut pTab: *mut RecoverTable = 0 as *mut RecoverTable;
        pTab = recoverFindTable(pState, &mut rc, iRoot, bIntkey, nCol, &mut bNoop);
        if bNoop != 0 || rc != 0 {
            continue;
        }
        if pTab.is_null() {
            if pOrphan.is_null() {
                pOrphan = recoverOrphanTable(pState, &mut rc, zLostAndFound, nOrphan)
            }
            pTab = pOrphan;
            if pTab.is_null() {
                break;
            }
        }
        if 0 as libc::c_int
            == sqlite3_stricmp(
                (*pTab).zQuoted,
                b"\"sqlite_sequence\"\x00" as *const u8 as *const libc::c_char,
            )
        {
            fprintf(
                (*pState).out,
                b"DELETE FROM sqlite_sequence;\n\x00" as *const u8 as *const libc::c_char,
            );
        }
        sqlite3_bind_int(pPages, 1 as libc::c_int, iRoot);
        if bRowids == 0 as libc::c_int && (*pTab).iPk < 0 as libc::c_int {
            sqlite3_bind_int(pCells, 1 as libc::c_int, 1 as libc::c_int);
        } else {
            sqlite3_bind_int(pCells, 1 as libc::c_int, 0 as libc::c_int);
        }
        sqlite3_bind_int(pCells, 3 as libc::c_int, (*pTab).iPk);
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pPages) {
            let mut iPgno: libc::c_int = sqlite3_column_int(pPages, 0 as libc::c_int);
            sqlite3_bind_int(pCells, 2 as libc::c_int, iPgno);
            while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pCells) {
                let mut nField: libc::c_int = sqlite3_column_int(pCells, 0 as libc::c_int);
                let mut iMin: libc::c_int = sqlite3_column_int(pCells, 2 as libc::c_int);
                let mut zVal: *const libc::c_char =
                    sqlite3_column_text(pCells, 1 as libc::c_int) as *const libc::c_char;
                let mut pTab2: *mut RecoverTable = pTab;
                if pTab != pOrphan && (iMin < 0 as libc::c_int) as libc::c_int != bIntkey {
                    if pOrphan.is_null() {
                        pOrphan = recoverOrphanTable(pState, &mut rc, zLostAndFound, nOrphan)
                    }
                    pTab2 = pOrphan;
                    if pTab2.is_null() {
                        break;
                    }
                }
                nField = nField + 1 as libc::c_int;
                if pTab2 == pOrphan {
                    fprintf(
                        (*pState).out,
                        b"INSERT INTO %s VALUES(%d, %d, %d, %s%s%s);\n\x00" as *const u8
                            as *const libc::c_char,
                        (*pTab2).zQuoted,
                        iRoot,
                        iPgno,
                        nField,
                        if iMin < 0 as libc::c_int {
                            b"\x00" as *const u8 as *const libc::c_char
                        } else {
                            b"NULL, \x00" as *const u8 as *const libc::c_char
                        },
                        zVal,
                        *(*pTab2).azlCol.offset(nField as isize),
                    );
                } else {
                    fprintf(
                        (*pState).out,
                        b"INSERT INTO %s(%s) VALUES( %s );\n\x00" as *const u8
                            as *const libc::c_char,
                        (*pTab2).zQuoted,
                        *(*pTab2).azlCol.offset(nField as isize),
                        zVal,
                    );
                }
            }
            shellReset(&mut rc, pCells);
        }
        shellReset(&mut rc, pPages);
        if !(pTab != pOrphan) {
            continue;
        }
        recoverFreeTable(pTab);
    }
    shellFinalize(&mut rc, pLoop);
    shellFinalize(&mut rc, pPages);
    shellFinalize(&mut rc, pCells);
    recoverFreeTable(pOrphan);
    /* The rest of the schema */
    if rc == 0 as libc::c_int {
        let mut pStmt_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
        shellPrepare(
            (*pState).db,
            &mut rc,
            b"SELECT sql, name FROM recovery.schema WHERE sql NOT LIKE \'create table%\'\x00"
                as *const u8 as *const libc::c_char,
            &mut pStmt_0,
        );
        while rc == 0 as libc::c_int && 100 as libc::c_int == sqlite3_step(pStmt_0) {
            let mut zSql: *const libc::c_char =
                sqlite3_column_text(pStmt_0, 0 as libc::c_int) as *const libc::c_char;
            if sqlite3_strnicmp(
                zSql,
                b"create virt\x00" as *const u8 as *const libc::c_char,
                11 as libc::c_int,
            ) == 0 as libc::c_int
            {
                let mut zName: *const libc::c_char =
                    sqlite3_column_text(pStmt_0, 1 as libc::c_int) as *const libc::c_char;
                let mut zPrint: *mut libc::c_char = shellMPrintf(
                    &mut rc as *mut libc::c_int,
                    b"INSERT INTO sqlite_schema VALUES(\'table\', %Q, %Q, 0, %Q)\x00" as *const u8
                        as *const libc::c_char,
                    zName,
                    zName,
                    zSql,
                );
                fprintf(
                    (*pState).out,
                    b"%s;\n\x00" as *const u8 as *const libc::c_char,
                    zPrint,
                );
                sqlite3_free(zPrint as *mut libc::c_void);
            } else {
                fprintf(
                    (*pState).out,
                    b"%s;\n\x00" as *const u8 as *const libc::c_char,
                    zSql,
                );
            }
        }
        shellFinalize(&mut rc, pStmt_0);
    }
    if rc == 0 as libc::c_int {
        fprintf(
            (*pState).out,
            b"PRAGMA writable_schema = off;\n\x00" as *const u8 as *const libc::c_char,
        );
        fprintf(
            (*pState).out,
            b"COMMIT;\n\x00" as *const u8 as *const libc::c_char,
        );
    }
    sqlite3_exec(
        (*pState).db,
        b"DETACH recovery\x00" as *const u8 as *const libc::c_char,
        None,
        0 as *mut libc::c_void,
        0 as *mut *mut libc::c_char,
    );
    return rc;
}
/* !(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB) */
/*
** If an input line begins with "." then invoke this routine to
** process that line.
**
** Return 1 on error, 2 to exit, and 0 otherwise.
*/
unsafe extern "C" fn do_meta_command(
    mut zLine: *mut libc::c_char,
    mut p: *mut ShellState,
) -> libc::c_int {
    let mut current_block: u64;
    let mut h: libc::c_int = 1 as libc::c_int;
    let mut nArg: libc::c_int = 0 as libc::c_int;
    let mut n: libc::c_int = 0;
    let mut c: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut azArg: [*mut libc::c_char; 52] = [0 as *mut libc::c_char; 52];
    if !(*p).expert.pExpert.is_null() {
        expertFinish(p, 1 as libc::c_int, 0 as *mut *mut libc::c_char);
    }
    /* Parse the input line into tokens.
     */
    while *zLine.offset(h as isize) as libc::c_int != 0
        && nArg
            < (::std::mem::size_of::<[*mut libc::c_char; 52]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                as libc::c_int
                - 1 as libc::c_int
    {
        while *(*__ctype_b_loc())
            .offset(*zLine.offset(h as isize) as libc::c_uchar as libc::c_int as isize)
            as libc::c_int
            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
            != 0
        {
            h += 1
        }
        if *zLine.offset(h as isize) as libc::c_int == 0 as libc::c_int {
            break;
        }
        if *zLine.offset(h as isize) as libc::c_int == '\'' as i32
            || *zLine.offset(h as isize) as libc::c_int == '\"' as i32
        {
            let fresh84 = h;
            h = h + 1;
            let mut delim: libc::c_int = *zLine.offset(fresh84 as isize) as libc::c_int;
            let fresh85 = nArg;
            nArg = nArg + 1;
            azArg[fresh85 as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *zLine.offset(h as isize) as libc::c_int != delim
            {
                if *zLine.offset(h as isize) as libc::c_int == '\\' as i32
                    && delim == '\"' as i32
                    && *zLine.offset((h + 1 as libc::c_int) as isize) as libc::c_int
                        != 0 as libc::c_int
                {
                    h += 1
                }
                h += 1
            }
            if *zLine.offset(h as isize) as libc::c_int == delim {
                let fresh86 = h;
                h = h + 1;
                *zLine.offset(fresh86 as isize) = 0 as libc::c_int as libc::c_char
            }
            if !(delim == '\"' as i32) {
                continue;
            }
            resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
        } else {
            let fresh87 = nArg;
            nArg = nArg + 1;
            azArg[fresh87 as usize] = &mut *zLine.offset(h as isize) as *mut libc::c_char;
            while *zLine.offset(h as isize) as libc::c_int != 0
                && *(*__ctype_b_loc())
                    .offset(*zLine.offset(h as isize) as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    == 0
            {
                h += 1
            }
            if *zLine.offset(h as isize) != 0 {
                let fresh88 = h;
                h = h + 1;
                *zLine.offset(fresh88 as isize) = 0 as libc::c_int as libc::c_char
            }
            resolve_backslashes(azArg[(nArg - 1 as libc::c_int) as usize]);
        }
    }
    azArg[nArg as usize] = 0 as *mut libc::c_char;
    /* Process the input line.
     */
    if nArg == 0 as libc::c_int {
        return 0 as libc::c_int;
    } else {
        n = strlen30(azArg[0 as libc::c_int as usize]); /* no tokens, no error */
        c = *azArg[0 as libc::c_int as usize].offset(0 as libc::c_int as isize) as libc::c_int;
        clearTempFile(p);
        if c == 'a' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"auth\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg != 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .auth ON|OFF\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                open_db(p, 0 as libc::c_int);
                if booleanValue(azArg[1 as libc::c_int as usize]) != 0 {
                    sqlite3_set_authorizer(
                        (*p).db,
                        Some(
                            shellAuth
                                as unsafe extern "C" fn(
                                    _: *mut libc::c_void,
                                    _: libc::c_int,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                } else if (*p).bSafeModePersist != 0 {
                    sqlite3_set_authorizer(
                        (*p).db,
                        Some(
                            safeModeAuth
                                as unsafe extern "C" fn(
                                    _: *mut libc::c_void,
                                    _: libc::c_int,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                    _: *const libc::c_char,
                                )
                                    -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                } else {
                    sqlite3_set_authorizer((*p).db, None, 0 as *mut libc::c_void);
                }
            }
        } else if c == 'a' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"archive\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            failIfSafeMode(
                p,
                b"cannot run .archive in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            rc = arDotCommand(p, 0 as libc::c_int, azArg.as_mut_ptr(), nArg)
        } else if c == 'b' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"backup\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            || c == 's' as i32
                && n >= 3 as libc::c_int
                && strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"save\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                ) == 0 as libc::c_int
        {
            let mut zDestFile: *const libc::c_char = 0 as *const libc::c_char;
            let mut zDb: *const libc::c_char = 0 as *const libc::c_char;
            let mut pDest: *mut sqlite3 = 0 as *mut sqlite3;
            let mut pBackup: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
            let mut j: libc::c_int = 0;
            let mut bAsync: libc::c_int = 0 as libc::c_int;
            let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
            failIfSafeMode(
                p,
                b"cannot run .%s in safe mode\x00" as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            j = 1 as libc::c_int;
            while j < nArg {
                let mut z: *const libc::c_char = azArg[j as usize];
                if *z.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                        z = z.offset(1)
                    }
                    if strcmp(z, b"-append\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        zVfs = b"apndvfs\x00" as *const u8 as *const libc::c_char
                    } else if strcmp(z, b"-async\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        bAsync = 1 as libc::c_int
                    } else {
                        fprintf(
                            stderr,
                            b"unknown option: %s\n\x00" as *const u8 as *const libc::c_char,
                            azArg[j as usize],
                        );
                        return 1 as libc::c_int;
                    }
                } else if zDestFile.is_null() {
                    zDestFile = azArg[j as usize]
                } else if zDb.is_null() {
                    zDb = zDestFile;
                    zDestFile = azArg[j as usize]
                } else {
                    fprintf(
                        stderr,
                        b"Usage: .backup ?DB? ?OPTIONS? FILENAME\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    return 1 as libc::c_int;
                }
                j += 1
            }
            if zDestFile.is_null() {
                fprintf(
                    stderr,
                    b"missing FILENAME argument on .backup\n\x00" as *const u8
                        as *const libc::c_char,
                );
                return 1 as libc::c_int;
            } else {
                if zDb.is_null() {
                    zDb = b"main\x00" as *const u8 as *const libc::c_char
                }
                rc = sqlite3_open_v2(
                    zDestFile,
                    &mut pDest,
                    0x2 as libc::c_int | 0x4 as libc::c_int,
                    zVfs,
                );
                if rc != 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: cannot open \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                        zDestFile,
                    );
                    close_db(pDest);
                    return 1 as libc::c_int;
                } else {
                    if bAsync != 0 {
                        sqlite3_exec(
                            pDest,
                            b"PRAGMA synchronous=OFF; PRAGMA journal_mode=OFF;\x00" as *const u8
                                as *const libc::c_char,
                            None,
                            0 as *mut libc::c_void,
                            0 as *mut *mut libc::c_char,
                        );
                    }
                    open_db(p, 0 as libc::c_int);
                    pBackup = sqlite3_backup_init(
                        pDest,
                        b"main\x00" as *const u8 as *const libc::c_char,
                        (*p).db,
                        zDb,
                    );
                    if pBackup.is_null() {
                        fprintf(
                            stderr,
                            b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                            sqlite3_errmsg(pDest),
                        );
                        close_db(pDest);
                        return 1 as libc::c_int;
                    } else {
                        loop {
                            rc = sqlite3_backup_step(pBackup, 100 as libc::c_int);
                            if !(rc == 0 as libc::c_int) {
                                break;
                            }
                        }
                        sqlite3_backup_finish(pBackup);
                        if rc == 101 as libc::c_int {
                            rc = 0 as libc::c_int
                        } else {
                            fprintf(
                                stderr,
                                b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                sqlite3_errmsg(pDest),
                            );
                            rc = 1 as libc::c_int
                        }
                        close_db(pDest);
                    }
                }
            }
        } else if c == 'b' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"bail\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                bail_on_error = booleanValue(azArg[1 as libc::c_int as usize])
            } else {
                fprintf(
                    stderr,
                    b"Usage: .bail on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'b' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"binary\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                let _ = (booleanValue(azArg[1 as libc::c_int as usize])) != 0;
            } else {
                fprintf(
                    stderr,
                    b"Usage: .binary on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'b' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"breakpoint\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            test_breakpoint();
        } else if c == 'c' as i32
            && strcmp(
                azArg[0 as libc::c_int as usize],
                b"cd\x00" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            failIfSafeMode(
                p,
                b"cannot run .cd in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg == 2 as libc::c_int {
                rc = chdir(azArg[1 as libc::c_int as usize]);
                if rc != 0 {
                    fprintf(
                        stderr,
                        b"Cannot change to directory \"%s\"\n\x00" as *const u8
                            as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = 1 as libc::c_int
                }
            } else {
                fprintf(
                    stderr,
                    b"Usage: .cd DIRECTORY\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'c' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"changes\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                setOrClearFlag(
                    p,
                    0x20 as libc::c_int as libc::c_uint,
                    azArg[1 as libc::c_int as usize],
                );
            } else {
                fprintf(
                    stderr,
                    b"Usage: .changes on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'c' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"check\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zRes: *mut libc::c_char = 0 as *mut libc::c_char;
            output_reset(p);
            if nArg != 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .check GLOB-PATTERN\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 2 as libc::c_int
            } else {
                zRes = readFile(
                    b"testcase-out.txt\x00" as *const u8 as *const libc::c_char,
                    0 as *mut libc::c_int,
                );
                if zRes.is_null() {
                    fprintf(
                        stderr,
                        b"Error: cannot read \'testcase-out.txt\'\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 2 as libc::c_int
                } else if testcase_glob(azArg[1 as libc::c_int as usize], zRes) == 0 as libc::c_int
                {
                    fprintf(
                        stderr,
                        b"testcase-%s FAILED\n Expected: [%s]\n      Got: [%s]\n\x00" as *const u8
                            as *const libc::c_char,
                        (*p).zTestcase.as_mut_ptr(),
                        azArg[1 as libc::c_int as usize],
                        zRes,
                    );
                    rc = 1 as libc::c_int
                } else {
                    fprintf(
                        stdout,
                        b"testcase-%s ok\n\x00" as *const u8 as *const libc::c_char,
                        (*p).zTestcase.as_mut_ptr(),
                    );
                    (*p).nCheck += 1
                }
            }
            sqlite3_free(zRes as *mut libc::c_void);
        } else if c == 'c' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"clone\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            failIfSafeMode(
                p,
                b"cannot run .clone in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg == 2 as libc::c_int {
                tryToClone(p, azArg[1 as libc::c_int as usize]);
            } else {
                fprintf(
                    stderr,
                    b"Usage: .clone FILENAME\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'c' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"connection\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 1 as libc::c_int {
                /* The undocumented ".breakpoint" command causes a call to the no-op
                 ** routine named test_breakpoint().
                 */
                /* Cancel output redirection, if it is currently set (by .testcase)
                 ** Then read the content of the testcase-out.txt file and compare against
                 ** azArg[1].  If there are differences, report an error and exit.
                 */
                /* List available connections */
                let mut i: libc::c_int = 0;
                i = 0 as libc::c_int;
                while i
                    < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                        as libc::c_int
                {
                    let mut zFile: *const libc::c_char = (*p).aAuxDb[i as usize].zDbFilename;
                    if (*p).aAuxDb[i as usize].db.is_null()
                        && (*p).pAuxDb
                            != &mut *(*p).aAuxDb.as_mut_ptr().offset(i as isize) as *mut AuxDb
                    {
                        zFile = b"(not open)\x00" as *const u8 as *const libc::c_char
                    } else if zFile.is_null() {
                        zFile = b"(memory)\x00" as *const u8 as *const libc::c_char
                    } else if *zFile.offset(0 as libc::c_int as isize) as libc::c_int
                        == 0 as libc::c_int
                    {
                        zFile = b"(temporary-file)\x00" as *const u8 as *const libc::c_char
                    }
                    if (*p).pAuxDb
                        == &mut *(*p).aAuxDb.as_mut_ptr().offset(i as isize) as *mut AuxDb
                    {
                        fprintf(
                            stdout,
                            b"ACTIVE %d: %s\n\x00" as *const u8 as *const libc::c_char,
                            i,
                            zFile,
                        );
                    } else if !(*p).aAuxDb[i as usize].db.is_null() {
                        fprintf(
                            stdout,
                            b"       %d: %s\n\x00" as *const u8 as *const libc::c_char,
                            i,
                            zFile,
                        );
                    }
                    i += 1
                }
            } else if nArg == 2 as libc::c_int
                && *(*__ctype_b_loc()).offset(
                    *azArg[1 as libc::c_int as usize].offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                && *azArg[1 as libc::c_int as usize].offset(1 as libc::c_int as isize)
                    as libc::c_int
                    == 0 as libc::c_int
            {
                let mut i_0: libc::c_int = *azArg[1 as libc::c_int as usize]
                    .offset(0 as libc::c_int as isize)
                    as libc::c_int
                    - '0' as i32;
                if (*p).pAuxDb != &mut *(*p).aAuxDb.as_mut_ptr().offset(i_0 as isize) as *mut AuxDb
                    && i_0 >= 0 as libc::c_int
                    && i_0
                        < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                            .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                            as libc::c_int
                {
                    (*(*p).pAuxDb).db = (*p).db;
                    (*p).pAuxDb = &mut *(*p).aAuxDb.as_mut_ptr().offset(i_0 as isize) as *mut AuxDb;
                    (*p).db = (*(*p).pAuxDb).db;
                    globalDb = (*p).db;
                    (*(*p).pAuxDb).db = 0 as *mut sqlite3
                }
            } else if nArg == 3 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"close\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                && *(*__ctype_b_loc()).offset(
                    *azArg[2 as libc::c_int as usize].offset(0 as libc::c_int as isize)
                        as libc::c_uchar as libc::c_int as isize,
                ) as libc::c_int
                    & _ISdigit as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                && *azArg[2 as libc::c_int as usize].offset(1 as libc::c_int as isize)
                    as libc::c_int
                    == 0 as libc::c_int
            {
                let mut i_1: libc::c_int = *azArg[2 as libc::c_int as usize]
                    .offset(0 as libc::c_int as isize)
                    as libc::c_int
                    - '0' as i32;
                if !(i_1 < 0 as libc::c_int
                    || i_1
                        >= (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                            .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                            as libc::c_int)
                {
                    if (*p).pAuxDb
                        == &mut *(*p).aAuxDb.as_mut_ptr().offset(i_1 as isize) as *mut AuxDb
                    {
                        fprintf(
                            stderr,
                            b"cannot close the active database connection\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                        rc = 1 as libc::c_int
                    } else if !(*p).aAuxDb[i_1 as usize].db.is_null() {
                        close_db((*p).aAuxDb[i_1 as usize].db);
                        (*p).aAuxDb[i_1 as usize].db = 0 as *mut sqlite3
                    }
                }
            } else {
                fprintf(
                    stderr,
                    b"Usage: .connection [close] [CONNECTION-NUMBER]\n\x00" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'd' as i32
            && n > 1 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"databases\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut azName: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
            let mut nName: libc::c_int = 0 as libc::c_int;
            let mut pStmt: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut i_2: libc::c_int = 0;
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_prepare_v2(
                (*p).db,
                b"PRAGMA database_list\x00" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
                &mut pStmt,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                fprintf(
                    stderr,
                    b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                    sqlite3_errmsg((*p).db),
                );
                rc = 1 as libc::c_int
            } else {
                while sqlite3_step(pStmt) == 100 as libc::c_int {
                    let mut zSchema: *const libc::c_char =
                        sqlite3_column_text(pStmt, 1 as libc::c_int) as *const libc::c_char;
                    let mut zFile_0: *const libc::c_char =
                        sqlite3_column_text(pStmt, 2 as libc::c_int) as *const libc::c_char;
                    azName = sqlite3_realloc(
                        azName as *mut libc::c_void,
                        (((nName + 1 as libc::c_int) * 2 as libc::c_int) as libc::c_ulong)
                            .wrapping_mul(
                                ::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong
                            ) as libc::c_int,
                    ) as *mut *mut libc::c_char;
                    if azName.is_null() {
                        shell_out_of_memory();
                        /* Does not return */
                    }
                    let ref mut fresh89 = *azName.offset((nName * 2 as libc::c_int) as isize);
                    *fresh89 = strdup(zSchema);
                    let ref mut fresh90 =
                        *azName.offset((nName * 2 as libc::c_int + 1 as libc::c_int) as isize);
                    *fresh90 = strdup(zFile_0);
                    nName += 1
                }
            }
            sqlite3_finalize(pStmt);
            i_2 = 0 as libc::c_int;
            while i_2 < nName {
                let mut eTxn: libc::c_int =
                    sqlite3_txn_state((*p).db, *azName.offset((i_2 * 2 as libc::c_int) as isize));
                let mut bRdonly: libc::c_int =
                    sqlite3_db_readonly((*p).db, *azName.offset((i_2 * 2 as libc::c_int) as isize));
                let mut z_0: *const libc::c_char =
                    *azName.offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize);
                fprintf(
                    (*p).out,
                    b"%s: %s %s%s\n\x00" as *const u8 as *const libc::c_char,
                    *azName.offset((i_2 * 2 as libc::c_int) as isize),
                    if !z_0.is_null() && *z_0.offset(0 as libc::c_int as isize) as libc::c_int != 0
                    {
                        z_0
                    } else {
                        b"\"\"\x00" as *const u8 as *const libc::c_char
                    },
                    if bRdonly != 0 {
                        b"r/o\x00" as *const u8 as *const libc::c_char
                    } else {
                        b"r/w\x00" as *const u8 as *const libc::c_char
                    },
                    if eTxn == 0 as libc::c_int {
                        b"\x00" as *const u8 as *const libc::c_char
                    } else if eTxn == 1 as libc::c_int {
                        b" read-txn\x00" as *const u8 as *const libc::c_char
                    } else {
                        b" write-txn\x00" as *const u8 as *const libc::c_char
                    },
                );
                free(*azName.offset((i_2 * 2 as libc::c_int) as isize) as *mut libc::c_void);
                free(
                    *azName.offset((i_2 * 2 as libc::c_int + 1 as libc::c_int) as isize)
                        as *mut libc::c_void,
                );
                i_2 += 1
            }
            sqlite3_free(azName as *mut libc::c_void);
        } else if c == 'd' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"dbconfig\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            static mut aDbConfig: [DbConfigChoices; 16] = [
                {
                    let mut init = DbConfigChoices {
                        zName: b"defensive\x00" as *const u8 as *const libc::c_char,
                        op: 1010 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"dqs_ddl\x00" as *const u8 as *const libc::c_char,
                        op: 1014 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"dqs_dml\x00" as *const u8 as *const libc::c_char,
                        op: 1013 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"enable_fkey\x00" as *const u8 as *const libc::c_char,
                        op: 1002 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"enable_qpsg\x00" as *const u8 as *const libc::c_char,
                        op: 1007 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"enable_trigger\x00" as *const u8 as *const libc::c_char,
                        op: 1003 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"enable_view\x00" as *const u8 as *const libc::c_char,
                        op: 1015 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"fts3_tokenizer\x00" as *const u8 as *const libc::c_char,
                        op: 1004 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"legacy_alter_table\x00" as *const u8 as *const libc::c_char,
                        op: 1012 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"legacy_file_format\x00" as *const u8 as *const libc::c_char,
                        op: 1016 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"load_extension\x00" as *const u8 as *const libc::c_char,
                        op: 1005 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"no_ckpt_on_close\x00" as *const u8 as *const libc::c_char,
                        op: 1006 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"reset_database\x00" as *const u8 as *const libc::c_char,
                        op: 1009 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"trigger_eqp\x00" as *const u8 as *const libc::c_char,
                        op: 1008 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"trusted_schema\x00" as *const u8 as *const libc::c_char,
                        op: 1017 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = DbConfigChoices {
                        zName: b"writable_schema\x00" as *const u8 as *const libc::c_char,
                        op: 1011 as libc::c_int,
                    };
                    init
                },
            ];
            let mut ii: libc::c_int = 0;
            let mut v: libc::c_int = 0;
            open_db(p, 0 as libc::c_int);
            ii = 0 as libc::c_int;
            while ii
                < (::std::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                    .wrapping_div(::std::mem::size_of::<DbConfigChoices>() as libc::c_ulong)
                    as libc::c_int
            {
                if !(nArg > 1 as libc::c_int
                    && strcmp(
                        azArg[1 as libc::c_int as usize],
                        aDbConfig[ii as usize].zName,
                    ) != 0 as libc::c_int)
                {
                    if nArg >= 3 as libc::c_int {
                        sqlite3_db_config(
                            (*p).db,
                            aDbConfig[ii as usize].op,
                            booleanValue(azArg[2 as libc::c_int as usize]),
                            0 as libc::c_int,
                        );
                    }
                    sqlite3_db_config(
                        (*p).db,
                        aDbConfig[ii as usize].op,
                        -(1 as libc::c_int),
                        &mut v as *mut libc::c_int,
                    );
                    fprintf(
                        (*p).out,
                        b"%19s %s\n\x00" as *const u8 as *const libc::c_char,
                        aDbConfig[ii as usize].zName,
                        if v != 0 {
                            b"on\x00" as *const u8 as *const libc::c_char
                        } else {
                            b"off\x00" as *const u8 as *const libc::c_char
                        },
                    );
                    if nArg > 1 as libc::c_int {
                        break;
                    }
                }
                ii += 1
            }
            if nArg > 1 as libc::c_int
                && ii
                    == (::std::mem::size_of::<[DbConfigChoices; 16]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<DbConfigChoices>() as libc::c_ulong)
                        as libc::c_int
            {
                fprintf(
                    stderr,
                    b"Error: unknown dbconfig \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
                fprintf(
                    stderr,
                    b"Enter \".dbconfig\" with no arguments for a list\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
        } else if c == 'd' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"dbinfo\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            rc = shell_dbinfo_command(p, nArg, azArg.as_mut_ptr())
        } else if c == 'r' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"recover\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            rc = recoverDatabaseCmd(p, nArg, azArg.as_mut_ptr())
        } else if c == 'd' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"dump\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zLike: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut i_3: libc::c_int = 0;
            let mut savedShowHeader: libc::c_int = (*p).showHeader;
            let mut savedShellFlags: libc::c_int = (*p).shellFlgs as libc::c_int;
            (*p).shellFlgs &= !(0x8 as libc::c_int
                | 0x10 as libc::c_int
                | 0x40 as libc::c_int
                | 0x100 as libc::c_int
                | 0x200 as libc::c_int) as libc::c_uint;
            i_3 = 1 as libc::c_int;
            loop {
                if !(i_3 < nArg) {
                    current_block = 18078460720374183796;
                    break;
                }
                if *azArg[i_3 as usize].offset(0 as libc::c_int as isize) as libc::c_int
                    == '-' as i32
                {
                    let mut z_1: *const libc::c_char =
                        azArg[i_3 as usize].offset(1 as libc::c_int as isize);
                    if *z_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                        z_1 = z_1.offset(1)
                    }
                    if strcmp(
                        z_1,
                        b"preserve-rowids\x00" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int
                    {
                        (*p).shellFlgs |= 0x8 as libc::c_int as libc::c_uint
                    } else if strcmp(z_1, b"newlines\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        (*p).shellFlgs |= 0x10 as libc::c_int as libc::c_uint
                    } else if strcmp(z_1, b"data-only\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        (*p).shellFlgs |= 0x100 as libc::c_int as libc::c_uint
                    } else if strcmp(z_1, b"nosys\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        (*p).shellFlgs |= 0x200 as libc::c_int as libc::c_uint
                    } else {
                        fprintf(
                            stderr,
                            b"Unknown option \"%s\" on \".dump\"\n\x00" as *const u8
                                as *const libc::c_char,
                            azArg[i_3 as usize],
                        );
                        rc = 1 as libc::c_int;
                        sqlite3_free(zLike as *mut libc::c_void);
                        current_block = 4767945957387570333;
                        break;
                    }
                } else {
                    /* !(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_ENABLE_DBPAGE_VTAB) */
                    /* azArg[i] contains a LIKE pattern. This ".dump" request should
                     ** only dump data for tables for which either the table name matches
                     ** the LIKE pattern, or the table appears to be a shadow table of
                     ** a virtual table for which the name matches the LIKE pattern.
                     */
                    let mut zExpr: *mut libc::c_char =
                        sqlite3_mprintf(b"name LIKE %Q ESCAPE \'\\\' OR EXISTS (  SELECT 1 FROM sqlite_schema WHERE     name LIKE %Q ESCAPE \'\\\' AND    sql LIKE \'CREATE VIRTUAL TABLE%%\' AND    substr(o.name, 1, length(name)+1) == (name||\'_\'))\x00"
                                            as *const u8 as
                                            *const libc::c_char,
                                        azArg[i_3 as usize],
                                        azArg[i_3 as usize]);
                    if !zLike.is_null() {
                        zLike = sqlite3_mprintf(
                            b"%z OR %z\x00" as *const u8 as *const libc::c_char,
                            zLike,
                            zExpr,
                        )
                    } else {
                        zLike = zExpr
                    }
                }
                i_3 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    open_db(p, 0 as libc::c_int);
                    if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        /* When playing back a "dump", the content might appear in an order
                         ** which causes immediate foreign key constraints to be violated.
                         ** So disable foreign-key constraint enforcement to prevent problems. */
                        fprintf(
                            (*p).out,
                            b"PRAGMA foreign_keys=OFF;\n\x00" as *const u8 as *const libc::c_char,
                        );
                        fprintf(
                            (*p).out,
                            b"BEGIN TRANSACTION;\n\x00" as *const u8 as *const libc::c_char,
                        );
                    }
                    (*p).writableSchema = 0 as libc::c_int;
                    (*p).showHeader = 0 as libc::c_int;
                    /* Set writable_schema=ON since doing so forces SQLite to initialize
                     ** as much of the schema as it can even if the sqlite_schema table is
                     ** corrupt. */
                    sqlite3_exec(
                        (*p).db,
                        b"SAVEPOINT dump; PRAGMA writable_schema=ON\x00" as *const u8
                            as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                    (*p).nErr = 0 as libc::c_int;
                    if zLike.is_null() {
                        zLike = sqlite3_mprintf(b"true\x00" as *const u8 as *const libc::c_char)
                    }
                    zSql =
                        sqlite3_mprintf(b"SELECT name, type, sql FROM sqlite_schema AS o WHERE (%s) AND type==\'table\'  AND sql NOT NULL ORDER BY tbl_name=\'sqlite_sequence\', rowid\x00"
                                            as *const u8 as
                                            *const libc::c_char, zLike);
                    run_schema_dump_query(p, zSql);
                    sqlite3_free(zSql as *mut libc::c_void);
                    if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        zSql =
                            sqlite3_mprintf(b"SELECT sql FROM sqlite_schema AS o WHERE (%s) AND sql NOT NULL  AND type IN (\'index\',\'trigger\',\'view\')\x00"
                                                as *const u8 as
                                                *const libc::c_char, zLike);
                        run_table_dump_query(p, zSql);
                        sqlite3_free(zSql as *mut libc::c_void);
                    }
                    sqlite3_free(zLike as *mut libc::c_void);
                    if (*p).writableSchema != 0 {
                        fprintf(
                            (*p).out,
                            b"PRAGMA writable_schema=OFF;\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                        (*p).writableSchema = 0 as libc::c_int
                    }
                    sqlite3_exec(
                        (*p).db,
                        b"PRAGMA writable_schema=OFF;\x00" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                    sqlite3_exec(
                        (*p).db,
                        b"RELEASE dump;\x00" as *const u8 as *const libc::c_char,
                        None,
                        0 as *mut libc::c_void,
                        0 as *mut *mut libc::c_char,
                    );
                    if (*p).shellFlgs & 0x100 as libc::c_int as libc::c_uint
                        == 0 as libc::c_int as libc::c_uint
                    {
                        fprintf(
                            (*p).out,
                            if (*p).nErr != 0 {
                                b"ROLLBACK; -- due to errors\n\x00" as *const u8
                                    as *const libc::c_char
                            } else {
                                b"COMMIT;\n\x00" as *const u8 as *const libc::c_char
                            },
                        );
                    }
                    (*p).showHeader = savedShowHeader;
                    (*p).shellFlgs = savedShellFlags as libc::c_uint
                }
            }
        } else if c == 'e' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"echo\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                setOrClearFlag(
                    p,
                    0x40 as libc::c_int as libc::c_uint,
                    azArg[1 as libc::c_int as usize],
                );
            } else {
                fprintf(
                    stderr,
                    b"Usage: .echo on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'e' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"eqp\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                (*p).autoEQPtest = 0 as libc::c_int as u8_0;
                if (*p).autoEQPtrace != 0 {
                    if !(*p).db.is_null() {
                        sqlite3_exec(
                            (*p).db,
                            b"PRAGMA vdbe_trace=OFF;\x00" as *const u8 as *const libc::c_char,
                            None,
                            0 as *mut libc::c_void,
                            0 as *mut *mut libc::c_char,
                        );
                    }
                    (*p).autoEQPtrace = 0 as libc::c_int as u8_0
                }
                if strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"full\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).autoEQP = 3 as libc::c_int as u8_0
                } else if strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"trigger\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).autoEQP = 2 as libc::c_int as u8_0
                } else {
                    (*p).autoEQP = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0
                }
            } else {
                fprintf(
                    stderr,
                    b"Usage: .eqp off|on|trace|trigger|full\n\x00" as *const u8
                        as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'e' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"exit\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg > 1 as libc::c_int && {
                rc = integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int;
                (rc) != 0 as libc::c_int
            } {
                exit(rc);
            } else {
                rc = 2 as libc::c_int
            }
        } else if c == 'e' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"explain\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut val: libc::c_int = 1 as libc::c_int;
            if nArg >= 2 as libc::c_int {
                if strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"auto\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    val = 99 as libc::c_int
                } else {
                    val = booleanValue(azArg[1 as libc::c_int as usize])
                }
            }
            if val == 1 as libc::c_int && (*p).mode != 9 as libc::c_int {
                (*p).normalMode = (*p).mode;
                (*p).mode = 9 as libc::c_int;
                (*p).autoExplain = 0 as libc::c_int as u8_0
            } else if val == 0 as libc::c_int {
                if (*p).mode == 9 as libc::c_int {
                    (*p).mode = (*p).normalMode
                }
                (*p).autoExplain = 0 as libc::c_int as u8_0
            } else if val == 99 as libc::c_int {
                if (*p).mode == 9 as libc::c_int {
                    (*p).mode = (*p).normalMode
                }
                (*p).autoExplain = 1 as libc::c_int as u8_0
            }
        } else if c == 'e' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"expert\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            expertDotCommand(p, azArg.as_mut_ptr(), nArg);
        } else if c == 'f' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"filectrl\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            /* The ".explain" command is automatic now.  It is largely pointless.  It
             ** retained purely for backwards compatibility */
            /* Usage notes */
            static mut aCtrl: [C2RustUnnamed_21; 9] = [
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"chunk_size\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 6 as libc::c_int,
                        zUsage: b"SIZE\x00" as *const u8 as *const libc::c_char,
                    }; /* Integer result to display if rc2==1 */
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"data_version\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 35 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    }; /* 0: usage  1: %lld  2: no-result */
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"has_moved\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 20 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"lock_timeout\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 34 as libc::c_int,
                        zUsage: b"MILLISEC\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"persist_wal\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 10 as libc::c_int,
                        zUsage: b"[BOOLEAN]\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"psow\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 13 as libc::c_int,
                        zUsage: b"[BOOLEAN]\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"reserve_bytes\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 38 as libc::c_int,
                        zUsage: b"[N]\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"size_limit\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 36 as libc::c_int,
                        zUsage: b"[LIMIT]\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_21 {
                        zCtrlName: b"tempfilename\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 16 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
            ];
            let mut filectrl: libc::c_int = -(1 as libc::c_int);
            let mut iCtrl: libc::c_int = -(1 as libc::c_int);
            let mut iRes: sqlite3_int64 = 0 as libc::c_int as sqlite3_int64;
            let mut isOk: libc::c_int = 0 as libc::c_int;
            let mut n2: libc::c_int = 0;
            let mut i_4: libc::c_int = 0;
            let mut zCmd: *const libc::c_char = 0 as *const libc::c_char;
            let mut zSchema_0: *const libc::c_char = 0 as *const libc::c_char;
            open_db(p, 0 as libc::c_int);
            zCmd = if nArg >= 2 as libc::c_int {
                azArg[1 as libc::c_int as usize] as *const libc::c_char
            } else {
                b"help\x00" as *const u8 as *const libc::c_char
            };
            if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && (strcmp(zCmd, b"--schema\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    || strcmp(zCmd, b"-schema\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int)
                && nArg >= 4 as libc::c_int
            {
                zSchema_0 = azArg[2 as libc::c_int as usize];
                i_4 = 3 as libc::c_int;
                while i_4 < nArg {
                    azArg[(i_4 - 2 as libc::c_int) as usize] = azArg[i_4 as usize];
                    i_4 += 1
                }
                nArg -= 2 as libc::c_int;
                zCmd = azArg[1 as libc::c_int as usize]
            }
            /* The argument can optionally begin with "-" or "--" */
            if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd = zCmd.offset(1);
                if *zCmd.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    && *zCmd.offset(1 as libc::c_int as isize) as libc::c_int != 0
                {
                    zCmd = zCmd.offset(1)
                }
            }
            /* --help lists all file-controls */
            if strcmp(zCmd, b"help\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"Available file-controls:\n\x00" as *const u8 as *const libc::c_char,
                );
                i_4 = 0 as libc::c_int;
                while i_4
                    < (::std::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong)
                        as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"  .filectrl %s %s\n\x00" as *const u8 as *const libc::c_char,
                        aCtrl[i_4 as usize].zCtrlName,
                        aCtrl[i_4 as usize].zUsage,
                    );
                    i_4 += 1
                }
                rc = 1 as libc::c_int
            } else {
                /* convert filectrl text option to value. allow any unique prefix
                 ** of the option name, or a numerical value. */
                n2 = strlen30(zCmd); /* Insert data into this table */
                i_4 = 0 as libc::c_int; /* Name of file to extra content from */
                loop {
                    if !(i_4 < (::std::mem::size_of::<[C2RustUnnamed_21; 9]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_21>() as libc::c_ulong)
                        as libc::c_int)
                    {
                        current_block = 5965671744794778453; /* A statement */
                        break; /* Number of columns in the table */
                    } /* Number of bytes in an SQL string */
                    if strncmp(zCmd, aCtrl[i_4 as usize].zCtrlName, n2 as libc::c_ulong)
                        == 0 as libc::c_int
                    {
                        if filectrl < 0 as libc::c_int {
                            filectrl = aCtrl[i_4 as usize].ctrlCode; /* Loop counters */
                            iCtrl = i_4
                        } else {
                            fprintf(stderr,
                                    b"Error: ambiguous file-control: \"%s\"\nUse \".filectrl --help\" for help\n\x00"
                                        as *const u8 as *const libc::c_char,
                                    zCmd); /* True to COMMIT or ROLLBACK at end */
                            rc = 1 as libc::c_int; /* Number of bytes in p->colSeparator[] */
                            current_block = 4767945957387570333; /* An SQL statement */
                            break; /* Reader context */
                        }
                    } /* Func to read one value */
                    i_4 += 1
                } /* Larger for more console output */
                match current_block {
                    4767945957387570333 => {}
                    _ => {
                        if filectrl < 0 as libc::c_int {
                            fprintf(stderr,
                                    b"Error: unknown file-control: %s\nUse \".filectrl --help\" for help\n\x00"
                                        as *const u8 as *const libc::c_char,
                                    zCmd); /* Initial lines to skip */
                        } else {
                            match filectrl {
                                36 => {
                                    current_block = 14290811757060112175; /* Use output mode to determine separators */
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                34 | 6 => {
                                    current_block = 5102396516157810314;
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                10 | 13 => {
                                    current_block = 15508192053828812388;
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                35 | 20 => {
                                    current_block = 3519104627463448925;
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                16 => {
                                    current_block = 16067586086876485193;
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                38 => {
                                    current_block = 14190140685265850346;
                                    match current_block {
                                        14190140685265850346 => {
                                            let mut x_2: libc::c_int = 0;
                                            if nArg >= 3 as libc::c_int {
                                                x_2 = atoi(azArg[2 as libc::c_int as usize]);
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_2 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                            }
                                            x_2 = -(1 as libc::c_int);
                                            sqlite3_file_control(
                                                (*p).db,
                                                zSchema_0,
                                                filectrl,
                                                &mut x_2 as *mut libc::c_int as *mut libc::c_void,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                                x_2,
                                            );
                                            isOk = 2 as libc::c_int
                                        }
                                        3519104627463448925 => {
                                            let mut x_1: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_1 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_1 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        15508192053828812388 => {
                                            let mut x_0: libc::c_int = 0;
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                x_0 = if nArg == 3 as libc::c_int {
                                                    booleanValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int)
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x_0 as *mut libc::c_int
                                                        as *mut libc::c_void,
                                                );
                                                iRes = x_0 as sqlite3_int64;
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        5102396516157810314 => {
                                            let mut x: libc::c_int = 0;
                                            if !(nArg != 3 as libc::c_int) {
                                                x = integerValue(azArg[2 as libc::c_int as usize])
                                                    as libc::c_int;
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut x as *mut libc::c_int as *mut libc::c_void,
                                                );
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                        14290811757060112175 => {
                                            if !(nArg != 2 as libc::c_int
                                                && nArg != 3 as libc::c_int)
                                            {
                                                iRes = if nArg == 3 as libc::c_int {
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                } else {
                                                    -(1 as libc::c_int) as libc::c_longlong
                                                };
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    36 as libc::c_int,
                                                    &mut iRes as *mut sqlite3_int64
                                                        as *mut libc::c_void,
                                                );
                                                isOk = 1 as libc::c_int
                                            }
                                        }
                                        _ => {
                                            let mut z_2: *mut libc::c_char = 0 as *mut libc::c_char;
                                            if !(nArg != 2 as libc::c_int) {
                                                sqlite3_file_control(
                                                    (*p).db,
                                                    zSchema_0,
                                                    filectrl,
                                                    &mut z_2 as *mut *mut libc::c_char
                                                        as *mut libc::c_void,
                                                );
                                                if !z_2.is_null() {
                                                    fprintf(
                                                        (*p).out,
                                                        b"%s\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        z_2,
                                                    );
                                                    sqlite3_free(z_2 as *mut libc::c_void);
                                                }
                                                isOk = 2 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if isOk == 0 as libc::c_int && iCtrl >= 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"Usage: .filectrl %s %s\n\x00" as *const u8 as *const libc::c_char,
                                zCmd,
                                aCtrl[iCtrl as usize].zUsage,
                            );
                            rc = 1 as libc::c_int
                        } else if isOk == 1 as libc::c_int {
                            let mut zBuf: [libc::c_char; 100] = [0; 100];
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong
                                    as libc::c_int,
                                zBuf.as_mut_ptr(),
                                b"%lld\x00" as *const u8 as *const libc::c_char,
                                iRes,
                            );
                            fprintf(
                                (*p).out,
                                b"%s\n\x00" as *const u8 as *const libc::c_char,
                                zBuf.as_mut_ptr(),
                            );
                        }
                    }
                }
            }
        } else if c == 'f' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"fullschema\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut data: ShellState = ShellState {
                db: 0 as *mut sqlite3,
                autoExplain: 0,
                autoEQP: 0,
                autoEQPtest: 0,
                autoEQPtrace: 0,
                scanstatsOn: 0,
                openMode: 0,
                doXdgOpen: 0,
                nEqpLevel: 0,
                eTraceType: 0,
                bSafeMode: 0,
                bSafeModePersist: 0,
                statsOn: 0,
                mEqpLines: 0,
                outCount: 0,
                cnt: 0,
                lineno: 0,
                openFlags: 0,
                in_0: 0 as *mut FILE,
                out: 0 as *mut FILE,
                traceOut: 0 as *mut FILE,
                nErr: 0,
                mode: 0,
                modePrior: 0,
                cMode: 0,
                normalMode: 0,
                writableSchema: 0,
                showHeader: 0,
                nCheck: 0,
                nProgress: 0,
                mxProgress: 0,
                flgProgress: 0,
                shellFlgs: 0,
                priorShFlgs: 0,
                szMax: 0,
                zDestTable: 0 as *mut libc::c_char,
                zTempFile: 0 as *mut libc::c_char,
                zTestcase: [0; 30],
                colSeparator: [0; 20],
                rowSeparator: [0; 20],
                colSepPrior: [0; 20],
                rowSepPrior: [0; 20],
                colWidth: 0 as *mut libc::c_int,
                actualWidth: 0 as *mut libc::c_int,
                nWidth: 0,
                nullValue: [0; 20],
                outfile: [0; 4096],
                pStmt: 0 as *mut sqlite3_stmt,
                pLog: 0 as *mut FILE,
                aAuxDb: [AuxDb {
                    db: 0 as *mut sqlite3,
                    zDbFilename: 0 as *const libc::c_char,
                    zFreeOnClose: 0 as *mut libc::c_char,
                }; 5],
                pAuxDb: 0 as *mut AuxDb,
                aiIndent: 0 as *mut libc::c_int,
                nIndent: 0,
                iIndent: 0,
                zNonce: 0 as *mut libc::c_char,
                sGraph: EQPGraph {
                    pRow: 0 as *mut EQPGraphRow,
                    pLast: 0 as *mut EQPGraphRow,
                    zPrefix: [0; 100],
                },
                expert: ExpertInfo {
                    pExpert: 0 as *mut sqlite3expert,
                    bVerbose: 0,
                },
            };
            let mut doStats: libc::c_int = 0 as libc::c_int;
            memcpy(
                &mut data as *mut ShellState as *mut libc::c_void,
                p as *const libc::c_void,
                ::std::mem::size_of::<ShellState>() as libc::c_ulong,
            );
            data.showHeader = 0 as libc::c_int;
            data.mode = 3 as libc::c_int;
            data.cMode = data.mode;
            if nArg == 2 as libc::c_int
                && optionMatch(
                    azArg[1 as libc::c_int as usize],
                    b"indent\x00" as *const u8 as *const libc::c_char,
                ) != 0
            {
                data.mode = 11 as libc::c_int;
                data.cMode = data.mode;
                nArg = 1 as libc::c_int
            }
            if nArg != 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .fullschema ?--indent?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                open_db(p, 0 as libc::c_int);
                rc =
                    sqlite3_exec((*p).db,
                                 b"SELECT sql FROM  (SELECT sql sql, type type, tbl_name tbl_name, name name, rowid x     FROM sqlite_schema UNION ALL   SELECT sql, type, tbl_name, name, rowid FROM sqlite_temp_schema) WHERE type!=\'meta\' AND sql NOTNULL AND name NOT LIKE \'sqlite_%\' ORDER BY x\x00"
                                     as *const u8 as *const libc::c_char,
                                 Some(callback as
                                          unsafe extern "C" fn(_:
                                                                   *mut libc::c_void,
                                                               _: libc::c_int,
                                                               _:
                                                                   *mut *mut libc::c_char,
                                                               _:
                                                                   *mut *mut libc::c_char)
                                              -> libc::c_int),
                                 &mut data as *mut ShellState as
                                     *mut libc::c_void,
                                 0 as *mut *mut libc::c_char);
                if rc == 0 as libc::c_int {
                    let mut pStmt_0: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        b"SELECT rowid FROM sqlite_schema WHERE name GLOB \'sqlite_stat[134]\'\x00"
                            as *const u8 as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pStmt_0,
                        0 as *mut *const libc::c_char,
                    );
                    doStats = (sqlite3_step(pStmt_0) == 100 as libc::c_int) as libc::c_int;
                    sqlite3_finalize(pStmt_0);
                }
                if doStats == 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"/* No STAT tables available */\n\x00" as *const u8 as *const libc::c_char,
                    );
                } else {
                    fprintf(
                        (*p).out,
                        b"ANALYZE sqlite_schema;\n\x00" as *const u8 as *const libc::c_char,
                    );
                    data.mode = 5 as libc::c_int;
                    data.cMode = data.mode;
                    data.zDestTable = b"sqlite_stat1\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    shell_exec(
                        &mut data,
                        b"SELECT * FROM sqlite_stat1\x00" as *const u8 as *const libc::c_char,
                        0 as *mut *mut libc::c_char,
                    );
                    data.zDestTable = b"sqlite_stat4\x00" as *const u8 as *const libc::c_char
                        as *mut libc::c_char;
                    shell_exec(
                        &mut data,
                        b"SELECT * FROM sqlite_stat4\x00" as *const u8 as *const libc::c_char,
                        0 as *mut *mut libc::c_char,
                    );
                    fprintf(
                        (*p).out,
                        b"ANALYZE sqlite_schema;\n\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else if c == 'h' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"headers\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                (*p).showHeader = booleanValue(azArg[1 as libc::c_int as usize]);
                (*p).shellFlgs |= 0x80 as libc::c_int as libc::c_uint
            } else {
                fprintf(
                    stderr,
                    b"Usage: .headers on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'h' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"help\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg >= 2 as libc::c_int {
                n = showHelp((*p).out, azArg[1 as libc::c_int as usize]);
                if n == 0 as libc::c_int {
                    fprintf(
                        (*p).out,
                        b"Nothing matches \'%s\'\n\x00" as *const u8 as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                }
            } else {
                showHelp((*p).out, 0 as *const libc::c_char);
            }
        } else if c == 'i' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"import\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zTable: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zFile_1: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut pStmt_1: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut nCol: libc::c_int = 0;
            let mut nByte: libc::c_int = 0;
            let mut i_5: libc::c_int = 0;
            let mut j_0: libc::c_int = 0;
            let mut needCommit: libc::c_int = 0;
            let mut nSep: libc::c_int = 0;
            let mut zSql_0: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut sCtx: ImportCtx = ImportCtx {
                zFile: 0 as *const libc::c_char,
                in_0: 0 as *mut FILE,
                xCloser: None,
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
                nLine: 0,
                nRow: 0,
                nErr: 0,
                bNotFirst: 0,
                cTerm: 0,
                cColSep: 0,
                cRowSep: 0,
            };
            let mut xRead: Option<unsafe extern "C" fn(_: *mut ImportCtx) -> *mut libc::c_char> =
                None;
            let mut eVerbose: libc::c_int = 0 as libc::c_int;
            let mut nSkip: libc::c_int = 0 as libc::c_int;
            let mut useOutputMode: libc::c_int = 1 as libc::c_int;
            failIfSafeMode(
                p,
                b"cannot run .import in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            memset(
                &mut sCtx as *mut ImportCtx as *mut libc::c_void,
                0 as libc::c_int,
                ::std::mem::size_of::<ImportCtx>() as libc::c_ulong,
            );
            if (*p).mode == 10 as libc::c_int {
                xRead = Some(
                    ascii_read_one_field
                        as unsafe extern "C" fn(_: *mut ImportCtx) -> *mut libc::c_char,
                )
            } else {
                xRead = Some(
                    csv_read_one_field
                        as unsafe extern "C" fn(_: *mut ImportCtx) -> *mut libc::c_char,
                )
            }
            i_5 = 1 as libc::c_int;
            loop {
                if !(i_5 < nArg) {
                    current_block = 17809027598452024276;
                    break;
                }
                let mut z_3: *mut libc::c_char = azArg[i_5 as usize];
                if *z_3.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    && *z_3.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
                {
                    z_3 = z_3.offset(1)
                }
                if *z_3.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                    if zFile_1.is_null() {
                        zFile_1 = z_3
                    } else if zTable.is_null() {
                        zTable = z_3
                    } else {
                        fprintf(
                            (*p).out,
                            b"ERROR: extra argument: \"%s\".  Usage:\n\x00" as *const u8
                                as *const libc::c_char,
                            z_3,
                        );
                        showHelp((*p).out, b"import\x00" as *const u8 as *const libc::c_char);
                        rc = 1 as libc::c_int;
                        current_block = 4767945957387570333;
                        break;
                    }
                } else if strcmp(z_3, b"-v\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    eVerbose += 1
                } else if strcmp(z_3, b"-skip\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    && i_5 < nArg - 1 as libc::c_int
                {
                    i_5 += 1;
                    nSkip = integerValue(azArg[i_5 as usize]) as libc::c_int
                } else if strcmp(z_3, b"-ascii\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    sCtx.cColSep =
                        (*::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\x1f\x00"))
                            [0 as libc::c_int as usize] as libc::c_int;
                    sCtx.cRowSep =
                        (*::std::mem::transmute::<&[u8; 2], &[libc::c_char; 2]>(b"\x1e\x00"))
                            [0 as libc::c_int as usize] as libc::c_int;
                    xRead = Some(
                        ascii_read_one_field
                            as unsafe extern "C" fn(_: *mut ImportCtx) -> *mut libc::c_char,
                    );
                    useOutputMode = 0 as libc::c_int
                } else if strcmp(z_3, b"-csv\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    sCtx.cColSep = ',' as i32;
                    sCtx.cRowSep = '\n' as i32;
                    xRead = Some(
                        csv_read_one_field
                            as unsafe extern "C" fn(_: *mut ImportCtx) -> *mut libc::c_char,
                    );
                    useOutputMode = 0 as libc::c_int
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: unknown option: \"%s\".  Usage:\n\x00" as *const u8
                            as *const libc::c_char,
                        z_3,
                    );
                    showHelp((*p).out, b"import\x00" as *const u8 as *const libc::c_char);
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                }
                i_5 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if zTable.is_null() {
                        fprintf(
                            (*p).out,
                            b"ERROR: missing %s argument. Usage:\n\x00" as *const u8
                                as *const libc::c_char,
                            if zFile_1.is_null() {
                                b"FILE\x00" as *const u8 as *const libc::c_char
                            } else {
                                b"TABLE\x00" as *const u8 as *const libc::c_char
                            },
                        );
                        showHelp((*p).out, b"import\x00" as *const u8 as *const libc::c_char);
                        rc = 1 as libc::c_int
                    } else {
                        ::std::ptr::write_volatile(
                            &mut seenInterrupt as *mut libc::c_int,
                            0 as libc::c_int,
                        );
                        open_db(p, 0 as libc::c_int);
                        if useOutputMode != 0 {
                            /* If neither the --csv or --ascii options are specified, then set
                             ** the column and row separator characters from the output mode. */
                            nSep = strlen30((*p).colSeparator.as_mut_ptr());
                            if nSep == 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: non-null column separator required for import\n\x00"
                                        as *const u8
                                        as *const libc::c_char,
                                );
                                rc = 1 as libc::c_int;
                                current_block = 4767945957387570333;
                            } else if nSep > 1 as libc::c_int {
                                fprintf(stderr,
                                        b"Error: multi-character column separators not allowed for import\n\x00"
                                            as *const u8 as
                                            *const libc::c_char);
                                rc = 1 as libc::c_int;
                                current_block = 4767945957387570333;
                            } else {
                                nSep = strlen30((*p).rowSeparator.as_mut_ptr());
                                if nSep == 0 as libc::c_int {
                                    fprintf(
                                        stderr,
                                        b"Error: non-null row separator required for import\n\x00"
                                            as *const u8
                                            as *const libc::c_char,
                                    );
                                    rc = 1 as libc::c_int;
                                    current_block = 4767945957387570333;
                                } else {
                                    if nSep == 2 as libc::c_int
                                        && (*p).mode == 8 as libc::c_int
                                        && strcmp(
                                            (*p).rowSeparator.as_mut_ptr(),
                                            b"\r\n\x00" as *const u8 as *const libc::c_char,
                                        ) == 0 as libc::c_int
                                    {
                                        /* When importing CSV (only), if the row separator is set to the
                                         ** default output row separator, change it to the default input
                                         ** row separator.  This avoids having to maintain different input
                                         ** and output row separators. */
                                        sqlite3_snprintf(
                                            ::std::mem::size_of::<[libc::c_char; 20]>()
                                                as libc::c_ulong
                                                as libc::c_int,
                                            (*p).rowSeparator.as_mut_ptr(),
                                            b"\n\x00" as *const u8 as *const libc::c_char,
                                        ); /* To ensure sCtx.z is allocated */
                                        nSep = strlen30((*p).rowSeparator.as_mut_ptr())
                                    } /* no columns, no error */
                                    if nSep > 1 as libc::c_int {
                                        fprintf(stderr,
                                                b"Error: multi-character row separators not allowed for import\n\x00"
                                                    as *const u8 as
                                                    *const libc::c_char);
                                        rc = 1 as libc::c_int;
                                        current_block = 4767945957387570333;
                                    } else {
                                        sCtx.cColSep = (*p).colSeparator[0 as libc::c_int as usize]
                                            as libc::c_int;
                                        sCtx.cRowSep = (*p).rowSeparator[0 as libc::c_int as usize]
                                            as libc::c_int;
                                        current_block = 14410773951667535844;
                                    }
                                }
                            }
                        } else {
                            current_block = 14410773951667535844;
                        }
                        match current_block {
                            4767945957387570333 => {}
                            _ => {
                                sCtx.zFile = zFile_1;
                                sCtx.nLine = 1 as libc::c_int;
                                if *sCtx.zFile.offset(0 as libc::c_int as isize) as libc::c_int
                                    == '|' as i32
                                {
                                    sCtx.in_0 = popen(
                                        sCtx.zFile.offset(1 as libc::c_int as isize),
                                        b"r\x00" as *const u8 as *const libc::c_char,
                                    );
                                    sCtx.zFile = b"<pipe>\x00" as *const u8 as *const libc::c_char;
                                    sCtx.xCloser = Some(
                                        pclose as unsafe extern "C" fn(_: *mut FILE) -> libc::c_int,
                                    )
                                } else {
                                    sCtx.in_0 = fopen(
                                        sCtx.zFile,
                                        b"rb\x00" as *const u8 as *const libc::c_char,
                                    );
                                    sCtx.xCloser = Some(
                                        fclose as unsafe extern "C" fn(_: *mut FILE) -> libc::c_int,
                                    )
                                }
                                if sCtx.in_0.is_null() {
                                    fprintf(
                                        stderr,
                                        b"Error: cannot open \"%s\"\n\x00" as *const u8
                                            as *const libc::c_char,
                                        zFile_1,
                                    );
                                    rc = 1 as libc::c_int
                                } else {
                                    if eVerbose >= 2 as libc::c_int
                                        || eVerbose >= 1 as libc::c_int && useOutputMode != 0
                                    {
                                        let mut zSep: [libc::c_char; 2] = [0; 2];
                                        zSep[1 as libc::c_int as usize] =
                                            0 as libc::c_int as libc::c_char;
                                        zSep[0 as libc::c_int as usize] =
                                            sCtx.cColSep as libc::c_char;
                                        fprintf(
                                            (*p).out,
                                            b"Column separator \x00" as *const u8
                                                as *const libc::c_char,
                                        );
                                        output_c_string((*p).out, zSep.as_mut_ptr());
                                        fprintf(
                                            (*p).out,
                                            b", row separator \x00" as *const u8
                                                as *const libc::c_char,
                                        );
                                        zSep[0 as libc::c_int as usize] =
                                            sCtx.cRowSep as libc::c_char;
                                        output_c_string((*p).out, zSep.as_mut_ptr());
                                        fprintf(
                                            (*p).out,
                                            b"\n\x00" as *const u8 as *const libc::c_char,
                                        );
                                    }
                                    loop {
                                        let fresh91 = nSkip;
                                        nSkip = nSkip - 1;
                                        if !(fresh91 > 0 as libc::c_int) {
                                            break;
                                        }
                                        while !xRead.expect("non-null function pointer")(&mut sCtx)
                                            .is_null()
                                            && sCtx.cTerm == sCtx.cColSep
                                        {
                                        }
                                    }
                                    zSql_0 = sqlite3_mprintf(
                                        b"SELECT * FROM \"%w\"\x00" as *const u8
                                            as *const libc::c_char,
                                        zTable,
                                    );
                                    if zSql_0.is_null() {
                                        import_cleanup(&mut sCtx);
                                        shell_out_of_memory();
                                    }
                                    nByte = strlen30(zSql_0);
                                    rc = sqlite3_prepare_v2(
                                        (*p).db,
                                        zSql_0,
                                        -(1 as libc::c_int),
                                        &mut pStmt_1,
                                        0 as *mut *const libc::c_char,
                                    );
                                    import_append_char(&mut sCtx, 0 as libc::c_int);
                                    if rc != 0
                                        && sqlite3_strglob(
                                            b"no such table: *\x00" as *const u8
                                                as *const libc::c_char,
                                            sqlite3_errmsg((*p).db),
                                        ) == 0 as libc::c_int
                                    {
                                        let mut zCreate: *mut libc::c_char = sqlite3_mprintf(
                                            b"CREATE TABLE \"%w\"\x00" as *const u8
                                                as *const libc::c_char,
                                            zTable,
                                        );
                                        let mut cSep: libc::c_char = '(' as i32 as libc::c_char;
                                        while !xRead.expect("non-null function pointer")(&mut sCtx)
                                            .is_null()
                                        {
                                            zCreate = sqlite3_mprintf(
                                                b"%z%c\n  \"%w\" TEXT\x00" as *const u8
                                                    as *const libc::c_char,
                                                zCreate,
                                                cSep as libc::c_int,
                                                sCtx.z,
                                            );
                                            cSep = ',' as i32 as libc::c_char;
                                            if sCtx.cTerm != sCtx.cColSep {
                                                break;
                                            }
                                        }
                                        if cSep as libc::c_int == '(' as i32 {
                                            sqlite3_free(zCreate as *mut libc::c_void);
                                            import_cleanup(&mut sCtx);
                                            fprintf(
                                                stderr,
                                                b"%s: empty file\n\x00" as *const u8
                                                    as *const libc::c_char,
                                                sCtx.zFile,
                                            );
                                            rc = 1 as libc::c_int;
                                            current_block = 4767945957387570333;
                                        } else {
                                            zCreate = sqlite3_mprintf(
                                                b"%z\n)\x00" as *const u8 as *const libc::c_char,
                                                zCreate,
                                            );
                                            if eVerbose >= 1 as libc::c_int {
                                                fprintf(
                                                    (*p).out,
                                                    b"%s\n\x00" as *const u8 as *const libc::c_char,
                                                    zCreate,
                                                );
                                            }
                                            rc = sqlite3_exec(
                                                (*p).db,
                                                zCreate,
                                                None,
                                                0 as *mut libc::c_void,
                                                0 as *mut *mut libc::c_char,
                                            );
                                            sqlite3_free(zCreate as *mut libc::c_void);
                                            if rc != 0 {
                                                fprintf(
                                                    stderr,
                                                    b"CREATE TABLE \"%s\"(...) failed: %s\n\x00"
                                                        as *const u8
                                                        as *const libc::c_char,
                                                    zTable,
                                                    sqlite3_errmsg((*p).db),
                                                );
                                                import_cleanup(&mut sCtx);
                                                rc = 1 as libc::c_int;
                                                current_block = 4767945957387570333;
                                            } else {
                                                rc = sqlite3_prepare_v2(
                                                    (*p).db,
                                                    zSql_0,
                                                    -(1 as libc::c_int),
                                                    &mut pStmt_1,
                                                    0 as *mut *const libc::c_char,
                                                );
                                                current_block = 2962397401736245980;
                                            }
                                        }
                                    } else {
                                        current_block = 2962397401736245980;
                                    }
                                    match current_block {
                                        4767945957387570333 => {}
                                        _ => {
                                            sqlite3_free(zSql_0 as *mut libc::c_void);
                                            if rc != 0 {
                                                if !pStmt_1.is_null() {
                                                    sqlite3_finalize(pStmt_1);
                                                }
                                                fprintf(
                                                    stderr,
                                                    b"Error: %s\n\x00" as *const u8
                                                        as *const libc::c_char,
                                                    sqlite3_errmsg((*p).db),
                                                );
                                                import_cleanup(&mut sCtx);
                                                rc = 1 as libc::c_int
                                            } else {
                                                nCol = sqlite3_column_count(pStmt_1);
                                                sqlite3_finalize(pStmt_1);
                                                pStmt_1 = 0 as *mut sqlite3_stmt;
                                                if nCol == 0 as libc::c_int {
                                                    return 0 as libc::c_int;
                                                } else {
                                                    zSql_0 = sqlite3_malloc64(
                                                        (nByte * 2 as libc::c_int
                                                            + 20 as libc::c_int
                                                            + nCol * 2 as libc::c_int)
                                                            as sqlite3_uint64,
                                                    )
                                                        as *mut libc::c_char;
                                                    if zSql_0.is_null() {
                                                        import_cleanup(&mut sCtx);
                                                        shell_out_of_memory();
                                                    }
                                                    sqlite3_snprintf(
                                                        nByte + 20 as libc::c_int,
                                                        zSql_0,
                                                        b"INSERT INTO \"%w\" VALUES(?\x00"
                                                            as *const u8
                                                            as *const libc::c_char,
                                                        zTable,
                                                    );
                                                    j_0 = strlen30(zSql_0);
                                                    i_5 = 1 as libc::c_int;
                                                    while i_5 < nCol {
                                                        let fresh92 = j_0;
                                                        j_0 = j_0 + 1;
                                                        *zSql_0.offset(fresh92 as isize) =
                                                            ',' as i32 as libc::c_char;
                                                        let fresh93 = j_0;
                                                        j_0 = j_0 + 1;
                                                        *zSql_0.offset(fresh93 as isize) =
                                                            '?' as i32 as libc::c_char;
                                                        i_5 += 1
                                                    }
                                                    let fresh94 = j_0;
                                                    j_0 = j_0 + 1;
                                                    *zSql_0.offset(fresh94 as isize) =
                                                        ')' as i32 as libc::c_char;
                                                    *zSql_0.offset(j_0 as isize) =
                                                        0 as libc::c_int as libc::c_char;
                                                    if eVerbose >= 2 as libc::c_int {
                                                        fprintf(
                                                            (*p).out,
                                                            b"Insert using: %s\n\x00" as *const u8
                                                                as *const libc::c_char,
                                                            zSql_0,
                                                        );
                                                    }
                                                    rc = sqlite3_prepare_v2(
                                                        (*p).db,
                                                        zSql_0,
                                                        -(1 as libc::c_int),
                                                        &mut pStmt_1,
                                                        0 as *mut *const libc::c_char,
                                                    );
                                                    sqlite3_free(zSql_0 as *mut libc::c_void);
                                                    if rc != 0 {
                                                        fprintf(
                                                            stderr,
                                                            b"Error: %s\n\x00" as *const u8
                                                                as *const libc::c_char,
                                                            sqlite3_errmsg((*p).db),
                                                        );
                                                        if !pStmt_1.is_null() {
                                                            sqlite3_finalize(pStmt_1);
                                                        }
                                                        import_cleanup(&mut sCtx);
                                                        rc = 1 as libc::c_int
                                                    } else {
                                                        needCommit =
                                                            sqlite3_get_autocommit((*p).db);
                                                        if needCommit != 0 {
                                                            sqlite3_exec(
                                                                (*p).db,
                                                                b"BEGIN\x00" as *const u8
                                                                    as *const libc::c_char,
                                                                None,
                                                                0 as *mut libc::c_void,
                                                                0 as *mut *mut libc::c_char,
                                                            );
                                                        }
                                                        loop {
                                                            let mut startLine: libc::c_int =
                                                                sCtx.nLine;
                                                            i_5 = 0 as libc::c_int;
                                                            while i_5 < nCol {
                                                                let mut z_4: *mut libc::c_char =
                                                                    xRead.expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                        &mut sCtx
                                                                    );
                                                                /*
                                                                 ** Did we reach end-of-file before finding any columns?
                                                                 ** If so, stop instead of NULL filling the remaining columns.
                                                                 */
                                                                if z_4.is_null()
                                                                    && i_5 == 0 as libc::c_int
                                                                {
                                                                    break;
                                                                }
                                                                /*
                                                                 ** Did we reach end-of-file OR end-of-line before finding any
                                                                 ** columns in ASCII mode?  If so, stop instead of NULL filling
                                                                 ** the remaining columns.
                                                                 */
                                                                if (*p).mode == 10 as libc::c_int
                                                                    && (z_4.is_null()
                                                                        || *z_4.offset(
                                                                            0 as libc::c_int
                                                                                as isize,
                                                                        )
                                                                            as libc::c_int
                                                                            == 0 as libc::c_int)
                                                                    && i_5 == 0 as libc::c_int
                                                                {
                                                                    break; /* True if making an imposter of a WITHOUT ROWID table */
                                                                } /* Length of the PRIMARY KEY string for isWO tables */
                                                                sqlite3_bind_text(
                                                                    pStmt_1,
                                                                    i_5 + 1 as libc::c_int,
                                                                    z_4,
                                                                    -(1 as libc::c_int),
                                                                    ::std::mem::transmute::<
                                                                        libc::intptr_t,
                                                                        sqlite3_destructor_type,
                                                                    >(
                                                                        -(1 as libc::c_int)
                                                                            as libc::intptr_t,
                                                                    ),
                                                                );
                                                                if i_5 < nCol - 1 as libc::c_int
                                                                    && sCtx.cTerm != sCtx.cColSep
                                                                {
                                                                    fprintf(stderr,
                                                                            b"%s:%d: expected %d columns but found %d - filling the rest with NULL\n\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const libc::c_char,
                                                                            sCtx.zFile,
                                                                            startLine,
                                                                            nCol,
                                                                            i_5
                                                                                +
                                                                                1
                                                                                    as
                                                                                    libc::c_int);
                                                                    i_5 += 2 as libc::c_int;
                                                                    while i_5 <= nCol {
                                                                        sqlite3_bind_null(
                                                                            pStmt_1, i_5,
                                                                        );
                                                                        i_5 += 1
                                                                    }
                                                                }
                                                                i_5 += 1
                                                            }
                                                            if sCtx.cTerm == sCtx.cColSep {
                                                                loop {
                                                                    xRead.expect(
                                                                        "non-null function pointer",
                                                                    )(
                                                                        &mut sCtx
                                                                    );
                                                                    i_5 += 1;
                                                                    if !(sCtx.cTerm == sCtx.cColSep)
                                                                    {
                                                                        break;
                                                                    }
                                                                }
                                                                fprintf(stderr,
                                                                        b"%s:%d: expected %d columns but found %d - extras ignored\n\x00"
                                                                            as
                                                                            *const u8
                                                                            as
                                                                            *const libc::c_char,
                                                                        sCtx.zFile,
                                                                        startLine,
                                                                        nCol,
                                                                        i_5);
                                                            }
                                                            if i_5 >= nCol {
                                                                sqlite3_step(pStmt_1);
                                                                rc = sqlite3_reset(pStmt_1);
                                                                if rc != 0 as libc::c_int {
                                                                    fprintf(stderr,
                                                                            b"%s:%d: INSERT failed: %s\n\x00"
                                                                                as
                                                                                *const u8
                                                                                as
                                                                                *const libc::c_char,
                                                                            sCtx.zFile,
                                                                            startLine,
                                                                            sqlite3_errmsg((*p).db));
                                                                    sCtx.nErr += 1
                                                                } else {
                                                                    sCtx.nRow += 1
                                                                }
                                                            }
                                                            if !(sCtx.cTerm != -(1 as libc::c_int))
                                                            {
                                                                break;
                                                            }
                                                        }
                                                        import_cleanup(&mut sCtx);
                                                        sqlite3_finalize(pStmt_1);
                                                        if needCommit != 0 {
                                                            sqlite3_exec(
                                                                (*p).db,
                                                                b"COMMIT\x00" as *const u8
                                                                    as *const libc::c_char,
                                                                None,
                                                                0 as *mut libc::c_void,
                                                                0 as *mut *mut libc::c_char,
                                                            );
                                                        }
                                                        if eVerbose > 0 as libc::c_int {
                                                            fprintf((*p).out,
                                                                    b"Added %d rows with %d errors using %d lines of input\n\x00"
                                                                        as
                                                                        *const u8
                                                                        as
                                                                        *const libc::c_char,
                                                                    sCtx.nRow,
                                                                    sCtx.nErr,
                                                                    sCtx.nLine
                                                                        -
                                                                        1 as
                                                                            libc::c_int);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        } else if c == 'i' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"imposter\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zSql_1: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zCollist: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut pStmt_2: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut tnum: libc::c_int = 0 as libc::c_int;
            let mut isWO: libc::c_int = 0 as libc::c_int;
            let mut lenPK: libc::c_int = 0 as libc::c_int;
            let mut i_6: libc::c_int = 0;
            if !(nArg == 3 as libc::c_int
                || nArg == 2 as libc::c_int
                    && sqlite3_stricmp(
                        azArg[1 as libc::c_int as usize],
                        b"off\x00" as *const u8 as *const libc::c_char,
                    ) == 0 as libc::c_int)
            {
                fprintf(
                    stderr,
                    b"Usage: .imposter INDEX IMPOSTER\n       .imposter off\n\x00" as *const u8
                        as *const libc::c_char,
                );
                /* Also allowed, but not documented:
                 **
                 **    .imposter TABLE IMPOSTER
                 **
                 ** where TABLE is a WITHOUT ROWID table.  In that case, the
                 ** imposter is another WITHOUT ROWID table with the columns in
                 ** storage order. */
                rc = 1 as libc::c_int
            } else {
                open_db(p, 0 as libc::c_int);
                if nArg == 2 as libc::c_int {
                    sqlite3_test_control(
                        25 as libc::c_int,
                        (*p).db,
                        b"main\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int,
                        1 as libc::c_int,
                    );
                } else {
                    zSql_1 =
                        sqlite3_mprintf(b"SELECT rootpage, 0 FROM sqlite_schema WHERE name=\'%q\' AND type=\'index\'UNION ALL SELECT rootpage, 1 FROM sqlite_schema WHERE name=\'%q\' AND type=\'table\'   AND sql LIKE \'%%without%%rowid%%\'\x00"
                                            as *const u8 as
                                            *const libc::c_char,
                                        azArg[1 as libc::c_int as usize],
                                        azArg[1 as libc::c_int as usize]);
                    sqlite3_prepare_v2(
                        (*p).db,
                        zSql_1,
                        -(1 as libc::c_int),
                        &mut pStmt_2,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_1 as *mut libc::c_void);
                    if sqlite3_step(pStmt_2) == 100 as libc::c_int {
                        tnum = sqlite3_column_int(pStmt_2, 0 as libc::c_int);
                        isWO = sqlite3_column_int(pStmt_2, 1 as libc::c_int)
                    }
                    sqlite3_finalize(pStmt_2);
                    zSql_1 = sqlite3_mprintf(
                        b"PRAGMA index_xinfo=\'%q\'\x00" as *const u8 as *const libc::c_char,
                        azArg[1 as libc::c_int as usize],
                    );
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        zSql_1,
                        -(1 as libc::c_int),
                        &mut pStmt_2,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_1 as *mut libc::c_void);
                    i_6 = 0 as libc::c_int;
                    while rc == 0 as libc::c_int && sqlite3_step(pStmt_2) == 100 as libc::c_int {
                        let mut zLabel: [libc::c_char; 20] = [0; 20];
                        let mut zCol: *const libc::c_char =
                            sqlite3_column_text(pStmt_2, 2 as libc::c_int) as *const libc::c_char;
                        i_6 += 1;
                        if zCol.is_null() {
                            if sqlite3_column_int(pStmt_2, 1 as libc::c_int) == -(1 as libc::c_int)
                            {
                                zCol = b"_ROWID_\x00" as *const u8 as *const libc::c_char
                            } else {
                                sqlite3_snprintf(
                                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                        as libc::c_int,
                                    zLabel.as_mut_ptr(),
                                    b"expr%d\x00" as *const u8 as *const libc::c_char,
                                    i_6,
                                );
                                zCol = zLabel.as_mut_ptr()
                            }
                        }
                        if isWO != 0
                            && lenPK == 0 as libc::c_int
                            && sqlite3_column_int(pStmt_2, 5 as libc::c_int) == 0 as libc::c_int
                            && !zCollist.is_null()
                        {
                            lenPK = strlen(zCollist) as libc::c_int
                        }
                        if zCollist.is_null() {
                            zCollist = sqlite3_mprintf(
                                b"\"%w\"\x00" as *const u8 as *const libc::c_char,
                                zCol,
                            )
                        } else {
                            zCollist = sqlite3_mprintf(
                                b"%z,\"%w\"\x00" as *const u8 as *const libc::c_char,
                                zCollist,
                                zCol,
                            )
                        }
                    }
                    sqlite3_finalize(pStmt_2);
                    if i_6 == 0 as libc::c_int || tnum == 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"no such index: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int;
                        sqlite3_free(zCollist as *mut libc::c_void);
                    } else {
                        if lenPK == 0 as libc::c_int {
                            lenPK = 100000 as libc::c_int
                        }
                        zSql_1 = sqlite3_mprintf(
                            b"CREATE TABLE \"%w\"(%s,PRIMARY KEY(%.*s))WITHOUT ROWID\x00"
                                as *const u8 as *const libc::c_char,
                            azArg[2 as libc::c_int as usize],
                            zCollist,
                            lenPK,
                            zCollist,
                        );
                        sqlite3_free(zCollist as *mut libc::c_void);
                        rc = sqlite3_test_control(
                            25 as libc::c_int,
                            (*p).db,
                            b"main\x00" as *const u8 as *const libc::c_char,
                            1 as libc::c_int,
                            tnum,
                        );
                        if rc == 0 as libc::c_int {
                            rc = sqlite3_exec(
                                (*p).db,
                                zSql_1,
                                None,
                                0 as *mut libc::c_void,
                                0 as *mut *mut libc::c_char,
                            );
                            sqlite3_test_control(
                                25 as libc::c_int,
                                (*p).db,
                                b"main\x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int,
                                0 as libc::c_int,
                            );
                            if rc != 0 {
                                fprintf(
                                    stderr,
                                    b"Error in [%s]: %s\n\x00" as *const u8 as *const libc::c_char,
                                    zSql_1,
                                    sqlite3_errmsg((*p).db),
                                );
                            } else {
                                fprintf(
                                    stdout,
                                    b"%s;\n\x00" as *const u8 as *const libc::c_char,
                                    zSql_1,
                                );
                                fprintf(stdout,
                                        b"WARNING: writing to an imposter table will corrupt the \"%s\" %s!\n\x00"
                                            as *const u8 as
                                            *const libc::c_char,
                                        azArg[1 as libc::c_int as usize],
                                        if isWO != 0 {
                                            b"table\x00" as *const u8 as
                                                *const libc::c_char
                                        } else {
                                            b"index\x00" as *const u8 as
                                                *const libc::c_char
                                        });
                            }
                        } else {
                            fprintf(
                                stderr,
                                b"SQLITE_TESTCTRL_IMPOSTER returns %d\n\x00" as *const u8
                                    as *const libc::c_char,
                                rc,
                            );
                            rc = 1 as libc::c_int
                        }
                        sqlite3_free(zSql_1 as *mut libc::c_void);
                    }
                }
            }
        } else if c == 'l' as i32
            && n >= 5 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"limits\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            /* !defined(SQLITE_OMIT_TEST_CONTROL) */
            /* Integer code for that limit */
            static mut aLimit: [C2RustUnnamed_20; 12] = [
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"length\x00" as *const u8 as *const libc::c_char,
                        limitCode: 0 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"sql_length\x00" as *const u8 as *const libc::c_char,
                        limitCode: 1 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"column\x00" as *const u8 as *const libc::c_char,
                        limitCode: 2 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"expr_depth\x00" as *const u8 as *const libc::c_char,
                        limitCode: 3 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"compound_select\x00" as *const u8 as *const libc::c_char,
                        limitCode: 4 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"vdbe_op\x00" as *const u8 as *const libc::c_char,
                        limitCode: 5 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"function_arg\x00" as *const u8 as *const libc::c_char,
                        limitCode: 6 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"attached\x00" as *const u8 as *const libc::c_char,
                        limitCode: 7 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"like_pattern_length\x00" as *const u8 as *const libc::c_char,
                        limitCode: 8 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"variable_number\x00" as *const u8 as *const libc::c_char,
                        limitCode: 9 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"trigger_depth\x00" as *const u8 as *const libc::c_char,
                        limitCode: 10 as libc::c_int,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_20 {
                        zLimitName: b"worker_threads\x00" as *const u8 as *const libc::c_char,
                        limitCode: 11 as libc::c_int,
                    };
                    init
                },
            ];
            let mut i_7: libc::c_int = 0;
            let mut n2_0: libc::c_int = 0;
            open_db(p, 0 as libc::c_int);
            if nArg == 1 as libc::c_int {
                i_7 = 0 as libc::c_int;
                while i_7
                    < (::std::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong)
                        as libc::c_int
                {
                    printf(
                        b"%20s %d\n\x00" as *const u8 as *const libc::c_char,
                        aLimit[i_7 as usize].zLimitName,
                        sqlite3_limit((*p).db, aLimit[i_7 as usize].limitCode, -(1 as libc::c_int)),
                    );
                    i_7 += 1
                }
            } else if nArg > 3 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .limit NAME ?NEW-VALUE?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                let mut iLimit: libc::c_int = -(1 as libc::c_int);
                n2_0 = strlen30(azArg[1 as libc::c_int as usize]);
                i_7 = 0 as libc::c_int;
                loop {
                    if !(i_7 < (::std::mem::size_of::<[C2RustUnnamed_20; 12]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_20>() as libc::c_ulong)
                        as libc::c_int)
                    {
                        current_block = 8496281696766203430;
                        break;
                    }
                    if sqlite3_strnicmp(
                        aLimit[i_7 as usize].zLimitName,
                        azArg[1 as libc::c_int as usize],
                        n2_0,
                    ) == 0 as libc::c_int
                    {
                        if iLimit < 0 as libc::c_int {
                            iLimit = i_7
                        } else {
                            fprintf(
                                stderr,
                                b"ambiguous limit: \"%s\"\n\x00" as *const u8
                                    as *const libc::c_char,
                                azArg[1 as libc::c_int as usize],
                            );
                            rc = 1 as libc::c_int;
                            current_block = 4767945957387570333;
                            break;
                        }
                    }
                    i_7 += 1
                }
                match current_block {
                    4767945957387570333 => {}
                    _ => {
                        if iLimit < 0 as libc::c_int {
                            fprintf(stderr,
                                    b"unknown limit: \"%s\"\nenter \".limits\" with no arguments for a list.\n\x00"
                                        as *const u8 as *const libc::c_char,
                                    azArg[1 as libc::c_int as usize]);
                            rc = 1 as libc::c_int
                        } else {
                            if nArg == 3 as libc::c_int {
                                sqlite3_limit(
                                    (*p).db,
                                    aLimit[iLimit as usize].limitCode,
                                    integerValue(azArg[2 as libc::c_int as usize]) as libc::c_int,
                                );
                            }
                            printf(
                                b"%20s %d\n\x00" as *const u8 as *const libc::c_char,
                                aLimit[iLimit as usize].zLimitName,
                                sqlite3_limit(
                                    (*p).db,
                                    aLimit[iLimit as usize].limitCode,
                                    -(1 as libc::c_int),
                                ),
                            );
                        }
                    }
                }
            }
        } else if c == 'l' as i32
            && n > 2 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"lint\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            lintDotCommand(p, azArg.as_mut_ptr(), nArg);
        } else if c == 'l' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"load\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zFile_2: *const libc::c_char = 0 as *const libc::c_char;
            let mut zProc: *const libc::c_char = 0 as *const libc::c_char;
            let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
            failIfSafeMode(
                p,
                b"cannot run .load in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg < 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .load FILE ?ENTRYPOINT?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                zFile_2 = azArg[1 as libc::c_int as usize];
                zProc = if nArg >= 3 as libc::c_int {
                    azArg[2 as libc::c_int as usize]
                } else {
                    0 as *mut libc::c_char
                };
                open_db(p, 0 as libc::c_int);
                rc = sqlite3_load_extension((*p).db, zFile_2, zProc, &mut zErrMsg);
                if rc != 0 as libc::c_int {
                    fprintf(
                        stderr,
                        b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                        zErrMsg,
                    );
                    sqlite3_free(zErrMsg as *mut libc::c_void);
                    rc = 1 as libc::c_int
                }
            }
        } else if c == 'l' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"log\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            failIfSafeMode(
                p,
                b"cannot run .log in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg != 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .log FILENAME\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                let mut zFile_3: *const libc::c_char = azArg[1 as libc::c_int as usize];
                output_file_close((*p).pLog);
                (*p).pLog = output_file_open(zFile_3, 0 as libc::c_int)
            }
        } else if c == 'm' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"mode\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zMode: *const libc::c_char = if nArg >= 2 as libc::c_int {
                azArg[1 as libc::c_int as usize] as *const libc::c_char
            } else {
                b"\x00" as *const u8 as *const libc::c_char
            };
            let mut n2_1: libc::c_int = strlen30(zMode);
            let mut c2: libc::c_int = *zMode.offset(0 as libc::c_int as isize) as libc::c_int;
            if c2 == 'l' as i32
                && n2_1 > 2 as libc::c_int
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"lines\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 0 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'c' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"columns\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 1 as libc::c_int;
                if (*p).shellFlgs & 0x80 as libc::c_int as libc::c_uint
                    == 0 as libc::c_int as libc::c_uint
                {
                    (*p).showHeader = 1 as libc::c_int
                }
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'l' as i32
                && n2_1 > 2 as libc::c_int
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"list\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 2 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b"|\x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'h' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"html\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 4 as libc::c_int
            } else if c2 == 't' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"tcl\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 7 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b" \x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'c' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"csv\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 8 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b",\x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\r\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 't' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"tabs\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 2 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b"\t\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'i' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"insert\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 5 as libc::c_int;
                set_table_name(
                    p,
                    if nArg >= 3 as libc::c_int {
                        azArg[2 as libc::c_int as usize] as *const libc::c_char
                    } else {
                        b"table\x00" as *const u8 as *const libc::c_char
                    },
                );
            } else if c2 == 'q' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"quote\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 6 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b",\x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\n\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'a' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"ascii\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 10 as libc::c_int;
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b"\x1f\x00" as *const u8 as *const libc::c_char,
                );
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"\x1e\x00" as *const u8 as *const libc::c_char,
                );
            } else if c2 == 'm' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"markdown\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 14 as libc::c_int
            } else if c2 == 't' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"table\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 15 as libc::c_int
            } else if c2 == 'b' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"box\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 16 as libc::c_int
            } else if c2 == 'j' as i32
                && strncmp(
                    azArg[1 as libc::c_int as usize],
                    b"json\x00" as *const u8 as *const libc::c_char,
                    n2_1 as libc::c_ulong,
                ) == 0 as libc::c_int
            {
                (*p).mode = 13 as libc::c_int
            } else if nArg == 1 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"current output mode: %s\n\x00" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                );
            } else {
                fprintf(stderr,
                        b"Error: mode should be one of: ascii box column csv html insert json line list markdown quote table tabs tcl\n\x00"
                            as *const u8 as *const libc::c_char);
                rc = 1 as libc::c_int
            }
            (*p).cMode = (*p).mode
        } else if c == 'n' as i32
            && strcmp(
                azArg[0 as libc::c_int as usize],
                b"nonce\x00" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            if nArg != 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .nonce NONCE\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else if (*p).zNonce.is_null()
                || strcmp(azArg[1 as libc::c_int as usize], (*p).zNonce) != 0 as libc::c_int
            {
                fprintf(
                    stderr,
                    b"line %d: incorrect nonce: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                    (*p).lineno,
                    azArg[1 as libc::c_int as usize],
                );
                exit(1 as libc::c_int);
            } else {
                (*p).bSafeMode = 0 as libc::c_int as u8_0;
                return 0 as libc::c_int;
                /* Return immediately to bypass the safe mode reset
                 ** at the end of this procedure */
            }
        } else if c == 'n' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"nullvalue\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).nullValue.as_mut_ptr(),
                    b"%.*s\x00" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int,
                    azArg[1 as libc::c_int as usize],
                );
            } else {
                fprintf(
                    stderr,
                    b"Usage: .nullvalue STRING\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 'o' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"open\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            && n >= 2 as libc::c_int
        {
            /* SQLITE_DEBUG */
            let mut zNewFilename: *mut libc::c_char = 0 as *mut libc::c_char; /* Name of the database file to open */
            let mut iName: libc::c_int = 1 as libc::c_int; /* Index in azArg[] of the filename */
            let mut newFlag: libc::c_int = 0 as libc::c_int; /* True to delete file before opening */
            /* Close the existing database */
            close_db((*p).db);
            (*p).db = 0 as *mut sqlite3;
            (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char;
            sqlite3_free((*(*p).pAuxDb).zFreeOnClose as *mut libc::c_void);
            (*(*p).pAuxDb).zFreeOnClose = 0 as *mut libc::c_char;
            (*p).openMode = 0 as libc::c_int as u8_0;
            (*p).openFlags = 0 as libc::c_int;
            (*p).szMax = 0 as libc::c_int as sqlite3_int64;
            /* Check for command-line arguments */
            iName = 1 as libc::c_int;
            loop {
                if !(iName < nArg) {
                    current_block = 9023099792512066638;
                    break;
                }
                let mut z_5: *const libc::c_char = azArg[iName as usize];
                if optionMatch(z_5, b"new\x00" as *const u8 as *const libc::c_char) != 0 {
                    newFlag = 1 as libc::c_int
                } else if optionMatch(z_5, b"zip\x00" as *const u8 as *const libc::c_char) != 0 {
                    (*p).openMode = 3 as libc::c_int as u8_0
                } else if optionMatch(z_5, b"append\x00" as *const u8 as *const libc::c_char) != 0 {
                    (*p).openMode = 2 as libc::c_int as u8_0
                } else if optionMatch(z_5, b"readonly\x00" as *const u8 as *const libc::c_char) != 0
                {
                    (*p).openMode = 4 as libc::c_int as u8_0
                } else if optionMatch(z_5, b"nofollow\x00" as *const u8 as *const libc::c_char) != 0
                {
                    (*p).openFlags |= 0x1000000 as libc::c_int
                } else if optionMatch(z_5, b"deserialize\x00" as *const u8 as *const libc::c_char)
                    != 0
                {
                    (*p).openMode = 5 as libc::c_int as u8_0
                } else if optionMatch(z_5, b"hexdb\x00" as *const u8 as *const libc::c_char) != 0 {
                    (*p).openMode = 6 as libc::c_int as u8_0
                } else if optionMatch(z_5, b"maxsize\x00" as *const u8 as *const libc::c_char) != 0
                    && (iName + 1 as libc::c_int) < nArg
                {
                    iName += 1;
                    (*p).szMax = integerValue(azArg[iName as usize])
                    /* SQLITE_OMIT_DESERIALIZE */
                } else if *z_5.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    fprintf(
                        stderr,
                        b"unknown option: %s\n\x00" as *const u8 as *const libc::c_char,
                        z_5,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                } else if !zNewFilename.is_null() {
                    fprintf(
                        stderr,
                        b"extra argument: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                        z_5,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                } else {
                    zNewFilename =
                        sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, z_5)
                }
                iName += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ =>
                /* If a filename is specified, try to open it first */
                {
                    if !zNewFilename.is_null() || (*p).openMode as libc::c_int == 6 as libc::c_int {
                        if newFlag != 0 && (*p).bSafeMode == 0 {
                            shellDeleteFile(zNewFilename);
                        }
                        if (*p).bSafeMode as libc::c_int != 0
                            && (*p).openMode as libc::c_int != 6 as libc::c_int
                            && !zNewFilename.is_null()
                            && strcmp(
                                zNewFilename,
                                b":memory:\x00" as *const u8 as *const libc::c_char,
                            ) != 0 as libc::c_int
                        {
                            failIfSafeMode(
                                p,
                                b"cannot open disk-based database files in safe mode\x00"
                                    as *const u8
                                    as *const libc::c_char,
                            );
                        }
                        (*(*p).pAuxDb).zDbFilename = zNewFilename;
                        open_db(p, 0x1 as libc::c_int);
                        if (*p).db.is_null() {
                            fprintf(
                                stderr,
                                b"Error: cannot open \'%s\'\n\x00" as *const u8
                                    as *const libc::c_char,
                                zNewFilename,
                            );
                            sqlite3_free(zNewFilename as *mut libc::c_void);
                        } else {
                            (*(*p).pAuxDb).zFreeOnClose = zNewFilename
                        }
                    }
                    if (*p).db.is_null() {
                        /* As a fall-back open a TEMP database */
                        (*(*p).pAuxDb).zDbFilename = 0 as *const libc::c_char; /* 0: .output, 1: .once, 2: .excel */
                        open_db(p, 0 as libc::c_int);
                    }
                }
            }
        } else if c == 'o' as i32
            && (strncmp(
                azArg[0 as libc::c_int as usize],
                b"output\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
                || strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"once\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                ) == 0 as libc::c_int)
            || c == 'e' as i32
                && n == 5 as libc::c_int
                && strcmp(
                    azArg[0 as libc::c_int as usize],
                    b"excel\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
        {
            let mut zFile_4: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut bTxtMode: libc::c_int = 0 as libc::c_int;
            let mut i_8: libc::c_int = 0;
            let mut eMode: libc::c_int = 0 as libc::c_int;
            let mut bBOM: libc::c_int = 0 as libc::c_int;
            let mut bOnce: libc::c_int = 0 as libc::c_int;
            failIfSafeMode(
                p,
                b"cannot run .%s in safe mode\x00" as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            if c == 'e' as i32 {
                eMode = 'x' as i32;
                bOnce = 2 as libc::c_int
            } else if strncmp(
                azArg[0 as libc::c_int as usize],
                b"once\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            {
                bOnce = 1 as libc::c_int
            }
            i_8 = 1 as libc::c_int;
            's_4073: loop {
                if !(i_8 < nArg) {
                    current_block = 8614990919848971746;
                    break;
                }
                let mut z_6: *mut libc::c_char = azArg[i_8 as usize];
                if *z_6.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    if *z_6.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                        z_6 = z_6.offset(1)
                    }
                    if strcmp(z_6, b"-bom\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        bBOM = 1 as libc::c_int
                    } else if c != 'e' as i32
                        && strcmp(z_6, b"-x\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                    {
                        eMode = 'x' as i32
                        /* spreadsheet */
                    } else if c != 'e' as i32
                        && strcmp(z_6, b"-e\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                    {
                        eMode = 'e' as i32
                        /* text editor */
                    } else {
                        fprintf(
                            (*p).out,
                            b"ERROR: unknown option: \"%s\".  Usage:\n\x00" as *const u8
                                as *const libc::c_char,
                            azArg[i_8 as usize],
                        );
                        showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                        rc = 1 as libc::c_int;
                        current_block = 4767945957387570333;
                        break;
                    }
                } else if zFile_4.is_null() && eMode != 'e' as i32 && eMode != 'x' as i32 {
                    zFile_4 = sqlite3_mprintf(b"%s\x00" as *const u8 as *const libc::c_char, z_6);
                    if *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int == '|' as i32 {
                        loop {
                            if !((i_8 + 1 as libc::c_int) < nArg) {
                                current_block = 8614990919848971746;
                                break 's_4073;
                            }
                            i_8 += 1;
                            zFile_4 = sqlite3_mprintf(
                                b"%z %s\x00" as *const u8 as *const libc::c_char,
                                zFile_4,
                                azArg[i_8 as usize],
                            )
                        }
                    }
                } else {
                    fprintf(
                        (*p).out,
                        b"ERROR: extra parameter: \"%s\".  Usage:\n\x00" as *const u8
                            as *const libc::c_char,
                        azArg[i_8 as usize],
                    );
                    showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                    rc = 1 as libc::c_int;
                    sqlite3_free(zFile_4 as *mut libc::c_void);
                    current_block = 4767945957387570333;
                    break;
                }
                i_8 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if zFile_4.is_null() {
                        zFile_4 = sqlite3_mprintf(b"stdout\x00" as *const u8 as *const libc::c_char)
                    }
                    if bOnce != 0 {
                        (*p).outCount = 2 as libc::c_int
                    } else {
                        (*p).outCount = 0 as libc::c_int
                    }
                    output_reset(p);
                    if eMode == 'e' as i32 || eMode == 'x' as i32 {
                        (*p).doXdgOpen = 1 as libc::c_int as u8_0;
                        outputModePush(p);
                        if eMode == 'x' as i32 {
                            /* spreadsheet mode.  Output as CSV. */
                            newTempFile(p, b"csv\x00" as *const u8 as *const libc::c_char);
                            (*p).shellFlgs &= !(0x40 as libc::c_int) as libc::c_uint;
                            (*p).mode = 8 as libc::c_int;
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                    as libc::c_int,
                                (*p).colSeparator.as_mut_ptr(),
                                b",\x00" as *const u8 as *const libc::c_char,
                            );
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong
                                    as libc::c_int,
                                (*p).rowSeparator.as_mut_ptr(),
                                b"\r\n\x00" as *const u8 as *const libc::c_char,
                            );
                        } else {
                            /* text editor mode */
                            newTempFile(p, b"txt\x00" as *const u8 as *const libc::c_char);
                            bTxtMode = 1 as libc::c_int
                        }
                        sqlite3_free(zFile_4 as *mut libc::c_void);
                        zFile_4 = sqlite3_mprintf(
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            (*p).zTempFile,
                        )
                    }
                    /* SQLITE_NOHAVE_SYSTEM */
                    if *zFile_4.offset(0 as libc::c_int as isize) as libc::c_int == '|' as i32 {
                        (*p).out = popen(
                            zFile_4.offset(1 as libc::c_int as isize),
                            b"w\x00" as *const u8 as *const libc::c_char,
                        );
                        if (*p).out.is_null() {
                            fprintf(
                                stderr,
                                b"Error: cannot open pipe \"%s\"\n\x00" as *const u8
                                    as *const libc::c_char,
                                zFile_4.offset(1 as libc::c_int as isize),
                            );
                            (*p).out = stdout;
                            rc = 1 as libc::c_int
                        } else {
                            if bBOM != 0 {
                                fprintf(
                                    (*p).out,
                                    b"\xef\xbb\xbf\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                                    as libc::c_int,
                                (*p).outfile.as_mut_ptr(),
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                zFile_4,
                            );
                        }
                    } else {
                        (*p).out = output_file_open(zFile_4, bTxtMode);
                        if (*p).out.is_null() {
                            if strcmp(zFile_4, b"off\x00" as *const u8 as *const libc::c_char)
                                != 0 as libc::c_int
                            {
                                fprintf(
                                    stderr,
                                    b"Error: cannot write to \"%s\"\n\x00" as *const u8
                                        as *const libc::c_char,
                                    zFile_4,
                                );
                            }
                            (*p).out = stdout;
                            rc = 1 as libc::c_int
                        } else {
                            if bBOM != 0 {
                                fprintf(
                                    (*p).out,
                                    b"\xef\xbb\xbf\x00" as *const u8 as *const libc::c_char,
                                );
                            }
                            sqlite3_snprintf(
                                ::std::mem::size_of::<[libc::c_char; 4096]>() as libc::c_ulong
                                    as libc::c_int,
                                (*p).outfile.as_mut_ptr(),
                                b"%s\x00" as *const u8 as *const libc::c_char,
                                zFile_4,
                            );
                        }
                    }
                    sqlite3_free(zFile_4 as *mut libc::c_void);
                }
            }
        } else if c == 'p' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"parameter\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            if nArg <= 1 as libc::c_int {
                current_block = 5711410892010072419;
            } else if nArg == 2 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"clear\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                sqlite3_exec(
                    (*p).db,
                    b"DROP TABLE IF EXISTS temp.sqlite_parameters;\x00" as *const u8
                        as *const libc::c_char,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                current_block = 4767945957387570333;
            } else if nArg == 2 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"list\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                let mut pStmt_3: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                let mut rx: libc::c_int = 0;
                let mut len: libc::c_int = 0 as libc::c_int;
                rx = sqlite3_prepare_v2(
                    (*p).db,
                    b"SELECT max(length(key)) FROM temp.sqlite_parameters;\x00" as *const u8
                        as *const libc::c_char,
                    -(1 as libc::c_int),
                    &mut pStmt_3,
                    0 as *mut *const libc::c_char,
                );
                if rx == 0 as libc::c_int && sqlite3_step(pStmt_3) == 100 as libc::c_int {
                    len = sqlite3_column_int(pStmt_3, 0 as libc::c_int);
                    if len > 40 as libc::c_int {
                        len = 40 as libc::c_int
                    }
                }
                sqlite3_finalize(pStmt_3);
                pStmt_3 = 0 as *mut sqlite3_stmt;
                if len != 0 {
                    rx = sqlite3_prepare_v2(
                        (*p).db,
                        b"SELECT key, quote(value) FROM temp.sqlite_parameters;\x00" as *const u8
                            as *const libc::c_char,
                        -(1 as libc::c_int),
                        &mut pStmt_3,
                        0 as *mut *const libc::c_char,
                    );
                    while rx == 0 as libc::c_int && sqlite3_step(pStmt_3) == 100 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"%-*s %s\n\x00" as *const u8 as *const libc::c_char,
                            len,
                            sqlite3_column_text(pStmt_3, 0 as libc::c_int),
                            sqlite3_column_text(pStmt_3, 1 as libc::c_int),
                        );
                    }
                    sqlite3_finalize(pStmt_3);
                    current_block = 4767945957387570333;
                } else {
                    current_block = 4767945957387570333;
                }
            } else if nArg == 2 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"init\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                bind_table_init(p);
                current_block = 4767945957387570333;
            } else if nArg == 4 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"set\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                let mut rx_0: libc::c_int = 0;
                let mut zSql_2: *mut libc::c_char = 0 as *mut libc::c_char;
                let mut pStmt_4: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                let mut zKey: *const libc::c_char = azArg[2 as libc::c_int as usize];
                let mut zValue: *const libc::c_char = azArg[3 as libc::c_int as usize];
                bind_table_init(p);
                zSql_2 = sqlite3_mprintf(
                    b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%s);\x00" as *const u8
                        as *const libc::c_char,
                    zKey,
                    zValue,
                );
                if zSql_2.is_null() {
                    shell_out_of_memory();
                }
                pStmt_4 = 0 as *mut sqlite3_stmt;
                rx_0 = sqlite3_prepare_v2(
                    (*p).db,
                    zSql_2,
                    -(1 as libc::c_int),
                    &mut pStmt_4,
                    0 as *mut *const libc::c_char,
                );
                sqlite3_free(zSql_2 as *mut libc::c_void);
                if rx_0 != 0 as libc::c_int {
                    sqlite3_finalize(pStmt_4);
                    pStmt_4 = 0 as *mut sqlite3_stmt;
                    zSql_2 = sqlite3_mprintf(
                        b"REPLACE INTO temp.sqlite_parameters(key,value)VALUES(%Q,%Q);\x00"
                            as *const u8 as *const libc::c_char,
                        zKey,
                        zValue,
                    );
                    if zSql_2.is_null() {
                        shell_out_of_memory();
                    }
                    rx_0 = sqlite3_prepare_v2(
                        (*p).db,
                        zSql_2,
                        -(1 as libc::c_int),
                        &mut pStmt_4,
                        0 as *mut *const libc::c_char,
                    );
                    sqlite3_free(zSql_2 as *mut libc::c_void);
                    if rx_0 != 0 as libc::c_int {
                        fprintf(
                            (*p).out,
                            b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                            sqlite3_errmsg((*p).db),
                        );
                        sqlite3_finalize(pStmt_4);
                        pStmt_4 = 0 as *mut sqlite3_stmt;
                        rc = 1 as libc::c_int
                    }
                }
                sqlite3_step(pStmt_4);
                sqlite3_finalize(pStmt_4);
                current_block = 4767945957387570333;
            } else if nArg == 3 as libc::c_int
                && strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"unset\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
            {
                let mut zSql_3: *mut libc::c_char = sqlite3_mprintf(
                    b"DELETE FROM temp.sqlite_parameters WHERE key=%Q\x00" as *const u8
                        as *const libc::c_char,
                    azArg[2 as libc::c_int as usize],
                );
                if zSql_3.is_null() {
                    shell_out_of_memory();
                }
                sqlite3_exec(
                    (*p).db,
                    zSql_3,
                    None,
                    0 as *mut libc::c_void,
                    0 as *mut *mut libc::c_char,
                );
                sqlite3_free(zSql_3 as *mut libc::c_void);
                current_block = 4767945957387570333;
            } else {
                current_block = 5711410892010072419;
            }
            match current_block {
                4767945957387570333 => {}
                _ =>
                /* .parameter clear
                 ** Clear all bind parameters by dropping the TEMP table that holds them.
                 */
                /* .parameter list
                 ** List all bind parameters.
                 */
                /* .parameter init
                 ** Make sure the TEMP table used to hold bind parameters exists.
                 ** Create it if necessary.
                 */
                /* .parameter set NAME VALUE
                 ** Set or reset a bind parameter.  NAME should be the full parameter
                 ** name exactly as it appears in the query.  (ex: $abc, @def).  The
                 ** VALUE can be in either SQL literal notation, or if not it will be
                 ** understood to be a text string.
                 */
                /* .parameter unset NAME
                 ** Remove the NAME binding from the parameter binding table, if it
                 ** exists.
                 */
                /* If no command name matches, show a syntax error */
                {
                    showHelp(
                        (*p).out,
                        b"parameter\x00" as *const u8 as *const libc::c_char,
                    );
                }
            }
        } else if c == 'p' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"print\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut i_9: libc::c_int = 0;
            i_9 = 1 as libc::c_int;
            while i_9 < nArg {
                if i_9 > 1 as libc::c_int {
                    fprintf((*p).out, b" \x00" as *const u8 as *const libc::c_char);
                }
                fprintf(
                    (*p).out,
                    b"%s\x00" as *const u8 as *const libc::c_char,
                    azArg[i_9 as usize],
                );
                i_9 += 1
            }
            fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
        } else if c == 'p' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"progress\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut i_10: libc::c_int = 0;
            let mut nn: libc::c_int = 0 as libc::c_int;
            (*p).flgProgress = 0 as libc::c_int as libc::c_uint;
            (*p).mxProgress = 0 as libc::c_int as libc::c_uint;
            (*p).nProgress = 0 as libc::c_int as libc::c_uint;
            i_10 = 1 as libc::c_int;
            loop {
                if !(i_10 < nArg) {
                    current_block = 2744597729945660966;
                    break;
                }
                let mut z_7: *const libc::c_char = azArg[i_10 as usize];
                if *z_7.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_7 = z_7.offset(1);
                    if *z_7.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                        z_7 = z_7.offset(1)
                    }
                    if strcmp(z_7, b"quiet\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                        || strcmp(z_7, b"q\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                    {
                        (*p).flgProgress |= 0x1 as libc::c_int as libc::c_uint
                    } else if strcmp(z_7, b"reset\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        (*p).flgProgress |= 0x2 as libc::c_int as libc::c_uint
                    } else if strcmp(z_7, b"once\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        (*p).flgProgress |= 0x4 as libc::c_int as libc::c_uint
                    } else if strcmp(z_7, b"limit\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        if i_10 + 1 as libc::c_int >= nArg {
                            fprintf(
                                stderr,
                                b"Error: missing argument on --limit\n\x00" as *const u8
                                    as *const libc::c_char,
                            );
                            rc = 1 as libc::c_int;
                            current_block = 4767945957387570333;
                            break;
                        } else {
                            i_10 += 1;
                            (*p).mxProgress =
                                integerValue(azArg[i_10 as usize]) as libc::c_int as libc::c_uint
                        }
                    } else {
                        fprintf(
                            stderr,
                            b"Error: unknown option: \"%s\"\n\x00" as *const u8
                                as *const libc::c_char,
                            azArg[i_10 as usize],
                        );
                        rc = 1 as libc::c_int;
                        current_block = 4767945957387570333;
                        break;
                    }
                } else {
                    nn = integerValue(z_7) as libc::c_int
                }
                i_10 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    open_db(p, 0 as libc::c_int);
                    sqlite3_progress_handler(
                        (*p).db,
                        nn,
                        Some(
                            progress_handler
                                as unsafe extern "C" fn(_: *mut libc::c_void) -> libc::c_int,
                        ),
                        p as *mut libc::c_void,
                    );
                }
            }
        } else if c == 'p' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"prompt\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg >= 2 as libc::c_int {
                strncpy(
                    mainPrompt.as_mut_ptr(),
                    azArg[1 as libc::c_int as usize],
                    ((::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int) as libc::c_ulong,
                );
            }
            if nArg >= 3 as libc::c_int {
                strncpy(
                    continuePrompt.as_mut_ptr(),
                    azArg[2 as libc::c_int as usize],
                    ((::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int) as libc::c_ulong,
                );
            }
        } else if c == 'q' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"quit\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            rc = 2 as libc::c_int
        } else if c == 'r' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"read\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut inSaved: *mut FILE = (*p).in_0;
            let mut savedLineno: libc::c_int = (*p).lineno;
            failIfSafeMode(
                p,
                b"cannot run .read in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg != 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .read FILE\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                if *azArg[1 as libc::c_int as usize].offset(0 as libc::c_int as isize)
                    as libc::c_int
                    == '|' as i32
                {
                    (*p).in_0 = popen(
                        azArg[1 as libc::c_int as usize].offset(1 as libc::c_int as isize),
                        b"r\x00" as *const u8 as *const libc::c_char,
                    );
                    if (*p).in_0.is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int
                    } else {
                        rc = process_input(p);
                        pclose((*p).in_0);
                    }
                } else {
                    (*p).in_0 = openChrSource(azArg[1 as libc::c_int as usize]);
                    if (*p).in_0.is_null() {
                        fprintf(
                            stderr,
                            b"Error: cannot open \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                            azArg[1 as libc::c_int as usize],
                        );
                        rc = 1 as libc::c_int
                    } else {
                        rc = process_input(p);
                        fclose((*p).in_0);
                    }
                }
                (*p).in_0 = inSaved;
                (*p).lineno = savedLineno
            }
        } else if c == 'r' as i32
            && n >= 3 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"restore\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zSrcFile: *const libc::c_char = 0 as *const libc::c_char;
            let mut zDb_0: *const libc::c_char = 0 as *const libc::c_char;
            let mut pSrc: *mut sqlite3 = 0 as *mut sqlite3;
            let mut pBackup_0: *mut sqlite3_backup = 0 as *mut sqlite3_backup;
            let mut nTimeout: libc::c_int = 0 as libc::c_int;
            failIfSafeMode(
                p,
                b"cannot run .restore in safe mode\x00" as *const u8 as *const libc::c_char,
            );
            if nArg == 2 as libc::c_int {
                zSrcFile = azArg[1 as libc::c_int as usize];
                zDb_0 = b"main\x00" as *const u8 as *const libc::c_char;
                current_block = 17079308100635269198;
            } else if nArg == 3 as libc::c_int {
                zSrcFile = azArg[2 as libc::c_int as usize];
                zDb_0 = azArg[1 as libc::c_int as usize];
                current_block = 17079308100635269198;
            } else {
                fprintf(
                    stderr,
                    b"Usage: .restore ?DB? FILE\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                current_block = 4767945957387570333;
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    rc = sqlite3_open(zSrcFile, &mut pSrc);
                    if rc != 0 as libc::c_int {
                        fprintf(
                            stderr,
                            b"Error: cannot open \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                            zSrcFile,
                        );
                        close_db(pSrc);
                        return 1 as libc::c_int;
                    } else {
                        open_db(p, 0 as libc::c_int);
                        pBackup_0 = sqlite3_backup_init(
                            (*p).db,
                            zDb_0,
                            pSrc,
                            b"main\x00" as *const u8 as *const libc::c_char,
                        );
                        if pBackup_0.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                sqlite3_errmsg((*p).db),
                            );
                            close_db(pSrc);
                            return 1 as libc::c_int;
                        } else {
                            loop {
                                rc = sqlite3_backup_step(pBackup_0, 100 as libc::c_int);
                                if !(rc == 0 as libc::c_int || rc == 5 as libc::c_int) {
                                    break;
                                }
                                if !(rc == 5 as libc::c_int) {
                                    continue;
                                }
                                let fresh95 = nTimeout;
                                nTimeout = nTimeout + 1;
                                if fresh95 >= 3 as libc::c_int {
                                    break;
                                }
                                sqlite3_sleep(100 as libc::c_int);
                            }
                            sqlite3_backup_finish(pBackup_0);
                            if rc == 101 as libc::c_int {
                                rc = 0 as libc::c_int
                            } else if rc == 5 as libc::c_int || rc == 6 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: source database is busy\n\x00" as *const u8
                                        as *const libc::c_char,
                                );
                                rc = 1 as libc::c_int
                            } else {
                                fprintf(
                                    stderr,
                                    b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                    sqlite3_errmsg((*p).db),
                                );
                                rc = 1 as libc::c_int
                            }
                            close_db(pSrc);
                        }
                    }
                }
            }
        } else if c == 's' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"scanstats\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                (*p).scanstatsOn = booleanValue(azArg[1 as libc::c_int as usize]) as u8_0;
                fprintf(
                    stderr,
                    b"Warning: .scanstats not available in this build.\n\x00" as *const u8
                        as *const libc::c_char,
                );
            } else {
                fprintf(
                    stderr,
                    b"Usage: .scanstats on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 's' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"schema\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut sSelect: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            let mut data_0: ShellState = ShellState {
                db: 0 as *mut sqlite3,
                autoExplain: 0,
                autoEQP: 0,
                autoEQPtest: 0,
                autoEQPtrace: 0,
                scanstatsOn: 0,
                openMode: 0,
                doXdgOpen: 0,
                nEqpLevel: 0,
                eTraceType: 0,
                bSafeMode: 0,
                bSafeModePersist: 0,
                statsOn: 0,
                mEqpLines: 0,
                outCount: 0,
                cnt: 0,
                lineno: 0,
                openFlags: 0,
                in_0: 0 as *mut FILE,
                out: 0 as *mut FILE,
                traceOut: 0 as *mut FILE,
                nErr: 0,
                mode: 0,
                modePrior: 0,
                cMode: 0,
                normalMode: 0,
                writableSchema: 0,
                showHeader: 0,
                nCheck: 0,
                nProgress: 0,
                mxProgress: 0,
                flgProgress: 0,
                shellFlgs: 0,
                priorShFlgs: 0,
                szMax: 0,
                zDestTable: 0 as *mut libc::c_char,
                zTempFile: 0 as *mut libc::c_char,
                zTestcase: [0; 30],
                colSeparator: [0; 20],
                rowSeparator: [0; 20],
                colSepPrior: [0; 20],
                rowSepPrior: [0; 20],
                colWidth: 0 as *mut libc::c_int,
                actualWidth: 0 as *mut libc::c_int,
                nWidth: 0,
                nullValue: [0; 20],
                outfile: [0; 4096],
                pStmt: 0 as *mut sqlite3_stmt,
                pLog: 0 as *mut FILE,
                aAuxDb: [AuxDb {
                    db: 0 as *mut sqlite3,
                    zDbFilename: 0 as *const libc::c_char,
                    zFreeOnClose: 0 as *mut libc::c_char,
                }; 5],
                pAuxDb: 0 as *mut AuxDb,
                aiIndent: 0 as *mut libc::c_int,
                nIndent: 0,
                iIndent: 0,
                zNonce: 0 as *mut libc::c_char,
                sGraph: EQPGraph {
                    pRow: 0 as *mut EQPGraphRow,
                    pLast: 0 as *mut EQPGraphRow,
                    zPrefix: [0; 100],
                },
                expert: ExpertInfo {
                    pExpert: 0 as *mut sqlite3expert,
                    bVerbose: 0,
                },
            };
            let mut zErrMsg_0: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zDiv: *const libc::c_char = b"(\x00" as *const u8 as *const libc::c_char;
            let mut zName: *const libc::c_char = 0 as *const libc::c_char;
            let mut iSchema: libc::c_int = 0 as libc::c_int;
            let mut bDebug: libc::c_int = 0 as libc::c_int;
            let mut bNoSystemTabs: libc::c_int = 0 as libc::c_int;
            let mut ii_0: libc::c_int = 0;
            open_db(p, 0 as libc::c_int);
            memcpy(
                &mut data_0 as *mut ShellState as *mut libc::c_void,
                p as *const libc::c_void,
                ::std::mem::size_of::<ShellState>() as libc::c_ulong,
            );
            data_0.showHeader = 0 as libc::c_int;
            data_0.mode = 3 as libc::c_int;
            data_0.cMode = data_0.mode;
            initText(&mut sSelect);
            ii_0 = 1 as libc::c_int;
            loop {
                if !(ii_0 < nArg) {
                    current_block = 2521877785192433750;
                    break;
                }
                if optionMatch(
                    azArg[ii_0 as usize],
                    b"indent\x00" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    data_0.mode = 11 as libc::c_int;
                    data_0.cMode = data_0.mode
                } else if optionMatch(
                    azArg[ii_0 as usize],
                    b"debug\x00" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    bDebug = 1 as libc::c_int
                } else if optionMatch(
                    azArg[ii_0 as usize],
                    b"nosys\x00" as *const u8 as *const libc::c_char,
                ) != 0
                {
                    bNoSystemTabs = 1 as libc::c_int
                } else if *azArg[ii_0 as usize].offset(0 as libc::c_int as isize) as libc::c_int
                    == '-' as i32
                {
                    fprintf(
                        stderr,
                        b"Unknown option: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                        azArg[ii_0 as usize],
                    );
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                } else if zName.is_null() {
                    zName = azArg[ii_0 as usize]
                } else {
                    fprintf(
                        stderr,
                        b"Usage: .schema ?--indent? ?--nosys? ?LIKE-PATTERN?\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                }
                ii_0 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if !zName.is_null() {
                        let mut isSchema: libc::c_int = (sqlite3_strlike(
                            zName,
                            b"sqlite_master\x00" as *const u8 as *const libc::c_char,
                            '\\' as i32 as libc::c_uint,
                        ) == 0 as libc::c_int
                            || sqlite3_strlike(
                                zName,
                                b"sqlite_schema\x00" as *const u8 as *const libc::c_char,
                                '\\' as i32 as libc::c_uint,
                            ) == 0 as libc::c_int
                            || sqlite3_strlike(
                                zName,
                                b"sqlite_temp_master\x00" as *const u8 as *const libc::c_char,
                                '\\' as i32 as libc::c_uint,
                            ) == 0 as libc::c_int
                            || sqlite3_strlike(
                                zName,
                                b"sqlite_temp_schema\x00" as *const u8 as *const libc::c_char,
                                '\\' as i32 as libc::c_uint,
                            ) == 0 as libc::c_int)
                            as libc::c_int;
                        if isSchema != 0 {
                            let mut new_argv: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];
                            let mut new_colv: [*mut libc::c_char; 2] = [0 as *mut libc::c_char; 2];
                            new_argv[0 as libc::c_int as usize] =
                                sqlite3_mprintf(b"CREATE TABLE %s (\n  type text,\n  name text,\n  tbl_name text,\n  rootpage integer,\n  sql text\n)\x00"
                                                    as *const u8 as
                                                    *const libc::c_char,
                                                zName);
                            new_argv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                            new_colv[0 as libc::c_int as usize] =
                                b"sql\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
                            new_colv[1 as libc::c_int as usize] = 0 as *mut libc::c_char;
                            callback(
                                &mut data_0 as *mut ShellState as *mut libc::c_void,
                                1 as libc::c_int,
                                new_argv.as_mut_ptr(),
                                new_colv.as_mut_ptr(),
                            );
                            sqlite3_free(new_argv[0 as libc::c_int as usize] as *mut libc::c_void);
                        }
                    }
                    if !zDiv.is_null() {
                        let mut pStmt_5: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
                        rc = sqlite3_prepare_v2(
                            (*p).db,
                            b"SELECT name FROM pragma_database_list\x00" as *const u8
                                as *const libc::c_char,
                            -(1 as libc::c_int),
                            &mut pStmt_5,
                            0 as *mut *const libc::c_char,
                        );
                        if rc != 0 {
                            fprintf(
                                stderr,
                                b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                sqlite3_errmsg((*p).db),
                            );
                            sqlite3_finalize(pStmt_5);
                            rc = 1 as libc::c_int;
                            current_block = 4767945957387570333;
                        } else {
                            appendText(
                                &mut sSelect,
                                b"SELECT sql FROM\x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            iSchema = 0 as libc::c_int;
                            while sqlite3_step(pStmt_5) == 100 as libc::c_int {
                                let mut zDb_1: *const libc::c_char =
                                    sqlite3_column_text(pStmt_5, 0 as libc::c_int)
                                        as *const libc::c_char;
                                let mut zScNum: [libc::c_char; 30] = [0; 30];
                                iSchema += 1;
                                sqlite3_snprintf(
                                    ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong
                                        as libc::c_int,
                                    zScNum.as_mut_ptr(),
                                    b"%d\x00" as *const u8 as *const libc::c_char,
                                    iSchema,
                                );
                                appendText(&mut sSelect, zDiv, 0 as libc::c_int as libc::c_char);
                                zDiv = b" UNION ALL \x00" as *const u8 as *const libc::c_char;
                                appendText(
                                    &mut sSelect,
                                    b"SELECT shell_add_schema(sql,\x00" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                                if sqlite3_stricmp(
                                    zDb_1,
                                    b"main\x00" as *const u8 as *const libc::c_char,
                                ) != 0 as libc::c_int
                                {
                                    appendText(&mut sSelect, zDb_1, '\'' as i32 as libc::c_char);
                                } else {
                                    appendText(
                                        &mut sSelect,
                                        b"NULL\x00" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int as libc::c_char,
                                    );
                                }
                                appendText(
                                    &mut sSelect,
                                    b",name) AS sql, type, tbl_name, name, rowid,\x00" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                                appendText(
                                    &mut sSelect,
                                    zScNum.as_mut_ptr(),
                                    0 as libc::c_int as libc::c_char,
                                );
                                appendText(
                                    &mut sSelect,
                                    b" AS snum, \x00" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                                appendText(&mut sSelect, zDb_1, '\'' as i32 as libc::c_char);
                                appendText(
                                    &mut sSelect,
                                    b" AS sname FROM \x00" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                                appendText(&mut sSelect, zDb_1, quoteChar(zDb_1));
                                appendText(
                                    &mut sSelect,
                                    b".sqlite_schema\x00" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            sqlite3_finalize(pStmt_5);
                            if !zName.is_null() {
                                appendText(&mut sSelect,
                                           b" UNION ALL SELECT shell_module_schema(name), \'table\', name, name, name, 9e+99, \'main\' FROM pragma_module_list\x00"
                                               as *const u8 as
                                               *const libc::c_char,
                                           0 as libc::c_int as libc::c_char);
                            }
                            appendText(
                                &mut sSelect,
                                b") WHERE \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            if !zName.is_null() {
                                let mut zQarg: *mut libc::c_char = sqlite3_mprintf(
                                    b"%Q\x00" as *const u8 as *const libc::c_char,
                                    zName,
                                );
                                let mut bGlob: libc::c_int = (!strchr(zName, '*' as i32).is_null()
                                    || !strchr(zName, '?' as i32).is_null()
                                    || !strchr(zName, '[' as i32).is_null())
                                    as libc::c_int;
                                if !strchr(zName, '.' as i32).is_null() {
                                    appendText(
                                        &mut sSelect,
                                        b"lower(printf(\'%s.%s\',sname,tbl_name))\x00" as *const u8
                                            as *const libc::c_char,
                                        0 as libc::c_int as libc::c_char,
                                    );
                                } else {
                                    appendText(
                                        &mut sSelect,
                                        b"lower(tbl_name)\x00" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int as libc::c_char,
                                    );
                                }
                                appendText(
                                    &mut sSelect,
                                    if bGlob != 0 {
                                        b" GLOB \x00" as *const u8 as *const libc::c_char
                                    } else {
                                        b" LIKE \x00" as *const u8 as *const libc::c_char
                                    },
                                    0 as libc::c_int as libc::c_char,
                                );
                                appendText(&mut sSelect, zQarg, 0 as libc::c_int as libc::c_char);
                                if bGlob == 0 {
                                    appendText(
                                        &mut sSelect,
                                        b" ESCAPE \'\\\' \x00" as *const u8 as *const libc::c_char,
                                        0 as libc::c_int as libc::c_char,
                                    );
                                }
                                appendText(
                                    &mut sSelect,
                                    b" AND \x00" as *const u8 as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                                sqlite3_free(zQarg as *mut libc::c_void);
                            }
                            if bNoSystemTabs != 0 {
                                appendText(
                                    &mut sSelect,
                                    b"name NOT LIKE \'sqlite_%%\' AND \x00" as *const u8
                                        as *const libc::c_char,
                                    0 as libc::c_int as libc::c_char,
                                );
                            }
                            appendText(
                                &mut sSelect,
                                b"sql IS NOT NULL ORDER BY snum, rowid\x00" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            if bDebug != 0 {
                                fprintf(
                                    (*p).out,
                                    b"SQL: %s;\n\x00" as *const u8 as *const libc::c_char,
                                    sSelect.z,
                                );
                            } else {
                                rc = sqlite3_exec(
                                    (*p).db,
                                    sSelect.z,
                                    Some(
                                        callback
                                            as unsafe extern "C" fn(
                                                _: *mut libc::c_void,
                                                _: libc::c_int,
                                                _: *mut *mut libc::c_char,
                                                _: *mut *mut libc::c_char,
                                            )
                                                -> libc::c_int,
                                    ),
                                    &mut data_0 as *mut ShellState as *mut libc::c_void,
                                    &mut zErrMsg_0,
                                )
                            }
                            freeText(&mut sSelect);
                            current_block = 259555387045937058;
                        }
                    } else {
                        current_block = 259555387045937058;
                    }
                    match current_block {
                        4767945957387570333 => {}
                        _ => {
                            if !zErrMsg_0.is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                    zErrMsg_0,
                                );
                                sqlite3_free(zErrMsg_0 as *mut libc::c_void);
                                rc = 1 as libc::c_int
                            } else if rc != 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: querying schema information\n\x00" as *const u8
                                        as *const libc::c_char,
                                );
                                rc = 1 as libc::c_int
                            } else {
                                rc = 0 as libc::c_int
                            }
                        }
                    }
                }
            }
        } else if c == 's' as i32
            && n == 11 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"selecttrace\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut x_3: libc::c_uint = if nArg >= 2 as libc::c_int {
                integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
            } else {
                0xffffffff as libc::c_uint
            };
            sqlite3_test_control(
                31 as libc::c_int,
                1 as libc::c_int,
                &mut x_3 as *mut libc::c_uint,
            );
        } else if c == 's' as i32
            && n >= 4 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"selftest\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            /* SQLITE_OMIT_PROGRESS_CALLBACK */
            let mut bIsInit: libc::c_int = 0 as libc::c_int; /* True to initialize the SELFTEST table */
            let mut bVerbose: libc::c_int = 0 as libc::c_int; /* Verbose output */
            let mut bSelftestExists: libc::c_int = 0; /* True if SELFTEST already exists */
            let mut i_11: libc::c_int = 0; /* Loop counters */
            let mut k: libc::c_int = 0; /* Number of tests runs */
            let mut nTest: libc::c_int = 0 as libc::c_int; /* Number of errors seen */
            let mut nErr: libc::c_int = 0 as libc::c_int; /* Answer for a query */
            let mut str: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            }; /* Query against the SELFTEST table */
            let mut pStmt_6: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt; /* End loop over k */
            open_db(p, 0 as libc::c_int); /* End loop over rows of content from SELFTEST */
            i_11 = 1 as libc::c_int; /* Which table to checksum. 0 means everything */
            loop {
                if !(i_11 < nArg) {
                    current_block = 153194751263032023; /* Loop counter */
                    break; /* Also hash the schema */
                } /* Hash each table separately */
                let mut z_8: *const libc::c_char = azArg[i_11 as usize]; /* Hash algorithm to use */
                if *z_8.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    && *z_8.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32
                {
                    z_8 = z_8.offset(1)
                } /* Only show the query that would have run */
                if strcmp(z_8, b"-init\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
                {
                    bIsInit = 1 as libc::c_int
                } else if strcmp(z_8, b"-v\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bVerbose += 1
                } else {
                    fprintf(
                        stderr,
                        b"Unknown option \"%s\" on \"%s\"\n\x00" as *const u8
                            as *const libc::c_char,
                        azArg[i_11 as usize],
                        azArg[0 as libc::c_int as usize],
                    ); /* For querying tables names */
                    fprintf(
                        stderr,
                        b"Should be one of: --init -v\n\x00" as *const u8 as *const libc::c_char,
                    ); /* SQL to be run */
                    rc = 1 as libc::c_int; /* Separator */
                    current_block = 4767945957387570333; /* Complete SQL for the query to run the hash */
                    break; /* Set of queries used to read all content */
                }
                i_11 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if sqlite3_table_column_metadata(
                        (*p).db,
                        b"main\x00" as *const u8 as *const libc::c_char,
                        b"selftest\x00" as *const u8 as *const libc::c_char,
                        0 as *const libc::c_char,
                        0 as *mut *const libc::c_char,
                        0 as *mut *const libc::c_char,
                        0 as *mut libc::c_int,
                        0 as *mut libc::c_int,
                        0 as *mut libc::c_int,
                    ) != 0 as libc::c_int
                    {
                        bSelftestExists = 0 as libc::c_int
                    } else {
                        bSelftestExists = 1 as libc::c_int
                    }
                    if bIsInit != 0 {
                        createSelftestTable(p);
                        bSelftestExists = 1 as libc::c_int
                    }
                    initText(&mut str);
                    appendText(
                        &mut str,
                        b"x\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    k = bSelftestExists;
                    loop {
                        if !(k >= 0 as libc::c_int) {
                            current_block = 14704594269423186288;
                            break;
                        }
                        if k == 1 as libc::c_int {
                            rc = sqlite3_prepare_v2(
                                (*p).db,
                                b"SELECT tno,op,cmd,ans FROM selftest ORDER BY tno\x00" as *const u8
                                    as *const libc::c_char,
                                -(1 as libc::c_int),
                                &mut pStmt_6,
                                0 as *mut *const libc::c_char,
                            )
                        } else {
                            rc =
                                sqlite3_prepare_v2((*p).db,
                                                   b"VALUES(0,\'memo\',\'Missing SELFTEST table - default checks only\',\'\'),      (1,\'run\',\'PRAGMA integrity_check\',\'ok\')\x00"
                                                       as *const u8 as
                                                       *const libc::c_char,
                                                   -(1 as libc::c_int),
                                                   &mut pStmt_6,
                                                   0 as
                                                       *mut *const libc::c_char)
                        }
                        if rc != 0 {
                            fprintf(
                                stderr,
                                b"Error querying the selftest table\n\x00" as *const u8
                                    as *const libc::c_char,
                            );
                            rc = 1 as libc::c_int;
                            sqlite3_finalize(pStmt_6);
                            current_block = 4767945957387570333;
                            break;
                        } else {
                            i_11 = 1 as libc::c_int;
                            while sqlite3_step(pStmt_6) == 100 as libc::c_int {
                                let mut tno: libc::c_int =
                                    sqlite3_column_int(pStmt_6, 0 as libc::c_int);
                                let mut zOp: *const libc::c_char =
                                    sqlite3_column_text(pStmt_6, 1 as libc::c_int)
                                        as *const libc::c_char;
                                let mut zSql_4: *const libc::c_char =
                                    sqlite3_column_text(pStmt_6, 2 as libc::c_int)
                                        as *const libc::c_char;
                                let mut zAns: *const libc::c_char =
                                    sqlite3_column_text(pStmt_6, 3 as libc::c_int)
                                        as *const libc::c_char;
                                k = 0 as libc::c_int;
                                if bVerbose > 0 as libc::c_int {
                                    let mut zQuote: *mut libc::c_char = sqlite3_mprintf(
                                        b"%q\x00" as *const u8 as *const libc::c_char,
                                        zSql_4,
                                    );
                                    printf(
                                        b"%d: %s %s\n\x00" as *const u8 as *const libc::c_char,
                                        tno,
                                        zOp,
                                        zSql_4,
                                    );
                                    sqlite3_free(zQuote as *mut libc::c_void);
                                }
                                if strcmp(zOp, b"memo\x00" as *const u8 as *const libc::c_char)
                                    == 0 as libc::c_int
                                {
                                    fprintf(
                                        (*p).out,
                                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                                        zSql_4,
                                    );
                                } else if strcmp(
                                    zOp,
                                    b"run\x00" as *const u8 as *const libc::c_char,
                                ) == 0 as libc::c_int
                                {
                                    let mut zErrMsg_1: *mut libc::c_char = 0 as *mut libc::c_char;
                                    str.n = 0 as libc::c_int;
                                    *str.z.offset(0 as libc::c_int as isize) =
                                        0 as libc::c_int as libc::c_char;
                                    rc = sqlite3_exec(
                                        (*p).db,
                                        zSql_4,
                                        Some(
                                            captureOutputCallback
                                                as unsafe extern "C" fn(
                                                    _: *mut libc::c_void,
                                                    _: libc::c_int,
                                                    _: *mut *mut libc::c_char,
                                                    _: *mut *mut libc::c_char,
                                                )
                                                    -> libc::c_int,
                                        ),
                                        &mut str as *mut ShellText as *mut libc::c_void,
                                        &mut zErrMsg_1,
                                    );
                                    nTest += 1;
                                    if bVerbose != 0 {
                                        fprintf(
                                            (*p).out,
                                            b"Result: %s\n\x00" as *const u8 as *const libc::c_char,
                                            str.z,
                                        );
                                    }
                                    if rc != 0 || !zErrMsg_1.is_null() {
                                        nErr += 1;
                                        rc = 1 as libc::c_int;
                                        fprintf(
                                            (*p).out,
                                            b"%d: error-code-%d: %s\n\x00" as *const u8
                                                as *const libc::c_char,
                                            tno,
                                            rc,
                                            zErrMsg_1,
                                        );
                                        sqlite3_free(zErrMsg_1 as *mut libc::c_void);
                                    } else if strcmp(zAns, str.z) != 0 as libc::c_int {
                                        nErr += 1;
                                        rc = 1 as libc::c_int;
                                        fprintf(
                                            (*p).out,
                                            b"%d: Expected: [%s]\n\x00" as *const u8
                                                as *const libc::c_char,
                                            tno,
                                            zAns,
                                        );
                                        fprintf(
                                            (*p).out,
                                            b"%d:      Got: [%s]\n\x00" as *const u8
                                                as *const libc::c_char,
                                            tno,
                                            str.z,
                                        );
                                    }
                                } else {
                                    fprintf(
                                        stderr,
                                        b"Unknown operation \"%s\" on selftest line %d\n\x00"
                                            as *const u8
                                            as *const libc::c_char,
                                        zOp,
                                        tno,
                                    );
                                    rc = 1 as libc::c_int;
                                    break;
                                }
                                i_11 += 1
                            }
                            sqlite3_finalize(pStmt_6);
                            k -= 1
                        }
                    }
                    match current_block {
                        4767945957387570333 => {}
                        _ => {
                            freeText(&mut str);
                            fprintf(
                                (*p).out,
                                b"%d errors out of %d tests\n\x00" as *const u8
                                    as *const libc::c_char,
                                nErr,
                                nTest,
                            );
                        }
                    }
                }
            }
        } else if c == 's' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"separator\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg < 2 as libc::c_int || nArg > 3 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .separator COL ?ROW?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
            if nArg >= 2 as libc::c_int {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).colSeparator.as_mut_ptr(),
                    b"%.*s\x00" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int,
                    azArg[1 as libc::c_int as usize],
                );
            }
            if nArg >= 3 as libc::c_int {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                    (*p).rowSeparator.as_mut_ptr(),
                    b"%.*s\x00" as *const u8 as *const libc::c_char,
                    (::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<libc::c_char>() as libc::c_ulong)
                        as libc::c_int
                        - 1 as libc::c_int,
                    azArg[2 as libc::c_int as usize],
                );
            }
        } else if c == 's' as i32
            && n >= 4 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"sha3sum\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zLike_0: *const libc::c_char = 0 as *const libc::c_char;
            let mut i_12: libc::c_int = 0;
            let mut bSchema: libc::c_int = 0 as libc::c_int;
            let mut bSeparate: libc::c_int = 0 as libc::c_int;
            let mut iSize: libc::c_int = 224 as libc::c_int;
            let mut bDebug_0: libc::c_int = 0 as libc::c_int;
            let mut pStmt_7: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut zSql_5: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zSep_0: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut sSql: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            let mut sQuery: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            open_db(p, 0 as libc::c_int);
            i_12 = 1 as libc::c_int;
            loop {
                if !(i_12 < nArg) {
                    current_block = 3816638281060850914;
                    break;
                }
                let mut z_9: *const libc::c_char = azArg[i_12 as usize];
                if *z_9.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_9 = z_9.offset(1);
                    if *z_9.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                        z_9 = z_9.offset(1)
                    }
                    if strcmp(z_9, b"schema\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        bSchema = 1 as libc::c_int
                    } else if strcmp(z_9, b"sha3-224\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                        || strcmp(z_9, b"sha3-256\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                        || strcmp(z_9, b"sha3-384\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                        || strcmp(z_9, b"sha3-512\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                    {
                        iSize = atoi(&*z_9.offset(5 as libc::c_int as isize))
                    } else if strcmp(z_9, b"debug\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        bDebug_0 = 1 as libc::c_int
                    } else {
                        fprintf(
                            stderr,
                            b"Unknown option \"%s\" on \"%s\"\n\x00" as *const u8
                                as *const libc::c_char,
                            azArg[i_12 as usize],
                            azArg[0 as libc::c_int as usize],
                        );
                        showHelp((*p).out, azArg[0 as libc::c_int as usize]);
                        rc = 1 as libc::c_int;
                        current_block = 4767945957387570333;
                        break;
                    }
                } else if !zLike_0.is_null() {
                    fprintf(
                        stderr,
                        b"Usage: .sha3sum ?OPTIONS? ?LIKE-PATTERN?\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    rc = 1 as libc::c_int;
                    current_block = 4767945957387570333;
                    break;
                } else {
                    zLike_0 = z_9;
                    bSeparate = 1 as libc::c_int;
                    if sqlite3_strlike(
                        b"sqlite\\_%\x00" as *const u8 as *const libc::c_char,
                        zLike_0,
                        '\\' as i32 as libc::c_uint,
                    ) == 0 as libc::c_int
                    {
                        bSchema = 1 as libc::c_int
                    }
                }
                i_12 += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if bSchema != 0 {
                        zSql_5 =
                            b"SELECT lower(name) FROM sqlite_schema WHERE type=\'table\' AND coalesce(rootpage,0)>1 UNION ALL SELECT \'sqlite_schema\' ORDER BY 1 collate nocase\x00"
                                as *const u8 as *const libc::c_char as
                                *mut libc::c_char
                    } else {
                        zSql_5 =
                            b"SELECT lower(name) FROM sqlite_schema WHERE type=\'table\' AND coalesce(rootpage,0)>1 AND name NOT LIKE \'sqlite_%\' ORDER BY 1 collate nocase\x00"
                                as *const u8 as *const libc::c_char as
                                *mut libc::c_char
                    }
                    sqlite3_prepare_v2(
                        (*p).db,
                        zSql_5,
                        -(1 as libc::c_int),
                        &mut pStmt_7,
                        0 as *mut *const libc::c_char,
                    );
                    initText(&mut sQuery);
                    initText(&mut sSql);
                    appendText(
                        &mut sSql,
                        b"WITH [sha3sum$query](a,b) AS(\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    zSep_0 =
                        b"VALUES(\x00" as *const u8 as *const libc::c_char as *mut libc::c_char;
                    while 100 as libc::c_int == sqlite3_step(pStmt_7) {
                        let mut zTab: *const libc::c_char =
                            sqlite3_column_text(pStmt_7, 0 as libc::c_int) as *const libc::c_char;
                        if !zLike_0.is_null()
                            && sqlite3_strlike(zLike_0, zTab, 0 as libc::c_int as libc::c_uint)
                                != 0 as libc::c_int
                        {
                            continue;
                        }
                        if strncmp(
                            zTab,
                            b"sqlite_\x00" as *const u8 as *const libc::c_char,
                            7 as libc::c_int as libc::c_ulong,
                        ) != 0 as libc::c_int
                        {
                            appendText(
                                &mut sQuery,
                                b"SELECT * FROM \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sQuery, zTab, '\"' as i32 as libc::c_char);
                            appendText(
                                &mut sQuery,
                                b" NOT INDEXED;\x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        } else if strcmp(
                            zTab,
                            b"sqlite_schema\x00" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            appendText(&mut sQuery,
                                       b"SELECT type,name,tbl_name,sql FROM sqlite_schema ORDER BY name;\x00"
                                           as *const u8 as
                                           *const libc::c_char,
                                       0 as libc::c_int as libc::c_char);
                        } else if strcmp(
                            zTab,
                            b"sqlite_sequence\x00" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            appendText(
                                &mut sQuery,
                                b"SELECT name,seq FROM sqlite_sequence ORDER BY name;\x00"
                                    as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        } else if strcmp(
                            zTab,
                            b"sqlite_stat1\x00" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            appendText(
                                &mut sQuery,
                                b"SELECT tbl,idx,stat FROM sqlite_stat1 ORDER BY tbl,idx;\x00"
                                    as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        } else if strcmp(
                            zTab,
                            b"sqlite_stat4\x00" as *const u8 as *const libc::c_char,
                        ) == 0 as libc::c_int
                        {
                            appendText(
                                &mut sQuery,
                                b"SELECT * FROM \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut sQuery, zTab, 0 as libc::c_int as libc::c_char);
                            appendText(
                                &mut sQuery,
                                b" ORDER BY tbl, idx, rowid;\n\x00" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(&mut sSql, zSep_0, 0 as libc::c_int as libc::c_char);
                        appendText(&mut sSql, sQuery.z, '\'' as i32 as libc::c_char);
                        sQuery.n = 0 as libc::c_int;
                        appendText(
                            &mut sSql,
                            b",\x00" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        appendText(&mut sSql, zTab, '\'' as i32 as libc::c_char);
                        zSep_0 = b"),(\x00" as *const u8 as *const libc::c_char as *mut libc::c_char
                    }
                    sqlite3_finalize(pStmt_7);
                    if bSeparate != 0 {
                        zSql_5 =
                            sqlite3_mprintf(b"%s)) SELECT lower(hex(sha3_query(a,%d))) AS hash, b AS label   FROM [sha3sum$query]\x00"
                                                as *const u8 as
                                                *const libc::c_char, sSql.z,
                                            iSize)
                    } else {
                        zSql_5 =
                            sqlite3_mprintf(b"%s)) SELECT lower(hex(sha3_query(group_concat(a,\'\'),%d))) AS hash   FROM [sha3sum$query]\x00"
                                                as *const u8 as
                                                *const libc::c_char, sSql.z,
                                            iSize)
                    }
                    freeText(&mut sQuery);
                    freeText(&mut sSql);
                    if bDebug_0 != 0 {
                        fprintf(
                            (*p).out,
                            b"%s\n\x00" as *const u8 as *const libc::c_char,
                            zSql_5,
                        );
                    } else {
                        shell_exec(p, zSql_5, 0 as *mut *mut libc::c_char);
                    }
                    sqlite3_free(zSql_5 as *mut libc::c_void);
                }
            }
        } else if c == 's' as i32
            && (strncmp(
                azArg[0 as libc::c_int as usize],
                b"shell\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
                || strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"system\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                ) == 0 as libc::c_int)
        {
            let mut zCmd_0: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut i_13: libc::c_int = 0;
            let mut x_4: libc::c_int = 0;
            failIfSafeMode(
                p,
                b"cannot run .%s in safe mode\x00" as *const u8 as *const libc::c_char,
                azArg[0 as libc::c_int as usize],
            );
            if nArg < 2 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .system COMMAND\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                zCmd_0 = sqlite3_mprintf(
                    if strchr(azArg[1 as libc::c_int as usize], ' ' as i32).is_null() {
                        b"%s\x00" as *const u8 as *const libc::c_char
                    } else {
                        b"\"%s\"\x00" as *const u8 as *const libc::c_char
                    },
                    azArg[1 as libc::c_int as usize],
                );
                i_13 = 2 as libc::c_int;
                while i_13 < nArg {
                    zCmd_0 = sqlite3_mprintf(
                        if strchr(azArg[i_13 as usize], ' ' as i32).is_null() {
                            b"%z %s\x00" as *const u8 as *const libc::c_char
                        } else {
                            b"%z \"%s\"\x00" as *const u8 as *const libc::c_char
                        },
                        zCmd_0,
                        azArg[i_13 as usize],
                    );
                    i_13 += 1
                }
                x_4 = system(zCmd_0);
                sqlite3_free(zCmd_0 as *mut libc::c_void);
                if x_4 != 0 {
                    fprintf(
                        stderr,
                        b"System command returns %d\n\x00" as *const u8 as *const libc::c_char,
                        x_4,
                    );
                }
            }
        } else if c == 's' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"show\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            static mut azBool: [*const libc::c_char; 4] = [
                b"off\x00" as *const u8 as *const libc::c_char,
                b"on\x00" as *const u8 as *const libc::c_char,
                b"trigger\x00" as *const u8 as *const libc::c_char,
                b"full\x00" as *const u8 as *const libc::c_char,
            ];
            let mut zOut: *const libc::c_char = 0 as *const libc::c_char;
            let mut i_14: libc::c_int = 0;
            if nArg != 1 as libc::c_int {
                fprintf(
                    stderr,
                    b"Usage: .show\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            } else {
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"echo\x00" as *const u8 as *const libc::c_char,
                    azBool[((*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint)
                        as libc::c_int as usize],
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"eqp\x00" as *const u8 as *const libc::c_char,
                    azBool[((*p).autoEQP as libc::c_int & 3 as libc::c_int) as usize],
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"explain\x00" as *const u8 as *const libc::c_char,
                    if (*p).mode == 9 as libc::c_int {
                        b"on\x00" as *const u8 as *const libc::c_char
                    } else if (*p).autoExplain as libc::c_int != 0 {
                        b"auto\x00" as *const u8 as *const libc::c_char
                    } else {
                        b"off\x00" as *const u8 as *const libc::c_char
                    },
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"headers\x00" as *const u8 as *const libc::c_char,
                    azBool[((*p).showHeader != 0 as libc::c_int) as libc::c_int as usize],
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"mode\x00" as *const u8 as *const libc::c_char,
                    modeDescr[(*p).mode as usize],
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: \x00" as *const u8 as *const libc::c_char,
                    b"nullvalue\x00" as *const u8 as *const libc::c_char,
                );
                output_c_string((*p).out, (*p).nullValue.as_mut_ptr());
                fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"output\x00" as *const u8 as *const libc::c_char,
                    if strlen30((*p).outfile.as_mut_ptr()) != 0 {
                        (*p).outfile.as_mut_ptr() as *const libc::c_char
                    } else {
                        b"stdout\x00" as *const u8 as *const libc::c_char
                    },
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: \x00" as *const u8 as *const libc::c_char,
                    b"colseparator\x00" as *const u8 as *const libc::c_char,
                );
                output_c_string((*p).out, (*p).colSeparator.as_mut_ptr());
                fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                fprintf(
                    (*p).out,
                    b"%12.12s: \x00" as *const u8 as *const libc::c_char,
                    b"rowseparator\x00" as *const u8 as *const libc::c_char,
                );
                output_c_string((*p).out, (*p).rowSeparator.as_mut_ptr());
                fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                match (*p).statsOn {
                    0 => zOut = b"off\x00" as *const u8 as *const libc::c_char,
                    2 => zOut = b"stmt\x00" as *const u8 as *const libc::c_char,
                    3 => zOut = b"vmstep\x00" as *const u8 as *const libc::c_char,
                    _ => zOut = b"on\x00" as *const u8 as *const libc::c_char,
                }
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"stats\x00" as *const u8 as *const libc::c_char,
                    zOut,
                );
                fprintf(
                    (*p).out,
                    b"%12.12s: \x00" as *const u8 as *const libc::c_char,
                    b"width\x00" as *const u8 as *const libc::c_char,
                );
                i_14 = 0 as libc::c_int;
                while i_14 < (*p).nWidth {
                    fprintf(
                        (*p).out,
                        b"%d \x00" as *const u8 as *const libc::c_char,
                        *(*p).colWidth.offset(i_14 as isize),
                    );
                    i_14 += 1
                }
                fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                fprintf(
                    (*p).out,
                    b"%12.12s: %s\n\x00" as *const u8 as *const libc::c_char,
                    b"filename\x00" as *const u8 as *const libc::c_char,
                    if !(*(*p).pAuxDb).zDbFilename.is_null() {
                        (*(*p).pAuxDb).zDbFilename
                    } else {
                        b"\x00" as *const u8 as *const libc::c_char
                    },
                );
            }
        } else if c == 's' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"stats\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                if strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"stmt\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).statsOn = 2 as libc::c_int as libc::c_uint
                } else if strcmp(
                    azArg[1 as libc::c_int as usize],
                    b"vmstep\x00" as *const u8 as *const libc::c_char,
                ) == 0 as libc::c_int
                {
                    (*p).statsOn = 3 as libc::c_int as libc::c_uint
                } else {
                    (*p).statsOn =
                        booleanValue(azArg[1 as libc::c_int as usize]) as u8_0 as libc::c_uint
                }
            } else if nArg == 1 as libc::c_int {
                display_stats((*p).db, p, 0 as libc::c_int);
            } else {
                fprintf(
                    stderr,
                    b"Usage: .stats ?on|off|stmt|vmstep?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 't' as i32
            && n > 1 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"tables\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
            || c == 'i' as i32
                && (strncmp(
                    azArg[0 as libc::c_int as usize],
                    b"indices\x00" as *const u8 as *const libc::c_char,
                    n as libc::c_ulong,
                ) == 0 as libc::c_int
                    || strncmp(
                        azArg[0 as libc::c_int as usize],
                        b"indexes\x00" as *const u8 as *const libc::c_char,
                        n as libc::c_ulong,
                    ) == 0 as libc::c_int)
        {
            let mut pStmt_8: *mut sqlite3_stmt = 0 as *mut sqlite3_stmt;
            let mut azResult: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
            let mut nRow: libc::c_int = 0;
            let mut nAlloc: libc::c_int = 0;
            let mut ii_1: libc::c_int = 0;
            let mut s: ShellText = ShellText {
                z: 0 as *mut libc::c_char,
                n: 0,
                nAlloc: 0,
            };
            initText(&mut s);
            open_db(p, 0 as libc::c_int);
            rc = sqlite3_prepare_v2(
                (*p).db,
                b"PRAGMA database_list\x00" as *const u8 as *const libc::c_char,
                -(1 as libc::c_int),
                &mut pStmt_8,
                0 as *mut *const libc::c_char,
            );
            if rc != 0 {
                sqlite3_finalize(pStmt_8);
                return shellDatabaseError((*p).db);
            } else if nArg > 2 as libc::c_int && c == 'i' as i32 {
                /* !defined(SQLITE_NOHAVE_SYSTEM) */
                /* It is an historical accident that the .indexes command shows an error
                 ** when called with the wrong number of arguments whereas the .tables
                 ** command does not. */
                fprintf(
                    stderr,
                    b"Usage: .indexes ?LIKE-PATTERN?\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int;
                sqlite3_finalize(pStmt_8);
            } else {
                ii_1 = 0 as libc::c_int;
                while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                    let mut zDbName: *const libc::c_char =
                        sqlite3_column_text(pStmt_8, 1 as libc::c_int) as *const libc::c_char;
                    if !zDbName.is_null() {
                        if !s.z.is_null()
                            && *s.z.offset(0 as libc::c_int as isize) as libc::c_int != 0
                        {
                            appendText(
                                &mut s,
                                b" UNION ALL \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        if sqlite3_stricmp(zDbName, b"main\x00" as *const u8 as *const libc::c_char)
                            == 0 as libc::c_int
                        {
                            appendText(
                                &mut s,
                                b"SELECT name FROM \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        } else {
                            appendText(
                                &mut s,
                                b"SELECT \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                            appendText(&mut s, zDbName, '\'' as i32 as libc::c_char);
                            appendText(
                                &mut s,
                                b"||\'.\'||name FROM \x00" as *const u8 as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                        appendText(&mut s, zDbName, '\"' as i32 as libc::c_char);
                        appendText(
                            &mut s,
                            b".sqlite_schema \x00" as *const u8 as *const libc::c_char,
                            0 as libc::c_int as libc::c_char,
                        );
                        if c == 't' as i32 {
                            appendText(&mut s,
                                       b" WHERE type IN (\'table\',\'view\')   AND name NOT LIKE \'sqlite_%\'   AND name LIKE ?1\x00"
                                           as *const u8 as
                                           *const libc::c_char,
                                       0 as libc::c_int as libc::c_char);
                        } else {
                            appendText(
                                &mut s,
                                b" WHERE type=\'index\'   AND tbl_name LIKE ?1\x00" as *const u8
                                    as *const libc::c_char,
                                0 as libc::c_int as libc::c_char,
                            );
                        }
                    }
                    ii_1 += 1
                }
                rc = sqlite3_finalize(pStmt_8);
                if rc == 0 as libc::c_int {
                    appendText(
                        &mut s,
                        b" ORDER BY 1\x00" as *const u8 as *const libc::c_char,
                        0 as libc::c_int as libc::c_char,
                    );
                    rc = sqlite3_prepare_v2(
                        (*p).db,
                        s.z,
                        -(1 as libc::c_int),
                        &mut pStmt_8,
                        0 as *mut *const libc::c_char,
                    )
                }
                freeText(&mut s);
                if rc != 0 {
                    return shellDatabaseError((*p).db);
                } else {
                    /* Run the SQL statement prepared by the above block. Store the results
                     ** as an array of nul-terminated strings in azResult[].  */
                    nAlloc = 0 as libc::c_int;
                    nRow = nAlloc;
                    azResult = 0 as *mut *mut libc::c_char;
                    if nArg > 1 as libc::c_int {
                        sqlite3_bind_text(
                            pStmt_8,
                            1 as libc::c_int,
                            azArg[1 as libc::c_int as usize],
                            -(1 as libc::c_int),
                            ::std::mem::transmute::<libc::intptr_t, sqlite3_destructor_type>(
                                -(1 as libc::c_int) as libc::intptr_t,
                            ),
                        );
                    } else {
                        sqlite3_bind_text(
                            pStmt_8,
                            1 as libc::c_int,
                            b"%\x00" as *const u8 as *const libc::c_char,
                            -(1 as libc::c_int),
                            None,
                        );
                    }
                    while sqlite3_step(pStmt_8) == 100 as libc::c_int {
                        if nRow >= nAlloc {
                            let mut azNew: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
                            let mut n2_2: libc::c_int =
                                nAlloc * 2 as libc::c_int + 10 as libc::c_int;
                            azNew = sqlite3_realloc64(
                                azResult as *mut libc::c_void,
                                (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                                    .wrapping_mul(n2_2 as libc::c_ulong)
                                    as sqlite3_uint64,
                            ) as *mut *mut libc::c_char;
                            if azNew.is_null() {
                                shell_out_of_memory();
                            }
                            nAlloc = n2_2;
                            azResult = azNew
                        }
                        let ref mut fresh96 = *azResult.offset(nRow as isize);
                        *fresh96 = sqlite3_mprintf(
                            b"%s\x00" as *const u8 as *const libc::c_char,
                            sqlite3_column_text(pStmt_8, 0 as libc::c_int),
                        );
                        if (*azResult.offset(nRow as isize)).is_null() {
                            shell_out_of_memory();
                        }
                        nRow += 1
                    }
                    if sqlite3_finalize(pStmt_8) != 0 as libc::c_int {
                        rc = shellDatabaseError((*p).db)
                    }
                    /* Pretty-print the contents of array azResult[] to the output */
                    if rc == 0 as libc::c_int && nRow > 0 as libc::c_int {
                        let mut len_0: libc::c_int = 0;
                        let mut maxlen: libc::c_int = 0 as libc::c_int;
                        let mut i_15: libc::c_int = 0;
                        let mut j_1: libc::c_int = 0;
                        let mut nPrintCol: libc::c_int = 0;
                        let mut nPrintRow: libc::c_int = 0;
                        i_15 = 0 as libc::c_int;
                        while i_15 < nRow {
                            len_0 = strlen30(*azResult.offset(i_15 as isize));
                            if len_0 > maxlen {
                                maxlen = len_0
                            }
                            i_15 += 1
                        }
                        nPrintCol = 80 as libc::c_int / (maxlen + 2 as libc::c_int);
                        if nPrintCol < 1 as libc::c_int {
                            nPrintCol = 1 as libc::c_int
                        }
                        nPrintRow = (nRow + nPrintCol - 1 as libc::c_int) / nPrintCol;
                        i_15 = 0 as libc::c_int;
                        while i_15 < nPrintRow {
                            j_1 = i_15;
                            while j_1 < nRow {
                                let mut zSp: *mut libc::c_char = if j_1 < nPrintRow {
                                    b"\x00" as *const u8 as *const libc::c_char
                                } else {
                                    b"  \x00" as *const u8 as *const libc::c_char
                                }
                                    as *mut libc::c_char;
                                fprintf(
                                    (*p).out,
                                    b"%s%-*s\x00" as *const u8 as *const libc::c_char,
                                    zSp,
                                    maxlen,
                                    if !(*azResult.offset(j_1 as isize)).is_null() {
                                        *azResult.offset(j_1 as isize) as *const libc::c_char
                                    } else {
                                        b"\x00" as *const u8 as *const libc::c_char
                                    },
                                );
                                j_1 += nPrintRow
                            }
                            fprintf((*p).out, b"\n\x00" as *const u8 as *const libc::c_char);
                            i_15 += 1
                        }
                    }
                    ii_1 = 0 as libc::c_int;
                    while ii_1 < nRow {
                        sqlite3_free(*azResult.offset(ii_1 as isize) as *mut libc::c_void);
                        ii_1 += 1
                    }
                    sqlite3_free(azResult as *mut libc::c_void);
                }
            }
        } else if c == 't' as i32
            && strcmp(
                azArg[0 as libc::c_int as usize],
                b"testcase\x00" as *const u8 as *const libc::c_char,
            ) == 0 as libc::c_int
        {
            output_reset(p);
            (*p).out = output_file_open(
                b"testcase-out.txt\x00" as *const u8 as *const libc::c_char,
                0 as libc::c_int,
            );
            if (*p).out.is_null() {
                fprintf(
                    stderr,
                    b"Error: cannot open \'testcase-out.txt\'\n\x00" as *const u8
                        as *const libc::c_char,
                );
            }
            if nArg >= 2 as libc::c_int {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as libc::c_int,
                    (*p).zTestcase.as_mut_ptr(),
                    b"%s\x00" as *const u8 as *const libc::c_char,
                    azArg[1 as libc::c_int as usize],
                );
            } else {
                sqlite3_snprintf(
                    ::std::mem::size_of::<[libc::c_char; 30]>() as libc::c_ulong as libc::c_int,
                    (*p).zTestcase.as_mut_ptr(),
                    b"?\x00" as *const u8 as *const libc::c_char,
                );
            }
        } else if c == 't' as i32
            && n >= 8 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"testctrl\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            /* Begin redirecting output to the file "testcase-out.txt" */
            /* Usage notes */
            static mut aCtrl_0: [C2RustUnnamed_19; 16] = [
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"always\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 13 as libc::c_int,
                        zUsage: b"BOOLEAN\x00" as *const u8 as *const libc::c_char,
                    }; /* 0: usage.  1: %d  2: %x  3: no-output */
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"assert\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 12 as libc::c_int,
                        zUsage: b"BOOLEAN\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"byteorder\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 22 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"extra_schema_checks\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 29 as libc::c_int,
                        zUsage: b"BOOLEAN\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"imposter\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 25 as libc::c_int,
                        zUsage: b"SCHEMA ON/OFF ROOTPAGE\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"internal_functions\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 17 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"localtime_fault\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 18 as libc::c_int,
                        zUsage: b"BOOLEAN\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"never_corrupt\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 20 as libc::c_int,
                        zUsage: b"BOOLEAN\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"optimizations\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 15 as libc::c_int,
                        zUsage: b"DISABLE-MASK\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"pending_byte\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 11 as libc::c_int,
                        zUsage: b"OFFSET  \x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"prng_restore\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 6 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"prng_save\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 5 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"prng_seed\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 28 as libc::c_int,
                        zUsage: b"SEED ?db?\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"seek_count\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 30 as libc::c_int,
                        zUsage: b"\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"sorter_mmap\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 24 as libc::c_int,
                        zUsage: b"NMAX\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
                {
                    let mut init = C2RustUnnamed_19 {
                        zCtrlName: b"tune\x00" as *const u8 as *const libc::c_char,
                        ctrlCode: 32 as libc::c_int,
                        zUsage: b"ID VALUE\x00" as *const u8 as *const libc::c_char,
                    };
                    init
                },
            ];
            let mut testctrl: libc::c_int = -(1 as libc::c_int);
            let mut iCtrl_0: libc::c_int = -(1 as libc::c_int);
            let mut rc2: libc::c_int = 0 as libc::c_int;
            let mut isOk_0: libc::c_int = 0 as libc::c_int;
            let mut i_16: libc::c_int = 0;
            let mut n2_3: libc::c_int = 0;
            let mut zCmd_1: *const libc::c_char = 0 as *const libc::c_char;
            open_db(p, 0 as libc::c_int);
            zCmd_1 = if nArg >= 2 as libc::c_int {
                azArg[1 as libc::c_int as usize] as *const libc::c_char
            } else {
                b"help\x00" as *const u8 as *const libc::c_char
            };
            /* The argument can optionally begin with "-" or "--" */
            if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
            {
                zCmd_1 = zCmd_1.offset(1);
                if *zCmd_1.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32
                    && *zCmd_1.offset(1 as libc::c_int as isize) as libc::c_int != 0
                {
                    zCmd_1 = zCmd_1.offset(1)
                }
            }
            /* --help lists all test-controls */
            if strcmp(zCmd_1, b"help\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int {
                fprintf(
                    (*p).out,
                    b"Available test-controls:\n\x00" as *const u8 as *const libc::c_char,
                );
                i_16 = 0 as libc::c_int;
                while i_16
                    < (::std::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong)
                        as libc::c_int
                {
                    fprintf(
                        (*p).out,
                        b"  .testctrl %s %s\n\x00" as *const u8 as *const libc::c_char,
                        aCtrl_0[i_16 as usize].zCtrlName,
                        aCtrl_0[i_16 as usize].zUsage,
                    );
                    i_16 += 1
                }
                rc = 1 as libc::c_int
            } else {
                /* convert testctrl text option to value. allow any unique prefix
                 ** of the option name, or a numerical value. */
                n2_3 = strlen30(zCmd_1);
                i_16 = 0 as libc::c_int;
                loop {
                    if !(i_16 < (::std::mem::size_of::<[C2RustUnnamed_19; 16]>() as libc::c_ulong)
                        .wrapping_div(::std::mem::size_of::<C2RustUnnamed_19>() as libc::c_ulong)
                        as libc::c_int)
                    {
                        current_block = 6392695526682111000;
                        break;
                    }
                    if strncmp(
                        zCmd_1,
                        aCtrl_0[i_16 as usize].zCtrlName,
                        n2_3 as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        if testctrl < 0 as libc::c_int {
                            testctrl = aCtrl_0[i_16 as usize].ctrlCode;
                            iCtrl_0 = i_16
                        } else {
                            fprintf(stderr,
                                    b"Error: ambiguous test-control: \"%s\"\nUse \".testctrl --help\" for help\n\x00"
                                        as *const u8 as *const libc::c_char,
                                    zCmd_1);
                            rc = 1 as libc::c_int;
                            current_block = 4767945957387570333;
                            break;
                        }
                    }
                    i_16 += 1
                }
                match current_block {
                    4767945957387570333 => {}
                    _ => {
                        if testctrl < 0 as libc::c_int {
                            fprintf(stderr,
                                    b"Error: unknown test-control: %s\nUse \".testctrl --help\" for help\n\x00"
                                        as *const u8 as *const libc::c_char,
                                    zCmd_1);
                        } else {
                            match testctrl {
                                15 => {
                                    current_block = 6607035776453710845;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 =>
                                        /* sqlite3_test_control(sqlite3*) */
                                        {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 =>
                                        /* sqlite3_test_control(int, int) */
                                        {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 =>
                                        /* sqlite3_test_control(int, int) */
                                        {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 =>
                                        /* sqlite3_test_control(int, int, sqlite3*) */
                                        {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    /* Make sure the schema has been loaded */
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 =>
                                        /* sqlite3_test_control(int, uint) */
                                        {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 =>
                                        /* sqlite3_test_control(int) */
                                        {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 =>
                                        /* sqlite3_test_control(int, db, int) */
                                        {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                5 | 6 | 22 => {
                                    current_block = 9950848984296616587;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                11 => {
                                    current_block = 167556243690099066;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                28 => {
                                    current_block = 4445027894144881889;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                12 | 13 => {
                                    current_block = 682710206895994785;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                18 | 20 => {
                                    current_block = 2281853558809188059;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                17 => {
                                    current_block = 13384017098195248509;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                25 => {
                                    current_block = 8148971061437104520;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                30 => {
                                    current_block = 11608372795245997655;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                24 => {
                                    current_block = 4642816011688875963;
                                    match current_block {
                                        4642816011688875963 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_3: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint
                                                        as libc::c_int;
                                                rc2 =
                                                    sqlite3_test_control(testctrl, (*p).db, opt_3);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        13384017098195248509 => {
                                            rc2 = sqlite3_test_control(testctrl, (*p).db);
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        2281853558809188059 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_2: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_2);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        682710206895994785 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_1: libc::c_int =
                                                    booleanValue(azArg[2 as libc::c_int as usize]);
                                                rc2 = sqlite3_test_control(testctrl, opt_1);
                                                isOk_0 = 1 as libc::c_int
                                            }
                                        }
                                        4445027894144881889 => {
                                            if nArg == 3 as libc::c_int || nArg == 4 as libc::c_int
                                            {
                                                let mut ii_2: libc::c_int =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_int;
                                                let mut db: *mut sqlite3 = 0 as *mut sqlite3;
                                                if ii_2 == 0 as libc::c_int
                                                    && strcmp(
                                                        azArg[2 as libc::c_int as usize],
                                                        b"random\x00" as *const u8
                                                            as *const libc::c_char,
                                                    ) == 0 as libc::c_int
                                                {
                                                    sqlite3_randomness(
                                                        ::std::mem::size_of::<libc::c_int>()
                                                            as libc::c_ulong
                                                            as libc::c_int,
                                                        &mut ii_2 as *mut libc::c_int
                                                            as *mut libc::c_void,
                                                    );
                                                    printf(
                                                        b"-- random seed: %d\n\x00" as *const u8
                                                            as *const libc::c_char,
                                                        ii_2,
                                                    );
                                                }
                                                if nArg == 3 as libc::c_int {
                                                    db = 0 as *mut sqlite3
                                                } else {
                                                    db = (*p).db;
                                                    sqlite3_table_column_metadata(
                                                        db,
                                                        0 as *const libc::c_char,
                                                        b"x\x00" as *const u8
                                                            as *const libc::c_char,
                                                        0 as *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut *const libc::c_char,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                        0 as *mut libc::c_int,
                                                    );
                                                }
                                                rc2 = sqlite3_test_control(testctrl, ii_2, db);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        167556243690099066 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt_0: libc::c_uint =
                                                    integerValue(azArg[2 as libc::c_int as usize])
                                                        as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, opt_0);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        9950848984296616587 => {
                                            if nArg == 2 as libc::c_int {
                                                rc2 = sqlite3_test_control(testctrl);
                                                isOk_0 = if testctrl == 22 as libc::c_int {
                                                    1 as libc::c_int
                                                } else {
                                                    3 as libc::c_int
                                                }
                                            }
                                        }
                                        6607035776453710845 => {
                                            if nArg == 3 as libc::c_int {
                                                let mut opt: libc::c_uint = strtol(
                                                    azArg[2 as libc::c_int as usize],
                                                    0 as *mut *mut libc::c_char,
                                                    0 as libc::c_int,
                                                )
                                                    as libc::c_uint;
                                                rc2 = sqlite3_test_control(testctrl, (*p).db, opt);
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                        11608372795245997655 => {
                                            let mut x_5: u64_0 = 0 as libc::c_int as u64_0;
                                            rc2 = sqlite3_test_control(
                                                testctrl,
                                                (*p).db,
                                                &mut x_5 as *mut u64_0,
                                            );
                                            fprintf(
                                                (*p).out,
                                                b"%llu\n\x00" as *const u8 as *const libc::c_char,
                                                x_5,
                                            );
                                            isOk_0 = 3 as libc::c_int
                                        }
                                        _ => {
                                            if nArg == 5 as libc::c_int {
                                                rc2 = sqlite3_test_control(
                                                    testctrl,
                                                    (*p).db,
                                                    azArg[2 as libc::c_int as usize],
                                                    integerValue(azArg[3 as libc::c_int as usize]),
                                                    integerValue(azArg[4 as libc::c_int as usize]),
                                                );
                                                isOk_0 = 3 as libc::c_int
                                            }
                                        }
                                    }
                                }
                                _ => {}
                            }
                        }
                        if isOk_0 == 0 as libc::c_int && iCtrl_0 >= 0 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"Usage: .testctrl %s %s\n\x00" as *const u8 as *const libc::c_char,
                                zCmd_1,
                                aCtrl_0[iCtrl_0 as usize].zUsage,
                            );
                            rc = 1 as libc::c_int
                        } else if isOk_0 == 1 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"%d\n\x00" as *const u8 as *const libc::c_char,
                                rc2,
                            );
                        } else if isOk_0 == 2 as libc::c_int {
                            fprintf(
                                (*p).out,
                                b"0x%08x\n\x00" as *const u8 as *const libc::c_char,
                                rc2,
                            );
                        }
                    }
                }
            }
        } else if c == 't' as i32
            && n > 4 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"timeout\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            open_db(p, 0 as libc::c_int);
            sqlite3_busy_timeout(
                (*p).db,
                if nArg >= 2 as libc::c_int {
                    integerValue(azArg[1 as libc::c_int as usize]) as libc::c_int
                } else {
                    0 as libc::c_int
                },
            );
        } else if c == 't' as i32
            && n >= 5 as libc::c_int
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"timer\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            if nArg == 2 as libc::c_int {
                enableTimer = booleanValue(azArg[1 as libc::c_int as usize]);
                if enableTimer != 0 && 1 as libc::c_int == 0 {
                    fprintf(
                        stderr,
                        b"Error: timer not available on this system.\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                    enableTimer = 0 as libc::c_int
                }
            } else {
                fprintf(
                    stderr,
                    b"Usage: .timer on|off\n\x00" as *const u8 as *const libc::c_char,
                );
                rc = 1 as libc::c_int
            }
        } else if c == 't' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"trace\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut mType: libc::c_int = 0 as libc::c_int;
            let mut jj: libc::c_int = 0;
            open_db(p, 0 as libc::c_int);
            jj = 1 as libc::c_int;
            loop {
                if !(jj < nArg) {
                    current_block = 15469049480916401536;
                    break;
                }
                let mut z_10: *const libc::c_char = azArg[jj as usize];
                if *z_10.offset(0 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    if optionMatch(z_10, b"expanded\x00" as *const u8 as *const libc::c_char) != 0 {
                        (*p).eTraceType = 1 as libc::c_int as u8_0
                    } else if optionMatch(z_10, b"plain\x00" as *const u8 as *const libc::c_char)
                        != 0
                    {
                        (*p).eTraceType = 0 as libc::c_int as u8_0
                    } else if optionMatch(z_10, b"profile\x00" as *const u8 as *const libc::c_char)
                        != 0
                    {
                        mType |= 0x2 as libc::c_int
                    } else if optionMatch(z_10, b"row\x00" as *const u8 as *const libc::c_char) != 0
                    {
                        mType |= 0x4 as libc::c_int
                    } else if optionMatch(z_10, b"stmt\x00" as *const u8 as *const libc::c_char)
                        != 0
                    {
                        mType |= 0x1 as libc::c_int
                    } else if optionMatch(z_10, b"close\x00" as *const u8 as *const libc::c_char)
                        != 0
                    {
                        mType |= 0x8 as libc::c_int
                    } else {
                        fprintf(
                            stderr,
                            b"Unknown option \"%s\" on \".trace\"\n\x00" as *const u8
                                as *const libc::c_char,
                            z_10,
                        );
                        rc = 1 as libc::c_int;
                        current_block = 4767945957387570333;
                        break;
                    }
                } else {
                    output_file_close((*p).traceOut);
                    (*p).traceOut =
                        output_file_open(azArg[1 as libc::c_int as usize], 0 as libc::c_int)
                }
                jj += 1
            }
            match current_block {
                4767945957387570333 => {}
                _ => {
                    if (*p).traceOut.is_null() {
                        sqlite3_trace_v2(
                            (*p).db,
                            0 as libc::c_int as libc::c_uint,
                            None,
                            0 as *mut libc::c_void,
                        );
                    } else {
                        if mType == 0 as libc::c_int {
                            mType = 0x1 as libc::c_int
                        }
                        sqlite3_trace_v2(
                            (*p).db,
                            mType as libc::c_uint,
                            Some(
                                sql_trace_callback
                                    as unsafe extern "C" fn(
                                        _: libc::c_uint,
                                        _: *mut libc::c_void,
                                        _: *mut libc::c_void,
                                        _: *mut libc::c_void,
                                    )
                                        -> libc::c_int,
                            ),
                            p as *mut libc::c_void,
                        );
                    }
                }
            }
        } else if c == 'v' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"version\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            fprintf(
                (*p).out,
                b"SQLite %s %s\n\x00" as *const u8 as *const libc::c_char,
                sqlite3_libversion(),
                sqlite3_sourceid(),
            );
            fprintf(
                (*p).out,
                b"zlib version %s\n\x00" as *const u8 as *const libc::c_char,
                zlibVersion(),
            );
            fprintf(
                (*p).out,
                b"clang-11.0.1\n\x00" as *const u8 as *const libc::c_char,
            );
        } else if c == 'v' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"vfsinfo\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zDbName_0: *const libc::c_char = if nArg == 2 as libc::c_int {
                azArg[1 as libc::c_int as usize] as *const libc::c_char
            } else {
                b"main\x00" as *const u8 as *const libc::c_char
            };
            let mut pVfs: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
            if !(*p).db.is_null() {
                sqlite3_file_control(
                    (*p).db,
                    zDbName_0,
                    27 as libc::c_int,
                    &mut pVfs as *mut *mut sqlite3_vfs as *mut libc::c_void,
                );
                if !pVfs.is_null() {
                    fprintf(
                        (*p).out,
                        b"vfs.zName      = \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                        (*pVfs).zName,
                    );
                    fprintf(
                        (*p).out,
                        b"vfs.iVersion   = %d\n\x00" as *const u8 as *const libc::c_char,
                        (*pVfs).iVersion,
                    );
                    fprintf(
                        (*p).out,
                        b"vfs.szOsFile   = %d\n\x00" as *const u8 as *const libc::c_char,
                        (*pVfs).szOsFile,
                    );
                    fprintf(
                        (*p).out,
                        b"vfs.mxPathname = %d\n\x00" as *const u8 as *const libc::c_char,
                        (*pVfs).mxPathname,
                    );
                }
            }
        } else if c == 'v' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"vfslist\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut pVfs_0: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
            let mut pCurrent: *mut sqlite3_vfs = 0 as *mut sqlite3_vfs;
            if !(*p).db.is_null() {
                sqlite3_file_control(
                    (*p).db,
                    b"main\x00" as *const u8 as *const libc::c_char,
                    27 as libc::c_int,
                    &mut pCurrent as *mut *mut sqlite3_vfs as *mut libc::c_void,
                );
            }
            pVfs_0 = sqlite3_vfs_find(0 as *const libc::c_char);
            while !pVfs_0.is_null() {
                fprintf(
                    (*p).out,
                    b"vfs.zName      = \"%s\"%s\n\x00" as *const u8 as *const libc::c_char,
                    (*pVfs_0).zName,
                    if pVfs_0 == pCurrent {
                        b"  <--- CURRENT\x00" as *const u8 as *const libc::c_char
                    } else {
                        b"\x00" as *const u8 as *const libc::c_char
                    },
                );
                fprintf(
                    (*p).out,
                    b"vfs.iVersion   = %d\n\x00" as *const u8 as *const libc::c_char,
                    (*pVfs_0).iVersion,
                );
                fprintf(
                    (*p).out,
                    b"vfs.szOsFile   = %d\n\x00" as *const u8 as *const libc::c_char,
                    (*pVfs_0).szOsFile,
                );
                fprintf(
                    (*p).out,
                    b"vfs.mxPathname = %d\n\x00" as *const u8 as *const libc::c_char,
                    (*pVfs_0).mxPathname,
                );
                if !(*pVfs_0).pNext.is_null() {
                    fprintf(
                        (*p).out,
                        b"-----------------------------------\n\x00" as *const u8
                            as *const libc::c_char,
                    );
                }
                pVfs_0 = (*pVfs_0).pNext
            }
        } else if c == 'v' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"vfsname\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut zDbName_1: *const libc::c_char = if nArg == 2 as libc::c_int {
                azArg[1 as libc::c_int as usize] as *const libc::c_char
            } else {
                b"main\x00" as *const u8 as *const libc::c_char
            };
            let mut zVfsName: *mut libc::c_char = 0 as *mut libc::c_char;
            if !(*p).db.is_null() {
                sqlite3_file_control(
                    (*p).db,
                    zDbName_1,
                    12 as libc::c_int,
                    &mut zVfsName as *mut *mut libc::c_char as *mut libc::c_void,
                );
                if !zVfsName.is_null() {
                    fprintf(
                        (*p).out,
                        b"%s\n\x00" as *const u8 as *const libc::c_char,
                        zVfsName,
                    );
                    sqlite3_free(zVfsName as *mut libc::c_void);
                }
            }
        } else if c == 'w' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"wheretrace\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut x_6: libc::c_uint = if nArg >= 2 as libc::c_int {
                integerValue(azArg[1 as libc::c_int as usize]) as libc::c_uint
            } else {
                0xffffffff as libc::c_uint
            };
            sqlite3_test_control(
                31 as libc::c_int,
                3 as libc::c_int,
                &mut x_6 as *mut libc::c_uint,
            );
        } else if c == 'w' as i32
            && strncmp(
                azArg[0 as libc::c_int as usize],
                b"width\x00" as *const u8 as *const libc::c_char,
                n as libc::c_ulong,
            ) == 0 as libc::c_int
        {
            let mut j_2: libc::c_int = 0;
            (*p).nWidth = nArg - 1 as libc::c_int;
            (*p).colWidth = realloc(
                (*p).colWidth as *mut libc::c_void,
                (((*p).nWidth + 1 as libc::c_int) as libc::c_ulong)
                    .wrapping_mul(::std::mem::size_of::<libc::c_int>() as libc::c_ulong)
                    .wrapping_mul(2 as libc::c_int as libc::c_ulong),
            ) as *mut libc::c_int;
            if (*p).colWidth.is_null() && (*p).nWidth > 0 as libc::c_int {
                shell_out_of_memory();
            }
            if (*p).nWidth != 0 {
                (*p).actualWidth =
                    &mut *(*p).colWidth.offset((*p).nWidth as isize) as *mut libc::c_int
            }
            j_2 = 1 as libc::c_int;
            while j_2 < nArg {
                *(*p).colWidth.offset((j_2 - 1 as libc::c_int) as isize) =
                    integerValue(azArg[j_2 as usize]) as libc::c_int;
                j_2 += 1
            }
        } else {
            fprintf(stderr,
                    b"Error: unknown command or invalid arguments:  \"%s\". Enter \".help\" for help\n\x00"
                        as *const u8 as *const libc::c_char,
                    azArg[0 as libc::c_int as usize]);
            rc = 1 as libc::c_int
        }
        if (*p).outCount != 0 {
            (*p).outCount -= 1;
            if (*p).outCount == 0 as libc::c_int {
                output_reset(p);
            }
        }
        (*p).bSafeMode = (*p).bSafeModePersist;
        return rc;
        /* !defined(SQLITE_UNTESTABLE) */
        /* !defined(SQLITE_OMIT_TRACE) */
        /* SQLITE_USER_AUTHENTICATION */
        /* No-op */
    };
}
/*
** Scan line for classification to guide shell's handling.
** The scan is resumable for subsequent lines when prior
** return values are passed as the 2nd argument.
*/
unsafe extern "C" fn quickscan(
    mut zLine: *mut libc::c_char,
    mut qss: QuickScanState,
) -> QuickScanState {
    let mut current_block: u64; /* intentional narrowing loss */
    let mut cin: libc::c_char = 0;
    let mut cWait: libc::c_char = qss as libc::c_char;
    if cWait as libc::c_int == 0 as libc::c_int {
        current_block = 16658872821858055392;
    } else {
        current_block = 11307063007268554308;
    }
    's_18: loop {
        match current_block {
            16658872821858055392 => {
                let fresh97 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh97;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if *(*__ctype_b_loc()).offset(cin as libc::c_uchar as libc::c_int as isize)
                    as libc::c_int
                    & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                    != 0
                {
                    current_block = 16658872821858055392;
                    continue;
                }
                match cin as libc::c_int {
                    45 => {
                        if *zLine as libc::c_int != '-' as i32 {
                            current_block = 224731115979188411;
                        } else {
                            loop {
                                zLine = zLine.offset(1);
                                cin = *zLine;
                                if !(cin as libc::c_int != 0 as libc::c_int) {
                                    break;
                                }
                                if cin as libc::c_int == '\n' as i32 {
                                    current_block = 16658872821858055392;
                                    continue 's_18;
                                }
                            }
                            return qss;
                        }
                    }
                    59 => {
                        qss = ::std::mem::transmute::<libc::c_uint, QuickScanState>(
                            qss as libc::c_uint | QSS_EndingSemi as libc::c_int as libc::c_uint,
                        );
                        current_block = 16658872821858055392;
                        continue;
                    }
                    47 => {
                        if *zLine as libc::c_int == '*' as i32 {
                            zLine = zLine.offset(1);
                            cWait = '*' as i32 as libc::c_char;
                            qss = (cWait as libc::c_uint
                                | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                                as QuickScanState;
                            current_block = 11307063007268554308;
                            continue;
                        } else {
                            current_block = 224731115979188411;
                        }
                    }
                    91 => {
                        cin = ']' as i32 as libc::c_char;
                        current_block = 10424142149821401439;
                    }
                    96 | 39 | 34 => {
                        current_block = 10424142149821401439;
                    }
                    _ => {
                        current_block = 224731115979188411;
                    }
                }
                match current_block {
                    224731115979188411 => {
                        qss = (qss as libc::c_uint
                            & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                            | QSS_HasDark as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 16658872821858055392;
                    }
                    _ =>
                    /* fall thru */
                    {
                        cWait = cin;
                        qss = (QSS_HasDark as libc::c_int | cWait as libc::c_int) as QuickScanState;
                        current_block = 11307063007268554308;
                    }
                }
            }
            _ => {
                let fresh98 = zLine;
                zLine = zLine.offset(1);
                cin = *fresh98;
                if !(cin as libc::c_int != 0 as libc::c_int) {
                    break;
                }
                if !(cin as libc::c_int == cWait as libc::c_int) {
                    current_block = 11307063007268554308;
                    continue;
                }
                match cWait as libc::c_int {
                    42 => {
                        if *zLine as libc::c_int != '/' as i32 {
                            current_block = 11307063007268554308;
                            continue;
                        }
                        zLine = zLine.offset(1);
                        cWait = 0 as libc::c_int as libc::c_char;
                        qss = (0 as libc::c_int as libc::c_uint
                            | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                            as QuickScanState;
                        current_block = 16658872821858055392;
                        continue;
                    }
                    96 | 39 | 34 => {
                        if *zLine as libc::c_int == cWait as libc::c_int {
                            zLine = zLine.offset(1);
                            current_block = 11307063007268554308;
                            continue;
                        }
                    }
                    93 => {}
                    _ => {
                        current_block = 11307063007268554308;
                        continue;
                    }
                }
                /* fall thru */
                cWait = 0 as libc::c_int as libc::c_char;
                qss = (0 as libc::c_int as libc::c_uint
                    | qss as libc::c_uint & QSS_ScanMask as libc::c_int as libc::c_uint)
                    as QuickScanState;
                current_block = 16658872821858055392;
            }
        }
    }
    return qss;
}
/*
** Return TRUE if the line typed in is an SQL command terminator other
** than a semi-colon.  The SQL Server style "go" command is understood
** as is the Oracle "/".
*/
unsafe extern "C" fn line_is_command_terminator(mut zLine: *mut libc::c_char) -> libc::c_int {
    while *(*__ctype_b_loc())
        .offset(*zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int as isize)
        as libc::c_int
        & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
        != 0
    {
        zLine = zLine.offset(1)
    } /* Oracle */
    if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '/' as i32 {
        zLine = zLine.offset(1 as libc::c_int as isize)
    } else if ({
        let mut __res: libc::c_int = 0; /* SQL Server */
        if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
            > 1 as libc::c_int as libc::c_ulong
        {
            if 0 != 0 {
                let mut __c: libc::c_int =
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int;
                __res = if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                    __c
                } else {
                    *(*__ctype_tolower_loc()).offset(__c as isize)
                }
            } else {
                __res = tolower(
                    *zLine.offset(0 as libc::c_int as isize) as libc::c_uchar as libc::c_int
                )
            }
        } else {
            __res = *(*__ctype_tolower_loc()).offset(*zLine.offset(0 as libc::c_int as isize)
                as libc::c_uchar as libc::c_int
                as isize)
        }
        __res
    }) as libc::c_char as libc::c_int
        == 'g' as i32
        && ({
            let mut __res: libc::c_int = 0;
            if ::std::mem::size_of::<libc::c_uchar>() as libc::c_ulong
                > 1 as libc::c_int as libc::c_ulong
            {
                if 0 != 0 {
                    let mut __c: libc::c_int =
                        *zLine.offset(1 as libc::c_int as isize) as libc::c_uchar as libc::c_int;
                    __res = if __c < -(128 as libc::c_int) || __c > 255 as libc::c_int {
                        __c
                    } else {
                        *(*__ctype_tolower_loc()).offset(__c as isize)
                    }
                } else {
                    __res =
                        tolower(*zLine.offset(1 as libc::c_int as isize) as libc::c_uchar
                            as libc::c_int)
                }
            } else {
                __res = *(*__ctype_tolower_loc()).offset(*zLine.offset(1 as libc::c_int as isize)
                    as libc::c_uchar
                    as libc::c_int
                    as isize)
            }
            __res
        }) as libc::c_char as libc::c_int
            == 'o' as i32
    {
        zLine = zLine.offset(2 as libc::c_int as isize)
    } else {
        return 0 as libc::c_int;
    }
    return (quickscan(zLine, QSS_Start) as libc::c_uint == QSS_Start as libc::c_int as libc::c_uint)
        as libc::c_int;
}
/*
** We need a default sqlite3_complete() implementation to use in case
** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
** any arbitrary text is a complete SQL statement.  This is not very
** user-friendly, but it does seem to work.
*/
/*
** Return true if zSql is a complete SQL statement.  Return false if it
** ends in the middle of a string literal or C-style comment.
*/
unsafe extern "C" fn line_is_complete(
    mut zSql: *mut libc::c_char,
    mut nSql: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    if zSql.is_null() {
        return 1 as libc::c_int;
    } else {
        *zSql.offset(nSql as isize) = ';' as i32 as libc::c_char;
        *zSql.offset((nSql + 1 as libc::c_int) as isize) = 0 as libc::c_int as libc::c_char;
        rc = sqlite3_complete(zSql);
        *zSql.offset(nSql as isize) = 0 as libc::c_int as libc::c_char;
        return rc;
    };
}
/*
** Run a single line of SQL.  Return the number of errors.
*/
unsafe extern "C" fn runOneSqlLine(
    mut p: *mut ShellState,
    mut zSql: *mut libc::c_char,
    mut in_0: *mut FILE,
    mut startline: libc::c_int,
) -> libc::c_int {
    let mut rc: libc::c_int = 0;
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    open_db(p, 0 as libc::c_int);
    if (*p).shellFlgs & 0x4 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint {
        resolve_backslashes(zSql);
    }
    if (*p).flgProgress & 0x2 as libc::c_int as libc::c_uint != 0 {
        (*p).nProgress = 0 as libc::c_int as libc::c_uint
    }
    beginTimer();
    rc = shell_exec(p, zSql, &mut zErrMsg);
    endTimer();
    if rc != 0 || !zErrMsg.is_null() {
        let mut zPrefix: [libc::c_char; 100] = [0; 100];
        if !in_0.is_null() || stdin_is_interactive == 0 {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"Error: near line %d:\x00" as *const u8 as *const libc::c_char,
                startline,
            );
        } else {
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 100]>() as libc::c_ulong as libc::c_int,
                zPrefix.as_mut_ptr(),
                b"Error:\x00" as *const u8 as *const libc::c_char,
            );
        }
        if !zErrMsg.is_null() {
            fprintf(
                stderr,
                b"%s %s\n\x00" as *const u8 as *const libc::c_char,
                zPrefix.as_mut_ptr(),
                zErrMsg,
            );
            sqlite3_free(zErrMsg as *mut libc::c_void);
            zErrMsg = 0 as *mut libc::c_char
        } else {
            fprintf(
                stderr,
                b"%s %s\n\x00" as *const u8 as *const libc::c_char,
                zPrefix.as_mut_ptr(),
                sqlite3_errmsg((*p).db),
            );
        }
        return 1 as libc::c_int;
    } else {
        if (*p).shellFlgs & 0x20 as libc::c_int as libc::c_uint != 0 as libc::c_int as libc::c_uint
        {
            let mut zLineBuf: [libc::c_char; 2000] = [0; 2000];
            sqlite3_snprintf(
                ::std::mem::size_of::<[libc::c_char; 2000]>() as libc::c_ulong as libc::c_int,
                zLineBuf.as_mut_ptr(),
                b"changes: %lld   total_changes: %lld\x00" as *const u8 as *const libc::c_char,
                sqlite3_changes64((*p).db),
                sqlite3_total_changes64((*p).db),
            );
            fprintf(
                (*p).out,
                b"%s\n\x00" as *const u8 as *const libc::c_char,
                zLineBuf.as_mut_ptr(),
            );
        }
        return 0 as libc::c_int;
    };
}
/* Forward reference */
/*
** Read input from *in and process it.  If *in==0 then input
** is interactive - the user is typing it it.  Otherwise, input
** is coming from a file or device.  A prompt is issued and history
** is saved only if input is interactive.  An interrupt signal will
** cause this routine to exit immediately, unless input is interactive.
**
** Return the number of errors.
*/
unsafe extern "C" fn process_input(mut p: *mut ShellState) -> libc::c_int {
    let mut zLine: *mut libc::c_char = 0 as *mut libc::c_char; /* A single input line */
    let mut zSql: *mut libc::c_char = 0 as *mut libc::c_char; /* Accumulated SQL text */
    let mut nLine: libc::c_int = 0; /* Length of current line */
    let mut nSql: libc::c_int = 0 as libc::c_int; /* Bytes of zSql[] used */
    let mut nAlloc: libc::c_int = 0 as libc::c_int; /* Allocated zSql[] space */
    let mut rc: libc::c_int = 0; /* Error code */
    let mut errCnt: libc::c_int = 0 as libc::c_int; /* Number of errors seen */
    let mut startline: libc::c_int = 0 as libc::c_int; /* Line number for start of current input */
    let mut qss: QuickScanState = QSS_Start; /* Accumulated line status (so far) */
    (*p).lineno = 0 as libc::c_int;
    while errCnt == 0 as libc::c_int
        || bail_on_error == 0
        || (*p).in_0.is_null() && stdin_is_interactive != 0
    {
        fflush((*p).out);
        zLine = one_input_line((*p).in_0, zLine, (nSql > 0 as libc::c_int) as libc::c_int);
        if zLine.is_null() {
            /* End of input */
            if !((*p).in_0.is_null() && stdin_is_interactive != 0) {
                break;
            }
            printf(b"\n\x00" as *const u8 as *const libc::c_char);
            break;
        } else {
            if seenInterrupt != 0 {
                if !(*p).in_0.is_null() {
                    break;
                }
                ::std::ptr::write_volatile(&mut seenInterrupt as *mut libc::c_int, 0 as libc::c_int)
            }
            (*p).lineno += 1;
            if qss as libc::c_uint & QSS_CharMask as libc::c_int as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && line_is_command_terminator(zLine) != 0
                && line_is_complete(zSql, nSql) != 0
            {
                memcpy(
                    zLine as *mut libc::c_void,
                    b";\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                    2 as libc::c_int as libc::c_ulong,
                );
            }
            qss = quickscan(zLine, qss);
            if qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                == QSS_Start as libc::c_int as libc::c_uint
                && nSql == 0 as libc::c_int
            {
                if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                {
                    printf(b"%s\n\x00" as *const u8 as *const libc::c_char, zLine);
                }
                /* Just swallow single-line whitespace */
                qss = QSS_Start
            } else if !zLine.is_null()
                && (*zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32
                    || *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '#' as i32)
                && nSql == 0 as libc::c_int
            {
                if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                    != 0 as libc::c_int as libc::c_uint
                {
                    printf(b"%s\n\x00" as *const u8 as *const libc::c_char, zLine);
                }
                if *zLine.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {
                    rc = do_meta_command(zLine, p);
                    if rc == 2 as libc::c_int {
                        break;
                    }
                    if rc != 0 {
                        errCnt += 1
                    }
                }
                qss = QSS_Start
            } else {
                /* No single-line dispositions remain; accumulate line(s). */
                nLine = strlen30(zLine);
                if nSql + nLine + 2 as libc::c_int >= nAlloc {
                    /* Grow buffer by half-again increments when big. */
                    nAlloc = nSql + (nSql >> 1 as libc::c_int) + nLine + 100 as libc::c_int;
                    zSql = realloc(zSql as *mut libc::c_void, nAlloc as libc::c_ulong)
                        as *mut libc::c_char;
                    if zSql.is_null() {
                        shell_out_of_memory();
                    }
                }
                if nSql == 0 as libc::c_int {
                    let mut i: libc::c_int = 0;
                    i = 0 as libc::c_int;
                    while *zLine.offset(i as isize) as libc::c_int != 0
                        && *(*__ctype_b_loc()).offset(*zLine.offset(i as isize) as libc::c_uchar
                            as libc::c_int
                            as isize) as libc::c_int
                            & _ISspace as libc::c_int as libc::c_ushort as libc::c_int
                            != 0
                    {
                        i += 1
                    }
                    memcpy(
                        zSql as *mut libc::c_void,
                        zLine.offset(i as isize) as *const libc::c_void,
                        (nLine + 1 as libc::c_int - i) as libc::c_ulong,
                    );
                    startline = (*p).lineno;
                    nSql = nLine - i
                } else {
                    let fresh99 = nSql;
                    nSql = nSql + 1;
                    *zSql.offset(fresh99 as isize) = '\n' as i32 as libc::c_char;
                    memcpy(
                        zSql.offset(nSql as isize) as *mut libc::c_void,
                        zLine as *const libc::c_void,
                        (nLine + 1 as libc::c_int) as libc::c_ulong,
                    );
                    nSql += nLine
                }
                if nSql != 0
                    && qss as libc::c_uint & !(QSS_HasDark as libc::c_int) as libc::c_uint
                        == QSS_EndingSemi as libc::c_int as libc::c_uint
                    && sqlite3_complete(zSql) != 0
                {
                    errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline);
                    nSql = 0 as libc::c_int;
                    if (*p).outCount != 0 {
                        output_reset(p);
                        (*p).outCount = 0 as libc::c_int
                    } else {
                        clearTempFile(p);
                    }
                    (*p).bSafeMode = (*p).bSafeModePersist;
                    qss = QSS_Start
                } else {
                    if !(nSql != 0
                        && qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
                            == QSS_Start as libc::c_int as libc::c_uint)
                    {
                        continue;
                    }
                    if (*p).shellFlgs & 0x40 as libc::c_int as libc::c_uint
                        != 0 as libc::c_int as libc::c_uint
                    {
                        printf(b"%s\n\x00" as *const u8 as *const libc::c_char, zSql);
                    }
                    nSql = 0 as libc::c_int;
                    qss = QSS_Start
                }
            }
        }
    }
    /* exit requested */
    if nSql != 0
        && qss as libc::c_uint & !(QSS_EndingSemi as libc::c_int) as libc::c_uint
            == QSS_HasDark as libc::c_int as libc::c_uint
    {
        errCnt += runOneSqlLine(p, zSql, (*p).in_0, startline)
    }
    free(zSql as *mut libc::c_void);
    free(zLine as *mut libc::c_void);
    return (errCnt > 0 as libc::c_int) as libc::c_int;
}
/*
** Return a pathname which is the user's home directory.  A
** 0 return indicates an error of some kind.
*/
unsafe extern "C" fn find_home_dir(mut clearFlag: libc::c_int) -> *mut libc::c_char {
    static mut home_dir: *mut libc::c_char = 0 as *const libc::c_char as *mut libc::c_char;
    if clearFlag != 0 {
        free(home_dir as *mut libc::c_void);
        home_dir = 0 as *mut libc::c_char;
        return 0 as *mut libc::c_char;
    } else if !home_dir.is_null() {
        return home_dir;
    } else {
        let mut pwent: *mut passwd = 0 as *mut passwd;
        let mut uid: uid_t = getuid();
        pwent = getpwuid(uid);
        if !pwent.is_null() {
            home_dir = (*pwent).pw_dir
        }
        if home_dir.is_null() {
            home_dir = getenv(b"HOME\x00" as *const u8 as *const libc::c_char)
        }
        /* !_WIN32_WCE */
        if !home_dir.is_null() {
            let mut n: libc::c_int = strlen30(home_dir) + 1 as libc::c_int;
            let mut z: *mut libc::c_char = malloc(n as libc::c_ulong) as *mut libc::c_char;
            if !z.is_null() {
                memcpy(
                    z as *mut libc::c_void,
                    home_dir as *const libc::c_void,
                    n as libc::c_ulong,
                );
            }
            home_dir = z
        }
        return home_dir;
    };
}
/*
** Read input from the file given by sqliterc_override.  Or if that
** parameter is NULL, take input from ~/.sqliterc
**
** Returns the number of errors.
*/
unsafe extern "C" fn process_sqliterc(
    mut p: *mut ShellState,
    mut sqliterc_override: *const libc::c_char,
)
/* Name of config file. NULL to use default */
{
    let mut home_dir: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut sqliterc: *const libc::c_char = sqliterc_override;
    let mut zBuf: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut inSaved: *mut FILE = (*p).in_0;
    let mut savedLineno: libc::c_int = (*p).lineno;
    if sqliterc.is_null() {
        home_dir = find_home_dir(0 as libc::c_int);
        if home_dir.is_null() {
            fprintf(
                stderr,
                b"-- warning: cannot find home directory; cannot read ~/.sqliterc\n\x00"
                    as *const u8 as *const libc::c_char,
            );
            return;
        } else {
            zBuf = sqlite3_mprintf(
                b"%s/.sqliterc\x00" as *const u8 as *const libc::c_char,
                home_dir,
            );
            sqliterc = zBuf
        }
    }
    (*p).in_0 = fopen(sqliterc, b"rb\x00" as *const u8 as *const libc::c_char);
    if !(*p).in_0.is_null() {
        if stdin_is_interactive != 0 {
            fprintf(
                stderr,
                b"-- Loading resources from %s\n\x00" as *const u8 as *const libc::c_char,
                sqliterc,
            );
        }
        if process_input(p) != 0 && bail_on_error != 0 {
            exit(1 as libc::c_int);
        } else {
            fclose((*p).in_0);
        }
    } else if !sqliterc_override.is_null() {
        fprintf(
            stderr,
            b"cannot open: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
            sqliterc,
        );
        if bail_on_error != 0 {
            exit(1 as libc::c_int);
        }
    }
    (*p).in_0 = inSaved;
    (*p).lineno = savedLineno;
    sqlite3_free(zBuf as *mut libc::c_void);
}
/*
** Show available command line options
*/
static mut zOptions: [libc::c_char; 2153] = unsafe {
    *::std::mem::transmute::<&[u8; 2153],
                                 &[libc::c_char; 2153]>(b"   -A ARGS...           run \".archive ARGS\" and exit\n   -append              append the database to the end of the file\n   -ascii               set output mode to \'ascii\'\n   -bail                stop after hitting an error\n   -batch               force batch I/O\n   -box                 set output mode to \'box\'\n   -column              set output mode to \'column\'\n   -cmd COMMAND         run \"COMMAND\" before reading stdin\n   -csv                 set output mode to \'csv\'\n   -deserialize         open the database using sqlite3_deserialize()\n   -echo                print commands before execution\n   -init FILENAME       read/process named file\n   -[no]header          turn headers on or off\n   -help                show this message\n   -html                set output mode to HTML\n   -interactive         force interactive I/O\n   -json                set output mode to \'json\'\n   -line                set output mode to \'line\'\n   -list                set output mode to \'list\'\n   -lookaside SIZE N    use N entries of SZ bytes for lookaside memory\n   -markdown            set output mode to \'markdown\'\n   -maxsize N           maximum size for a --deserialize database\n   -memtrace            trace all memory allocations and deallocations\n   -mmap N              default mmap size set to N\n   -newline SEP         set output row separator. Default: \'\\n\'\n   -nofollow            refuse to open symbolic links to database files\n   -nonce STRING        set the safe-mode escape nonce\n   -nullvalue TEXT      set text string for NULL values. Default \'\'\n   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n   -quote               set output mode to \'quote\'\n   -readonly            open the database read-only\n   -safe                enable safe-mode\n   -separator SEP       set output column separator. Default: \'|\'\n   -stats               print memory stats before each finalize\n   -table               set output mode to \'table\'\n   -tabs                set output mode to \'tabs\'\n   -version             show SQLite version\n   -vfs NAME            use NAME as the default VFS\n   -zip                 open the file as a ZIP Archive\n\x00")
};
unsafe extern "C" fn usage(mut showDetail: libc::c_int) {
    fprintf(stderr,
            b"Usage: %s [OPTIONS] FILENAME [SQL]\nFILENAME is the name of an SQLite database. A new database is created\nif the file does not previously exist.\n\x00"
                as *const u8 as *const libc::c_char, Argv0);
    if showDetail != 0 {
        fprintf(
            stderr,
            b"OPTIONS include:\n%s\x00" as *const u8 as *const libc::c_char,
            zOptions.as_ptr(),
        );
    } else {
        fprintf(
            stderr,
            b"Use the -help option for additional information\n\x00" as *const u8
                as *const libc::c_char,
        );
    }
    exit(1 as libc::c_int);
}
/*
** Internal check:  Verify that the SQLite is uninitialized.  Print a
** error message if it is initialized.
*/
unsafe extern "C" fn verify_uninitialized() {
    if sqlite3_config(-(1 as libc::c_int)) == 21 as libc::c_int {
        fprintf(
            stdout,
            b"WARNING: attempt to configure SQLite after initialization.\n\x00" as *const u8
                as *const libc::c_char,
        );
    };
}
/*
** Initialize the state information in data
*/
unsafe extern "C" fn main_init(mut data: *mut ShellState) {
    memset(
        data as *mut libc::c_void,
        0 as libc::c_int,
        ::std::mem::size_of::<ShellState>() as libc::c_ulong,
    );
    (*data).mode = 2 as libc::c_int;
    (*data).cMode = (*data).mode;
    (*data).normalMode = (*data).cMode;
    (*data).autoExplain = 1 as libc::c_int as u8_0;
    (*data).pAuxDb = &mut *(*data)
        .aAuxDb
        .as_mut_ptr()
        .offset(0 as libc::c_int as isize) as *mut AuxDb;
    memcpy(
        (*data).colSeparator.as_mut_ptr() as *mut libc::c_void,
        b"|\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    memcpy(
        (*data).rowSeparator.as_mut_ptr() as *mut libc::c_void,
        b"\n\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
        2 as libc::c_int as libc::c_ulong,
    );
    (*data).showHeader = 0 as libc::c_int;
    (*data).shellFlgs = 0x2 as libc::c_int as libc::c_uint;
    verify_uninitialized();
    sqlite3_config(17 as libc::c_int, 1 as libc::c_int);
    sqlite3_config(
        16 as libc::c_int,
        Some(
            shellLog
                as unsafe extern "C" fn(
                    _: *mut libc::c_void,
                    _: libc::c_int,
                    _: *const libc::c_char,
                ) -> (),
        ),
        data,
    );
    sqlite3_config(2 as libc::c_int);
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        mainPrompt.as_mut_ptr(),
        b"sqlite> \x00" as *const u8 as *const libc::c_char,
    );
    sqlite3_snprintf(
        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
        continuePrompt.as_mut_ptr(),
        b"   ...> \x00" as *const u8 as *const libc::c_char,
    );
}
/*
** Output text to the console in a font that attracts extra attention.
*/
unsafe extern "C" fn printBold(mut zText: *const libc::c_char) {
    printf(
        b"\x1b[1m%s\x1b[0m\x00" as *const u8 as *const libc::c_char,
        zText,
    );
}
/*
** Get the argument to an --option.  Throw an error and die if no argument
** is available.
*/
unsafe extern "C" fn cmdline_option_value(
    mut argc: libc::c_int,
    mut argv: *mut *mut libc::c_char,
    mut i: libc::c_int,
) -> *mut libc::c_char {
    if i == argc {
        fprintf(
            stderr,
            b"%s: Error: missing argument to %s\n\x00" as *const u8 as *const libc::c_char,
            *argv.offset(0 as libc::c_int as isize),
            *argv.offset((argc - 1 as libc::c_int) as isize),
        ); /* Value of -vfs command-line option */
        exit(1 as libc::c_int); /* Make sure stderr is unbuffered */
    } else {
        return *argv.offset(i as isize);
    };
}
unsafe fn main_0(mut argc: libc::c_int, mut argv: *mut *mut libc::c_char) -> libc::c_int {
    let mut zErrMsg: *mut libc::c_char = 0 as *mut libc::c_char;
    let mut data: ShellState = ShellState {
        db: 0 as *mut sqlite3,
        autoExplain: 0,
        autoEQP: 0,
        autoEQPtest: 0,
        autoEQPtrace: 0,
        scanstatsOn: 0,
        openMode: 0,
        doXdgOpen: 0,
        nEqpLevel: 0,
        eTraceType: 0,
        bSafeMode: 0,
        bSafeModePersist: 0,
        statsOn: 0,
        mEqpLines: 0,
        outCount: 0,
        cnt: 0,
        lineno: 0,
        openFlags: 0,
        in_0: 0 as *mut FILE,
        out: 0 as *mut FILE,
        traceOut: 0 as *mut FILE,
        nErr: 0,
        mode: 0,
        modePrior: 0,
        cMode: 0,
        normalMode: 0,
        writableSchema: 0,
        showHeader: 0,
        nCheck: 0,
        nProgress: 0,
        mxProgress: 0,
        flgProgress: 0,
        shellFlgs: 0,
        priorShFlgs: 0,
        szMax: 0,
        zDestTable: 0 as *mut libc::c_char,
        zTempFile: 0 as *mut libc::c_char,
        zTestcase: [0; 30],
        colSeparator: [0; 20],
        rowSeparator: [0; 20],
        colSepPrior: [0; 20],
        rowSepPrior: [0; 20],
        colWidth: 0 as *mut libc::c_int,
        actualWidth: 0 as *mut libc::c_int,
        nWidth: 0,
        nullValue: [0; 20],
        outfile: [0; 4096],
        pStmt: 0 as *mut sqlite3_stmt,
        pLog: 0 as *mut FILE,
        aAuxDb: [AuxDb {
            db: 0 as *mut sqlite3,
            zDbFilename: 0 as *const libc::c_char,
            zFreeOnClose: 0 as *mut libc::c_char,
        }; 5],
        pAuxDb: 0 as *mut AuxDb,
        aiIndent: 0 as *mut libc::c_int,
        nIndent: 0,
        iIndent: 0,
        zNonce: 0 as *mut libc::c_char,
        sGraph: EQPGraph {
            pRow: 0 as *mut EQPGraphRow,
            pLast: 0 as *mut EQPGraphRow,
            zPrefix: [0; 100],
        },
        expert: ExpertInfo {
            pExpert: 0 as *mut sqlite3expert,
            bVerbose: 0,
        },
    };
    let mut zInitFile: *const libc::c_char = 0 as *const libc::c_char;
    let mut i: libc::c_int = 0;
    let mut rc: libc::c_int = 0 as libc::c_int;
    let mut warnInmemoryDb: libc::c_int = 0 as libc::c_int;
    let mut readStdin: libc::c_int = 1 as libc::c_int;
    let mut nCmd: libc::c_int = 0 as libc::c_int;
    let mut azCmd: *mut *mut libc::c_char = 0 as *mut *mut libc::c_char;
    let mut zVfs: *const libc::c_char = 0 as *const libc::c_char;
    setvbuf(
        stderr,
        0 as *mut libc::c_char,
        2 as libc::c_int,
        0 as libc::c_int as size_t,
    );
    stdin_is_interactive = isatty(0 as libc::c_int);
    stdout_is_console = isatty(1 as libc::c_int);
    if !getenv(b"SQLITE_DEBUG_BREAK\x00" as *const u8 as *const libc::c_char).is_null() {
        if isatty(0 as libc::c_int) != 0 && isatty(2 as libc::c_int) != 0 {
            fprintf(
                stderr,
                b"attach debugger to process %d and press any key to continue.\n\x00" as *const u8
                    as *const libc::c_char,
                getpid(),
            );
            fgetc(stdin);
        } else {
            raise(5 as libc::c_int);
        }
    }
    if strncmp(
        sqlite3_sourceid(),
        b"2021-10-17 10:31:09 03dff7196bb00f8e32f574f65745ceafb33ee3fdd169263121342859c362alt1\x00"
            as *const u8 as *const libc::c_char,
        60 as libc::c_int as libc::c_ulong,
    ) != 0 as libc::c_int
    {
        fprintf(stderr,
                b"SQLite header and source version mismatch\n%s\n%s\n\x00" as
                    *const u8 as *const libc::c_char, sqlite3_sourceid(),
                b"2021-10-17 10:31:09 03dff7196bb00f8e32f574f65745ceafb33ee3fdd169263121342859c362alt1\x00"
                    as *const u8 as *const libc::c_char);
        exit(1 as libc::c_int);
    } else {
        main_init(&mut data);
        /* On Windows, we must translate command-line arguments into UTF-8.
         ** The SQLite memory allocator subsystem has to be enabled in order to
         ** do this.  But we want to run an sqlite3_shutdown() afterwards so that
         ** subsequent sqlite3_config() calls will work.  So copy all results into
         ** memory that does not come from the SQLite memory allocator.
         */
        Argv0 = *argv.offset(0 as libc::c_int as isize);
        /* Make sure we have a valid signal handler early, before anything
         ** else is done.
         */
        signal(
            2 as libc::c_int,
            Some(interrupt_handler as unsafe extern "C" fn(_: libc::c_int) -> ()),
        );
        /* Do an initial pass through the command-line argument to locate
         ** the name of the database file, the name of the initialization file,
         ** the size of the alternative malloc heap,
         ** and the first command to execute.
         */
        verify_uninitialized();
        i = 1 as libc::c_int;
        while i < argc {
            let mut z: *mut libc::c_char = 0 as *mut libc::c_char;
            z = *argv.offset(i as isize);
            if *z.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32 {
                if (*data.aAuxDb.as_mut_ptr()).zDbFilename.is_null() {
                    let ref mut fresh100 = (*data.aAuxDb.as_mut_ptr()).zDbFilename;
                    *fresh100 = z
                } else {
                    /* Excesss arguments are interpreted as SQL (or dot-commands) and
                     ** mean that nothing is read from stdin */
                    readStdin = 0 as libc::c_int;
                    nCmd += 1;
                    azCmd = realloc(
                        azCmd as *mut libc::c_void,
                        (::std::mem::size_of::<*mut libc::c_char>() as libc::c_ulong)
                            .wrapping_mul(nCmd as libc::c_ulong),
                    ) as *mut *mut libc::c_char;
                    if azCmd.is_null() {
                        shell_out_of_memory();
                    }
                    let ref mut fresh101 = *azCmd.offset((nCmd - 1 as libc::c_int) as isize);
                    *fresh101 = z
                }
            }
            if *z.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                z = z.offset(1)
            }
            if strcmp(z, b"-separator\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
                || strcmp(z, b"-nullvalue\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                || strcmp(z, b"-newline\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                || strcmp(z, b"-cmd\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
            {
                i += 1;
                cmdline_option_value(argc, argv, i);
            } else if strcmp(z, b"-init\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                zInitFile = cmdline_option_value(argc, argv, i)
            } else if strcmp(z, b"-batch\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                /* Need to check for batch mode here to so we can avoid printing
                 ** informational messages (like from process_sqliterc) before
                 ** we do the actual processing of arguments later in a second pass.
                 */
                stdin_is_interactive = 0 as libc::c_int
            } else if strcmp(z, b"-heap\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                cmdline_option_value(argc, argv, i);
            } else if strcmp(z, b"-pagecache\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n: sqlite3_int64 = 0;
                let mut sz: sqlite3_int64 = 0;
                i += 1;
                sz = integerValue(cmdline_option_value(argc, argv, i));
                if sz > 70000 as libc::c_int as libc::c_longlong {
                    sz = 70000 as libc::c_int as sqlite3_int64
                }
                if sz < 0 as libc::c_int as libc::c_longlong {
                    sz = 0 as libc::c_int as sqlite3_int64
                }
                i += 1;
                n = integerValue(cmdline_option_value(argc, argv, i));
                if sz > 0 as libc::c_int as libc::c_longlong
                    && n > 0 as libc::c_int as libc::c_longlong
                    && 0xffffffffffff as libc::c_longlong / sz < n
                {
                    n = 0xffffffffffff as libc::c_longlong / sz
                }
                sqlite3_config(
                    7 as libc::c_int,
                    if n > 0 as libc::c_int as libc::c_longlong
                        && sz > 0 as libc::c_int as libc::c_longlong
                    {
                        malloc((n * sz) as libc::c_ulong)
                    } else {
                        0 as *mut libc::c_void
                    },
                    sz,
                    n,
                );
                data.shellFlgs |= 0x1 as libc::c_int as libc::c_uint
            } else if strcmp(z, b"-lookaside\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n_0: libc::c_int = 0;
                let mut sz_0: libc::c_int = 0;
                i += 1;
                sz_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                if sz_0 < 0 as libc::c_int {
                    sz_0 = 0 as libc::c_int
                }
                i += 1;
                n_0 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                if n_0 < 0 as libc::c_int {
                    n_0 = 0 as libc::c_int
                }
                sqlite3_config(13 as libc::c_int, sz_0, n_0);
                if sz_0 * n_0 == 0 as libc::c_int {
                    data.shellFlgs &= !(0x2 as libc::c_int) as libc::c_uint
                }
            } else if strcmp(z, b"-threadsafe\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                let mut n_1: libc::c_int = 0;
                i += 1;
                n_1 = integerValue(cmdline_option_value(argc, argv, i)) as libc::c_int;
                match n_1 {
                    0 => {
                        sqlite3_config(1 as libc::c_int);
                    }
                    2 => {
                        sqlite3_config(2 as libc::c_int);
                    }
                    _ => {
                        sqlite3_config(3 as libc::c_int);
                    }
                }
            } else if strcmp(z, b"-mmap\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                i += 1;
                let mut sz_1: sqlite3_int64 = integerValue(cmdline_option_value(argc, argv, i));
                sqlite3_config(22 as libc::c_int, sz_1, sz_1);
            } else if strcmp(z, b"-vfs\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
            {
                i += 1;
                zVfs = cmdline_option_value(argc, argv, i)
            } else if strcmp(z, b"-zip\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
            {
                data.openMode = 3 as libc::c_int as u8_0
            } else if strcmp(z, b"-append\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 2 as libc::c_int as u8_0
            } else if strcmp(z, b"-deserialize\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 5 as libc::c_int as u8_0
            } else if strcmp(z, b"-maxsize\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
                && (i + 1 as libc::c_int) < argc
            {
                i += 1;
                data.szMax = integerValue(*argv.offset(i as isize))
            } else if strcmp(z, b"-readonly\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openMode = 4 as libc::c_int as u8_0
            } else if strcmp(z, b"-nofollow\x00" as *const u8 as *const libc::c_char)
                == 0 as libc::c_int
            {
                data.openFlags = 0x1000000 as libc::c_int
            } else {
                if strncmp(
                    z,
                    b"-A\x00" as *const u8 as *const libc::c_char,
                    2 as libc::c_int as libc::c_ulong,
                ) == 0 as libc::c_int
                {
                    break;
                }
                if strcmp(z, b"-memtrace\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    sqlite3MemTraceActivate(stderr);
                } else if strcmp(z, b"-bail\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    bail_on_error = 1 as libc::c_int
                } else if strcmp(z, b"-nonce\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    free(data.zNonce as *mut libc::c_void);
                    i += 1;
                    data.zNonce = strdup(*argv.offset(i as isize))
                } else {
                    let _ = (strcmp(z, b"-safe\x00" as *const u8 as *const libc::c_char))
                        == 0 as libc::c_int;
                }
            }
            i += 1
            /* no-op - catch this on the second pass */
        }
        /* All remaining command-line arguments are passed to the ".archive"
         ** command, so ignore them */
        verify_uninitialized();
        /* All the sqlite3_config() calls have now been made. So it is safe
         ** to call sqlite3_initialize() and process any command line -vfs option. */
        sqlite3_initialize();
        if !zVfs.is_null() {
            let mut pVfs: *mut sqlite3_vfs = sqlite3_vfs_find(zVfs);
            if !pVfs.is_null() {
                sqlite3_vfs_register(pVfs, 1 as libc::c_int);
            } else {
                fprintf(
                    stderr,
                    b"no such VFS: \"%s\"\n\x00" as *const u8 as *const libc::c_char,
                    *argv.offset(i as isize),
                );
                exit(1 as libc::c_int);
            }
        }
        if (*data.pAuxDb).zDbFilename.is_null() {
            (*data.pAuxDb).zDbFilename = b":memory:\x00" as *const u8 as *const libc::c_char;
            warnInmemoryDb = (argc == 1 as libc::c_int) as libc::c_int
        }
        data.out = stdout;
        sqlite3_appendvfs_init(
            0 as *mut sqlite3,
            0 as *mut *mut libc::c_char,
            0 as *const sqlite3_api_routines,
        );
        /* Go ahead and open the database file if it already exists.  If the
         ** file does not exist, delay opening it.  This prevents empty database
         ** files from being created if a user mistypes the database name argument
         ** to the sqlite command-line tool.
         */
        if access((*data.pAuxDb).zDbFilename, 0 as libc::c_int) == 0 as libc::c_int {
            open_db(&mut data, 0 as libc::c_int);
        }
        /* Process the initialization file if there is one.  If no -init option
         ** is given on the command line, look for a file named ~/.sqliterc and
         ** try to process it.
         */
        process_sqliterc(&mut data, zInitFile);
        /* Make a second pass through the command-line argument and set
         ** options.  This second pass is delayed until after the initialization
         ** file is processed so that the command-line arguments will override
         ** settings in the initialization file.
         */
        i = 1 as libc::c_int;
        while i < argc {
            let mut z_0: *mut libc::c_char = *argv.offset(i as isize);
            if !(*z_0.offset(0 as libc::c_int as isize) as libc::c_int != '-' as i32) {
                if *z_0.offset(1 as libc::c_int as isize) as libc::c_int == '-' as i32 {
                    z_0 = z_0.offset(1)
                }
                if strcmp(z_0, b"-init\x00" as *const u8 as *const libc::c_char) == 0 as libc::c_int
                {
                    i += 1
                } else if strcmp(z_0, b"-html\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 4 as libc::c_int
                } else if strcmp(z_0, b"-list\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 2 as libc::c_int
                } else if strcmp(z_0, b"-quote\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 6 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.colSeparator.as_mut_ptr(),
                        b",\x00" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.rowSeparator.as_mut_ptr(),
                        b"\n\x00" as *const u8 as *const libc::c_char,
                    );
                } else if strcmp(z_0, b"-line\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 0 as libc::c_int
                } else if strcmp(z_0, b"-column\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 1 as libc::c_int
                } else if strcmp(z_0, b"-json\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 13 as libc::c_int
                } else if strcmp(z_0, b"-markdown\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 14 as libc::c_int
                } else if strcmp(z_0, b"-table\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 15 as libc::c_int
                } else if strcmp(z_0, b"-box\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 16 as libc::c_int
                } else if strcmp(z_0, b"-csv\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 8 as libc::c_int;
                    memcpy(
                        data.colSeparator.as_mut_ptr() as *mut libc::c_void,
                        b",\x00" as *const u8 as *const libc::c_char as *const libc::c_void,
                        2 as libc::c_int as libc::c_ulong,
                    );
                } else if strcmp(z_0, b"-zip\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.openMode = 3 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-append\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.openMode = 2 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-deserialize\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.openMode = 5 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-maxsize\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                    && (i + 1 as libc::c_int) < argc
                {
                    i += 1;
                    data.szMax = integerValue(*argv.offset(i as isize))
                } else if strcmp(z_0, b"-readonly\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.openMode = 4 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-nofollow\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.openFlags |= 0x1000000 as libc::c_int
                } else if strcmp(z_0, b"-ascii\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 10 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.colSeparator.as_mut_ptr(),
                        b"\x1f\x00" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.rowSeparator.as_mut_ptr(),
                        b"\x1e\x00" as *const u8 as *const libc::c_char,
                    );
                } else if strcmp(z_0, b"-tabs\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.mode = 2 as libc::c_int;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.colSeparator.as_mut_ptr(),
                        b"\t\x00" as *const u8 as *const libc::c_char,
                    );
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.rowSeparator.as_mut_ptr(),
                        b"\n\x00" as *const u8 as *const libc::c_char,
                    );
                } else if strcmp(z_0, b"-separator\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.colSeparator.as_mut_ptr(),
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        cmdline_option_value(argc, argv, i),
                    );
                } else if strcmp(z_0, b"-newline\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.rowSeparator.as_mut_ptr(),
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        cmdline_option_value(argc, argv, i),
                    );
                } else if strcmp(z_0, b"-nullvalue\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    i += 1;
                    sqlite3_snprintf(
                        ::std::mem::size_of::<[libc::c_char; 20]>() as libc::c_ulong as libc::c_int,
                        data.nullValue.as_mut_ptr(),
                        b"%s\x00" as *const u8 as *const libc::c_char,
                        cmdline_option_value(argc, argv, i),
                    );
                } else if strcmp(z_0, b"-header\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.showHeader = 1 as libc::c_int;
                    data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint
                } else if strcmp(z_0, b"-noheader\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.showHeader = 0 as libc::c_int;
                    data.shellFlgs |= 0x80 as libc::c_int as libc::c_uint
                } else if strcmp(z_0, b"-echo\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.shellFlgs |= 0x40 as libc::c_int as libc::c_uint
                } else if strcmp(z_0, b"-eqp\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.autoEQP = 1 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-eqpfull\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.autoEQP = 3 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-stats\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.statsOn = 1 as libc::c_int as libc::c_uint
                } else if strcmp(z_0, b"-scanstats\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    data.scanstatsOn = 1 as libc::c_int as u8_0
                } else if strcmp(z_0, b"-backslash\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int
                {
                    /* Undocumented command-line option: -backslash
                     ** Causes C-style backslash escapes to be evaluated in SQL statements
                     ** prior to sending the SQL into SQLite.  Useful for injecting
                     ** crazy bytes in the middle of SQL statements for testing and debugging.
                     */
                    data.shellFlgs |= 0x4 as libc::c_int as libc::c_uint
                } else if !(strcmp(z_0, b"-bail\x00" as *const u8 as *const libc::c_char)
                    == 0 as libc::c_int)
                {
                    if strcmp(z_0, b"-version\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        printf(
                            b"%s %s\n\x00" as *const u8 as *const libc::c_char,
                            sqlite3_libversion(),
                            sqlite3_sourceid(),
                        );
                        return 0 as libc::c_int;
                    } else if strcmp(z_0, b"-interactive\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        stdin_is_interactive = 1 as libc::c_int
                    } else if strcmp(z_0, b"-batch\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        stdin_is_interactive = 0 as libc::c_int
                    } else if strcmp(z_0, b"-heap\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 1
                    } else if strcmp(z_0, b"-pagecache\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int
                    } else if strcmp(z_0, b"-lookaside\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int
                    } else if strcmp(z_0, b"-threadsafe\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int
                    } else if strcmp(z_0, b"-nonce\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 2 as libc::c_int
                    } else if strcmp(z_0, b"-mmap\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 1
                    } else if strcmp(z_0, b"-memtrace\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 1
                    } else if strcmp(z_0, b"-vfs\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        i += 1
                    } else if strcmp(z_0, b"-help\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        usage(1 as libc::c_int);
                    } else if strcmp(z_0, b"-cmd\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        /* Run commands that follow -cmd first and separately from commands
                         ** that simply appear on the command-line.  This seems goofy.  It would
                         ** be better if all commands ran in the order that they appear.  But
                         ** we retain the goofy behavior for historical compatibility. */
                        if i == argc - 1 as libc::c_int {
                            break;
                        }
                        i += 1;
                        z_0 = cmdline_option_value(argc, argv, i);
                        if *z_0.offset(0 as libc::c_int as isize) as libc::c_int == '.' as i32 {
                            rc = do_meta_command(z_0, &mut data);
                            if rc != 0 && bail_on_error != 0 {
                                return if rc == 2 as libc::c_int {
                                    0 as libc::c_int
                                } else {
                                    rc
                                };
                            }
                        } else {
                            open_db(&mut data, 0 as libc::c_int);
                            rc = shell_exec(&mut data, z_0, &mut zErrMsg);
                            if !zErrMsg.is_null() {
                                fprintf(
                                    stderr,
                                    b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                    zErrMsg,
                                );
                                if bail_on_error != 0 {
                                    return if rc != 0 as libc::c_int {
                                        rc
                                    } else {
                                        1 as libc::c_int
                                    };
                                }
                            } else if rc != 0 as libc::c_int {
                                fprintf(
                                    stderr,
                                    b"Error: unable to process SQL \"%s\"\n\x00" as *const u8
                                        as *const libc::c_char,
                                    z_0,
                                );
                                if bail_on_error != 0 {
                                    return rc;
                                }
                            }
                        }
                    } else if strncmp(
                        z_0,
                        b"-A\x00" as *const u8 as *const libc::c_char,
                        2 as libc::c_int as libc::c_ulong,
                    ) == 0 as libc::c_int
                    {
                        if nCmd > 0 as libc::c_int {
                            fprintf(
                                stderr,
                                b"Error: cannot mix regular SQL or dot-commands with \"%s\"\n\x00"
                                    as *const u8
                                    as *const libc::c_char,
                                z_0,
                            );
                            return 1 as libc::c_int;
                        } else {
                            open_db(&mut data, 0x2 as libc::c_int);
                            if *z_0.offset(2 as libc::c_int as isize) != 0 {
                                let ref mut fresh102 = *argv.offset(i as isize);
                                *fresh102 = &mut *z_0.offset(2 as libc::c_int as isize)
                                    as *mut libc::c_char;
                                arDotCommand(
                                    &mut data,
                                    1 as libc::c_int,
                                    argv.offset((i - 1 as libc::c_int) as isize),
                                    argc - (i - 1 as libc::c_int),
                                );
                            } else {
                                arDotCommand(
                                    &mut data,
                                    1 as libc::c_int,
                                    argv.offset(i as isize),
                                    argc - i,
                                );
                            }
                            readStdin = 0 as libc::c_int;
                            break;
                        }
                    } else if strcmp(z_0, b"-safe\x00" as *const u8 as *const libc::c_char)
                        == 0 as libc::c_int
                    {
                        data.bSafeModePersist = 1 as libc::c_int as u8_0;
                        data.bSafeMode = data.bSafeModePersist
                    } else {
                        fprintf(
                            stderr,
                            b"%s: Error: unknown option: %s\n\x00" as *const u8
                                as *const libc::c_char,
                            Argv0,
                            z_0,
                        );
                        fprintf(
                            stderr,
                            b"Use -help for a list of options.\n\x00" as *const u8
                                as *const libc::c_char,
                        );
                        return 1 as libc::c_int;
                    }
                }
                data.cMode = data.mode
                /* No-op.  The bail_on_error flag should already be set. */
            }
            i += 1
        }
        if readStdin == 0 {
            /* Run all arguments that do not begin with '-' as if they were separate
             ** command-line inputs, except for the argToSkip argument which contains
             ** the database filename.
             */
            i = 0 as libc::c_int;
            while i < nCmd {
                if *(*azCmd.offset(i as isize)).offset(0 as libc::c_int as isize) as libc::c_int
                    == '.' as i32
                {
                    rc = do_meta_command(*azCmd.offset(i as isize), &mut data);
                    if rc != 0 {
                        free(azCmd as *mut libc::c_void);
                        return if rc == 2 as libc::c_int {
                            0 as libc::c_int
                        } else {
                            rc
                        };
                    }
                } else {
                    open_db(&mut data, 0 as libc::c_int);
                    rc = shell_exec(&mut data, *azCmd.offset(i as isize), &mut zErrMsg);
                    if !zErrMsg.is_null() || rc != 0 {
                        if !zErrMsg.is_null() {
                            fprintf(
                                stderr,
                                b"Error: %s\n\x00" as *const u8 as *const libc::c_char,
                                zErrMsg,
                            );
                        } else {
                            fprintf(
                                stderr,
                                b"Error: unable to process SQL: %s\n\x00" as *const u8
                                    as *const libc::c_char,
                                *azCmd.offset(i as isize),
                            );
                        }
                        sqlite3_free(zErrMsg as *mut libc::c_void);
                        free(azCmd as *mut libc::c_void);
                        return if rc != 0 as libc::c_int {
                            rc
                        } else {
                            1 as libc::c_int
                        };
                    }
                }
                i += 1
            }
        } else if stdin_is_interactive != 0 {
            let mut zHome: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut zHistory: *mut libc::c_char = 0 as *mut libc::c_char;
            let mut nHistory: libc::c_int = 0;
            printf(
                b"SQLite version %s %.19s\nEnter \".help\" for usage hints.\n\x00" as *const u8
                    as *const libc::c_char,
                sqlite3_libversion(),
                sqlite3_sourceid(),
            );
            if warnInmemoryDb != 0 {
                printf(b"Connected to a \x00" as *const u8 as *const libc::c_char);
                printBold(b"transient in-memory database\x00" as *const u8 as *const libc::c_char);
                printf(
                    b".\nUse \".open FILENAME\" to reopen on a persistent database.\n\x00"
                        as *const u8 as *const libc::c_char,
                );
            }
            zHistory = getenv(b"SQLITE_HISTORY\x00" as *const u8 as *const libc::c_char);
            if !zHistory.is_null() {
                zHistory = strdup(zHistory)
            } else {
                zHome = find_home_dir(0 as libc::c_int);
                if !zHome.is_null() {
                    nHistory = strlen30(zHome) + 20 as libc::c_int;
                    zHistory = malloc(nHistory as libc::c_ulong) as *mut libc::c_char;
                    if !zHistory.is_null() {
                        sqlite3_snprintf(
                            nHistory,
                            zHistory,
                            b"%s/.sqlite_history\x00" as *const u8 as *const libc::c_char,
                            zHome,
                        );
                    }
                }
            }
            if !zHistory.is_null() {
                read_history(zHistory);
            }
            rl_attempted_completion_function = Some(
                readline_completion
                    as unsafe extern "C" fn(
                        _: *const libc::c_char,
                        _: libc::c_int,
                        _: libc::c_int,
                    ) -> *mut *mut libc::c_char,
            );
            data.in_0 = 0 as *mut FILE;
            rc = process_input(&mut data);
            if !zHistory.is_null() {
                stifle_history(2000 as libc::c_int);
                write_history(zHistory);
                free(zHistory as *mut libc::c_void);
            }
        } else {
            data.in_0 = stdin;
            rc = process_input(&mut data)
        }
        free(azCmd as *mut libc::c_void);
        set_table_name(&mut data, 0 as *const libc::c_char);
        if !data.db.is_null() {
            close_db(data.db);
        }
        i = 0 as libc::c_int;
        while i
            < (::std::mem::size_of::<[AuxDb; 5]>() as libc::c_ulong)
                .wrapping_div(::std::mem::size_of::<AuxDb>() as libc::c_ulong)
                as libc::c_int
        {
            sqlite3_free(data.aAuxDb[i as usize].zFreeOnClose as *mut libc::c_void);
            if !data.aAuxDb[i as usize].db.is_null() {
                close_db(data.aAuxDb[i as usize].db);
            }
            i += 1
        }
        find_home_dir(1 as libc::c_int);
        output_reset(&mut data);
        data.doXdgOpen = 0 as libc::c_int as u8_0;
        clearTempFile(&mut data);
        free(data.colWidth as *mut libc::c_void);
        free(data.zNonce as *mut libc::c_void);
        /* Run commands received from standard input
         */
        /* Clear the global data structure so that valgrind will detect memory
         ** leaks */
        memset(
            &mut data as *mut ShellState as *mut libc::c_void,
            0 as libc::c_int,
            ::std::mem::size_of::<ShellState>() as libc::c_ulong,
        );
        return rc;
    };
}
#[main]
pub fn main() {
    let mut args: Vec<*mut libc::c_char> = Vec::new();
    for arg in ::std::env::args() {
        args.push(
            ::std::ffi::CString::new(arg)
                .expect("Failed to convert argument into CString.")
                .into_raw(),
        );
    }
    args.push(::std::ptr::null_mut());
    unsafe {
        ::std::process::exit(main_0(
            (args.len() - 1) as libc::c_int,
            args.as_mut_ptr() as *mut *mut libc::c_char,
        ) as i32)
    }
}
